import { CacheOptions, CacheEntry, CacheAlarm, CacheEvent, CacheEventHandler } from './types';
export declare class Cache<K = string, V = any> {
    private storage;
    private maxEntries;
    private maxBytes?;
    private ttl?;
    private cleanupInterval?;
    private cleanupTimer?;
    private alarm?;
    private autoDeleteAfterUse?;
    private mergeAllowDuplicates?;
    private evictionPolicy;
    private eventListeners;
    constructor(options?: CacheOptions);
    /**
     * Set a value in the cache
     */
    set(key: K, value: V): void;
    /**
     * Set multiple values at once
     */
    setMany(entries: Array<[K, V]>): void;
    /**
     * Get a value from the cache
     */
    get(key: K): V | undefined;
    /**
     * Get multiple values at once
     * Returns only existing values (filters out undefined)
     */
    getMany(keys: K[]): V[];
    /**
     * Check if a key exists in the cache
     */
    has(key: K): boolean;
    /**
     * Get entry with metadata (createdAt, expiresAt)
     */
    getEntry(key: K): CacheEntry<V> | undefined;
    /**
     * Peek at a value without updating access time or triggering auto-delete
     * Useful for checking values without affecting eviction order
     */
    peek(key: K): V | undefined;
    /**
     * Delete a value from the cache
     */
    delete(key: K): boolean;
    /**
     * Delete multiple values at once
     */
    deleteMany(keys: K[]): number;
    /**
     * Clear all entries from the cache
     */
    clear(): void;
    /**
     * Update an existing value using a function
     * @template T - Optional type parameter for better type inference in updater function (must extend V)
     */
    mutate<T extends V = V>(key: K, updater: (value: T) => T): T | undefined;
    /**
     * Update an existing value, or set if it doesn't exist
     */
    upsert(key: K, valueOrUpdater: V | ((value: V | undefined) => V)): V;
    /**
     * Increment a numeric value
     * Note: Only works when V is number
     */
    increment(key: K, amount?: number): number | undefined;
    /**
     * Decrement a numeric value
     * Note: Only works when V is number
     */
    decrement(key: K, amount?: number): number | undefined;
    /**
     * Append to an array value
     * Note: Only works when V is an array type
     */
    append<T>(key: K, ...items: T[]): T[] | undefined;
    /**
     * Merge values based on type:
     * - Objects: Shallow merge properties
     * - Arrays: Concatenate (with optional duplicate filtering)
     * - Strings: Concatenate
     * - Numbers: Concatenate as strings then convert back to number (4 + 2 = 42)
     */
    merge(key: K, updates: any, options?: {
        allowDuplicates?: boolean;
    }): V | undefined;
    /**
     * Get the size of the cache (number of entries)
     */
    size(): number;
    /**
     * Get the size of the cache in bytes
     */
    sizeInBytes(): number;
    /**
     * Get all keys in the cache
     */
    keys(): K[];
    /**
     * Get all values in the cache
     */
    values(): V[];
    /**
     * Get all entries in the cache
     */
    entries(): Array<[K, V]>;
    /**
     * Check if cache is empty
     */
    isEmpty(): boolean;
    /**
     * Get a random key from the cache
     */
    randomKey(): K | undefined;
    /**
     * Cleanup expired entries manually
     */
    cleanupExpired(): number;
    /**
     * Start automatic cleanup of expired entries
     */
    private startCleanup;
    /**
     * Stop automatic cleanup
     */
    stopCleanup(): void;
    /**
     * Destroy the cache and cleanup resources
     */
    destroy(): void;
    /**
     * Register an event listener
     * @param key - The key to listen to, or '*' for all keys
     * @param eventOrHandler - The event name, or handler if event is omitted
     * @param handler - The handler function (optional if event is omitted)
     */
    on(key: K | '*', eventOrHandler: CacheEvent | '*' | CacheEventHandler<K, V>, handler?: CacheEventHandler<K, V>): void;
    /**
     * Remove an event listener
     */
    off(key: K | '*', eventOrHandler?: CacheEvent | '*' | CacheEventHandler<K, V>, handler?: CacheEventHandler<K, V>): void;
    /**
     * Emit an event (internal use)
     */
    private emit;
    /**
     * Emit event for a specific key (internal use)
     */
    private emitForKey;
    /**
     * Get alarm configuration (used internally by registry)
     */
    getAlarmConfig(): CacheAlarm | undefined;
    private getSetOperations;
    private getGetOperations;
    private getDeleteOperations;
    private getMutateOperations;
    private getUtilityOperations;
    private getCleanupOperations;
}
//# sourceMappingURL=cache.d.ts.map