'use strict';

class CacheRegistry {
    static register(instance) {
        this.instances.add(instance);
        this.instanceInfo.set(instance, {
            instance,
            createdAt: Date.now(),
            lastSizeCheck: 0,
        });
    }
    static unregister(instance) {
        this.instanceInfo.delete(instance);
    }
    static checkAllInstances() {
        for (const [instance, info] of this.instanceInfo.entries()) {
            const currentSize = instance.sizeInBytes();
            // Update lastSizeCheck
            info.lastSizeCheck = currentSize;
            // Get alarm callbacks from the instance
            const alarm = instance.getAlarmConfig();
            // Check thresholds
            if (currentSize >= this.CRITICAL_THRESHOLD_BYTES) {
                if (alarm?.onCritical) {
                    alarm.onCritical();
                }
                else {
                    // Standard critical
                    const remaining = this.MAX_SAFE_BYTES - currentSize;
                    const remainingGB = (remaining / (1024 * 1024 * 1024)).toFixed(1);
                    console.warn(`⚠️ CRITICAL: You have ${remainingGB}GB before you are at risk at node engine crash`);
                }
            }
            else if (currentSize >= this.WARNING_THRESHOLD_BYTES) {
                if (alarm?.onWarning) {
                    alarm.onWarning();
                }
                else {
                    // Standard warning
                    const maxSizeGB = (this.MAX_SAFE_BYTES /
                        (1024 * 1024 * 1024)).toFixed(1);
                    console.warn(`⚠️ WARNING: Cache is reaching dangerous level, max size is ${maxSizeGB}GB`);
                }
            }
        }
    }
    static startMonitoring(interval = 5000) {
        // Stop any existing monitoring
        if (this.monitoringInterval) {
            this.stopMonitoring();
        }
        // Start monitoring (works in both Node.js and browser)
        if (typeof setInterval !== 'undefined') {
            this.monitoringInterval = setInterval(() => {
                this.checkAllInstances();
            }, interval);
        }
    }
    static stopMonitoring() {
        if (this.monitoringInterval && typeof clearInterval !== 'undefined') {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = undefined;
        }
    }
    static getInstanceCount() {
        return this.instanceInfo.size;
    }
    static getAllInstances() {
        return Array.from(this.instanceInfo.keys());
    }
}
CacheRegistry.instances = new WeakSet();
CacheRegistry.instanceInfo = new Map();
// Standard thresholds
CacheRegistry.WARNING_THRESHOLD_BYTES = 1 * 1024 * 1024 * 1024; // 1GB
CacheRegistry.CRITICAL_THRESHOLD_BYTES = 1.5 * 1024 * 1024 * 1024; // 1.5GB
CacheRegistry.MAX_SAFE_BYTES = 1.6 * 1024 * 1024 * 1024; // 1.6GB

/**
 * Calculate the approximate size in bytes of a JavaScript value
 */
function getSizeInBytes(obj) {
    if (obj === null || obj === undefined) {
        return 0;
    }
    let size = 0;
    switch (typeof obj) {
        case 'number':
            size = 8; // 64-bit float
            break;
        case 'string':
            size = obj.length * 2; // UTF-16, 2 bytes per char
            break;
        case 'boolean':
            size = 4; // Boolean
            break;
        case 'object':
            if (Array.isArray(obj)) {
                size = obj.reduce((acc, item) => acc + getSizeInBytes(item), 0);
            }
            else if (obj instanceof Date) {
                size = 8; // Date object
            }
            else if (obj instanceof Map) {
                // For Map, iterate over entries
                for (const [key, value] of obj.entries()) {
                    size += getSizeInBytes(key);
                    size += getSizeInBytes(value);
                }
            }
            else if (obj instanceof Set) {
                // For Set, iterate over values
                for (const value of obj.values()) {
                    size += getSizeInBytes(value);
                }
            }
            else {
                // Plain object
                for (const key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        size += getSizeInBytes(key); // Key size
                        size += getSizeInBytes(obj[key]); // Value size
                    }
                }
            }
            break;
        case 'function':
            size = 0; // Functions are not serialized
            break;
        case 'symbol':
            size = 0; // Symbols are not serialized
            break;
        case 'bigint':
            size = 8; // BigInt
            break;
    }
    return size;
}
/**
 * Calculate the size of a single cache entry (key + value + overhead)
 * This matches the calculation used in getCacheSizeInBytes for consistency
 */
function getEntrySize(key, value) {
    return (getSizeInBytes(key) + // Key size
        getSizeInBytes(value) + // Value size
        48 + // Map entry overhead + object overhead
        16 // Metadata (createdAt, expiresAt, lastAccessed) - 2-3 numbers * 8 bytes
    );
}
/**
 * Calculate the total size in bytes of a cache storage
 */
function getCacheSizeInBytes(storage) {
    let totalSize = 0;
    for (const [key, entry] of storage.entries()) {
        // Size of key
        totalSize += getSizeInBytes(key);
        // Size of entry object overhead (~48 bytes for Map entry + object overhead)
        totalSize += 48;
        // Size of value
        totalSize += getSizeInBytes(entry.value);
        // Size of metadata (createdAt, expiresAt, lastAccessed)
        totalSize += 16; // 2-3 numbers * 8 bytes
    }
    return totalSize;
}

/**
 * Find the least recently used key (for LRU eviction)
 * Returns undefined if storage is empty
 */
function findLRUKey(storage) {
    if (storage.size === 0) {
        return undefined;
    }
    let oldestKey;
    let oldestTime = Infinity;
    for (const [key, entry] of storage.entries()) {
        const accessTime = entry.lastAccessed ?? entry.createdAt;
        if (accessTime < oldestTime) {
            oldestTime = accessTime;
            oldestKey = key;
        }
    }
    return oldestKey;
}
/**
 * Set a value in the cache
 */
function set(operations, key, value) {
    const { storage, maxEntries, maxBytes, ttl, evictionPolicy = 'FIFO', } = operations;
    const now = Date.now();
    // Check if key already exists (before eviction)
    const existingEntry = storage.get(key);
    const isNewKey = !existingEntry;
    // If maxBytes is set, use bytes-based limit
    if (maxBytes) {
        const entrySize = getEntrySize(key, value);
        // If entry is larger than maxBytes, we'll remove all existing entries
        // and set it anyway (user's choice to set a large entry)
        // Remove entries until we have space
        while (storage.size > 0) {
            const currentSize = getCacheSizeInBytes(storage);
            if (currentSize + entrySize <= maxBytes) {
                break;
            }
            // Choose eviction based on policy
            // For LRU, don't consider the key we're about to set (if it's new)
            const keyToRemove = evictionPolicy === 'LRU'
                ? findLRUKey(storage)
                : storage.keys().next().value;
            // If no key to remove or keyToRemove is the key we're setting, break
            if (keyToRemove === undefined || keyToRemove === key) {
                break;
            }
            storage.delete(keyToRemove);
        }
        // Note: Entry will be set even if entrySize > maxBytes
        // This allows users to set large entries, clearing the cache if needed
    }
    else {
        // Fallback to entries-based limit
        if (storage.size >= maxEntries && isNewKey) {
            // Choose eviction based on policy
            const keyToRemove = evictionPolicy === 'LRU'
                ? findLRUKey(storage)
                : storage.keys().next().value;
            if (keyToRemove !== undefined) {
                storage.delete(keyToRemove);
            }
        }
    }
    // Create entry
    const entry = {
        value,
        createdAt: existingEntry?.createdAt ?? now,
        // For LRU: set lastAccessed when creating/updating entry
        lastAccessed: evictionPolicy === 'LRU' ? now : existingEntry?.lastAccessed,
        expiresAt: ttl ? now + ttl : undefined,
    };
    storage.set(key, entry);
}
/**
 * Set multiple values at once
 */
function setMany(operations, entries) {
    entries.forEach(([key, value]) => {
        set(operations, key, value);
    });
}

/**
 * Get a value from the cache
 */
function get(operations, key) {
    const { storage, autoDeleteAfterUse, evictionPolicy = 'FIFO' } = operations;
    const entry = storage.get(key);
    if (!entry) {
        return undefined;
    }
    // Check if expired
    if (entry.expiresAt && Date.now() > entry.expiresAt) {
        storage.delete(key);
        return undefined;
    }
    const value = entry.value;
    // Update lastAccessed for LRU policy
    if (evictionPolicy === 'LRU' && !autoDeleteAfterUse) {
        entry.lastAccessed = Date.now();
    }
    // Auto-delete after use if enabled
    if (autoDeleteAfterUse) {
        storage.delete(key);
    }
    return value;
}
/**
 * Get multiple values at once
 * Returns only existing values (filters out undefined)
 */
function getMany(operations, keys) {
    return keys
        .map((key) => get(operations, key))
        .filter((value) => value !== undefined);
}
/**
 * Check if a key exists in the cache
 */
function has(operations, key) {
    const { storage } = operations;
    const entry = storage.get(key);
    if (!entry) {
        return false;
    }
    // Check if expired
    if (entry.expiresAt && Date.now() > entry.expiresAt) {
        storage.delete(key);
        return false;
    }
    return true;
}
/**
 * Get entry with metadata (createdAt, expiresAt, ttlLeft, age)
 */
function getEntry(operations, key) {
    const { storage } = operations;
    const entry = storage.get(key);
    if (!entry) {
        return undefined;
    }
    const now = Date.now();
    // Check if expired
    if (entry.expiresAt && now > entry.expiresAt) {
        storage.delete(key);
        return undefined;
    }
    // Calculate age
    const age = now - entry.createdAt;
    // Calculate ttlLeft if expiresAt exists
    const ttlLeft = entry.expiresAt ? entry.expiresAt - now : undefined;
    return {
        ...entry,
        age,
        ttlLeft,
    };
}
/**
 * Peek at a value without updating access time or triggering auto-delete
 * Useful for checking values without affecting eviction order
 */
function peek(operations, key) {
    const { storage } = operations;
    const entry = storage.get(key);
    if (!entry) {
        return undefined;
    }
    // Check if expired (but don't delete - just return undefined)
    if (entry.expiresAt && Date.now() > entry.expiresAt) {
        return undefined;
    }
    return entry.value;
}

/**
 * Delete a value from the cache
 */
function del(operations, key) {
    return operations.storage.delete(key);
}
/**
 * Delete multiple values at once
 */
function deleteMany(operations, keys) {
    let deleted = 0;
    keys.forEach((key) => {
        if (del(operations, key)) {
            deleted++;
        }
    });
    return deleted;
}
/**
 * Clear all entries from the cache
 */
function clear(operations) {
    operations.storage.clear();
}

/**
 * Update an existing value using a function
 */
function mutate(operations, key, updater) {
    const currentValue = get(operations, key);
    if (currentValue === undefined) {
        return undefined;
    }
    const newValue = updater(currentValue);
    set(operations, key, newValue);
    return newValue;
}
/**
 * Update an existing value, or set if it doesn't exist
 */
function upsert(operations, key, valueOrUpdater) {
    if (typeof valueOrUpdater === 'function') {
        const updater = valueOrUpdater;
        const currentValue = get(operations, key);
        const newValue = updater(currentValue);
        set(operations, key, newValue);
        return newValue;
    }
    else {
        set(operations, key, valueOrUpdater);
        return valueOrUpdater;
    }
}
/**
 * Increment a numeric value
 */
function increment(operations, key, amount = 1) {
    return mutate(operations, key, (value) => value + amount);
}
/**
 * Decrement a numeric value
 */
function decrement(operations, key, amount = 1) {
    return mutate(operations, key, (value) => value - amount);
}
/**
 * Append to an array value
 */
function append(operations, key, ...items) {
    return mutate(operations, key, (value) => [...value, ...items]);
}
/**
 * Merge values based on type:
 * - Objects: Shallow merge properties
 * - Arrays: Concatenate (with optional duplicate filtering)
 * - Strings: Concatenate
 * - Numbers: Concatenate as strings then convert back to number (4 + 2 = 42)
 */
function merge(operations, key, updates, options) {
    const currentValue = get(operations, key);
    if (currentValue === undefined) {
        return undefined;
    }
    const allowDuplicates = options?.allowDuplicates ?? false;
    let mergedValue;
    // Handle arrays
    if (Array.isArray(currentValue) && Array.isArray(updates)) {
        if (allowDuplicates) {
            mergedValue = [...currentValue, ...updates];
        }
        else {
            // Remove duplicates using Set for primitives, or deep comparison for objects
            const seen = new Set();
            const result = [];
            for (const item of [...currentValue, ...updates]) {
                const key = typeof item === 'object' && item !== null
                    ? JSON.stringify(item)
                    : String(item);
                if (!seen.has(key)) {
                    seen.add(key);
                    result.push(item);
                }
            }
            mergedValue = result;
        }
    }
    // Handle strings
    else if (typeof currentValue === 'string' && typeof updates === 'string') {
        mergedValue = currentValue + updates;
    }
    // Handle numbers
    else if (typeof currentValue === 'number' && typeof updates === 'number') {
        // Concatenate as strings then convert back to number
        mergedValue = Number(String(currentValue) + String(updates));
    }
    // Handle objects
    else if (typeof currentValue === 'object' &&
        currentValue !== null &&
        !Array.isArray(currentValue) &&
        typeof updates === 'object' &&
        updates !== null &&
        !Array.isArray(updates)) {
        mergedValue = { ...currentValue, ...updates };
    }
    // Fallback: return updates if types don't match
    else {
        mergedValue = updates;
    }
    set(operations, key, mergedValue);
    return mergedValue;
}

/**
 * Cleanup expired entries
 */
function cleanupExpired(operations) {
    const { storage, ttl } = operations;
    if (!ttl) {
        return 0;
    }
    let cleaned = 0;
    const now = Date.now();
    for (const [key, entry] of storage.entries()) {
        if (entry.expiresAt && now > entry.expiresAt) {
            storage.delete(key);
            cleaned++;
        }
    }
    return cleaned;
}
/**
 * Start automatic cleanup of expired entries
 */
function startCleanup(operations) {
    const { cleanupInterval, ttl } = operations;
    if (!ttl || !cleanupInterval) {
        return undefined;
    }
    if (typeof setInterval === 'undefined') {
        // Not available in all environments
        return undefined;
    }
    return setInterval(() => {
        cleanupExpired(operations);
    }, cleanupInterval);
}
/**
 * Stop automatic cleanup
 */
function stopCleanup(timer) {
    if (timer && typeof clearInterval !== 'undefined') {
        clearInterval(timer);
    }
}

/**
 * Get the size of the cache (number of entries)
 */
function size(operations) {
    cleanupExpired(operations);
    return operations.storage.size;
}
/**
 * Get the size of the cache in bytes
 */
function sizeInBytes(operations) {
    cleanupExpired(operations);
    return getCacheSizeInBytes(operations.storage);
}
/**
 * Get all keys in the cache
 */
function keys(operations) {
    cleanupExpired(operations);
    return Array.from(operations.storage.keys());
}
/**
 * Get all values in the cache
 */
function values(operations) {
    cleanupExpired(operations);
    return Array.from(operations.storage.values()).map((entry) => entry.value);
}
/**
 * Get all entries in the cache
 */
function entries(operations) {
    cleanupExpired(operations);
    return Array.from(operations.storage.entries()).map(([key, entry]) => [
        key,
        entry.value,
    ]);
}
/**
 * Check if cache is empty
 */
function isEmpty(operations) {
    return size(operations) === 0;
}
/**
 * Get a random key from the cache
 */
function randomKey(operations) {
    const allKeys = keys(operations);
    if (allKeys.length === 0) {
        return undefined;
    }
    const randomIndex = Math.floor(Math.random() * allKeys.length);
    return allKeys[randomIndex];
}

class Cache {
    constructor(options = {}) {
        this.eventListeners = new Map();
        this.storage = new Map();
        this.maxEntries = options.maxEntries || Infinity;
        this.maxBytes = options.maxBytes;
        this.ttl = options.ttl;
        this.cleanupInterval = options.cleanupInterval || 60000; // Default 1 minute
        this.evictionPolicy = options.evictionPolicy || 'FIFO'; // Default FIFO
        this.alarm = options.alarm;
        this.autoDeleteAfterUse = options.autoDeleteAfterUse;
        this.mergeAllowDuplicates = options.mergeAllowDuplicates;
        // Register the instance in the registry
        CacheRegistry.register(this);
        if (this.ttl && this.cleanupInterval)
            this.startCleanup();
    }
    // ========== Set Operations ==========
    /**
     * Set a value in the cache
     */
    set(key, value) {
        set(this.getSetOperations(), key, value);
        this.emit('set', key, value);
    }
    /**
     * Set multiple values at once
     */
    setMany(entries) {
        setMany(this.getSetOperations(), entries);
        const keys = entries.map(([k]) => k);
        const values = entries.map(([, v]) => v);
        this.emit('setMany', keys, values);
    }
    // ========== Get Operations ==========
    /**
     * Get a value from the cache
     */
    get(key) {
        const value = get(this.getGetOperations(), key);
        this.emit('get', key, value);
        return value;
    }
    /**
     * Get multiple values at once
     * Returns only existing values (filters out undefined)
     */
    getMany(keys) {
        const values = getMany(this.getGetOperations(), keys);
        this.emit('getMany', keys, values);
        return values;
    }
    /**
     * Check if a key exists in the cache
     */
    has(key) {
        return has(this.getGetOperations(), key);
    }
    /**
     * Get entry with metadata (createdAt, expiresAt)
     */
    getEntry(key) {
        return getEntry(this.getGetOperations(), key);
    }
    /**
     * Peek at a value without updating access time or triggering auto-delete
     * Useful for checking values without affecting eviction order
     */
    peek(key) {
        return peek(this.getGetOperations(), key);
    }
    // ========== Delete Operations ==========
    /**
     * Delete a value from the cache
     */
    delete(key) {
        const existed = del(this.getDeleteOperations(), key);
        if (existed) {
            this.emit('delete', key, undefined);
        }
        return existed;
    }
    /**
     * Delete multiple values at once
     */
    deleteMany(keys) {
        const deleted = deleteMany(this.getDeleteOperations(), keys);
        if (deleted > 0) {
            this.emit('deleteMany', keys.slice(0, deleted), undefined);
        }
        return deleted;
    }
    /**
     * Clear all entries from the cache
     */
    clear() {
        clear(this.getDeleteOperations());
        // Note: clear doesn't emit deleteMany event as it's a bulk operation
    }
    // ========== Mutate Operations ==========
    /**
     * Update an existing value using a function
     * @template T - Optional type parameter for better type inference in updater function (must extend V)
     */
    mutate(key, updater) {
        const result = mutate(this.getMutateOperations(), key, updater);
        this.emit('mutate', key, result);
        return result;
    }
    /**
     * Update an existing value, or set if it doesn't exist
     */
    upsert(key, valueOrUpdater) {
        const result = upsert(this.getMutateOperations(), key, valueOrUpdater);
        this.emit('upsert', key, result);
        return result;
    }
    /**
     * Increment a numeric value
     * Note: Only works when V is number
     */
    increment(key, amount = 1) {
        const result = increment(this.getMutateOperations(), key, amount);
        this.emit('increment', key, result);
        return result;
    }
    /**
     * Decrement a numeric value
     * Note: Only works when V is number
     */
    decrement(key, amount = 1) {
        const result = decrement(this.getMutateOperations(), key, amount);
        this.emit('decrement', key, result);
        return result;
    }
    /**
     * Append to an array value
     * Note: Only works when V is an array type
     */
    append(key, ...items) {
        const result = append(this.getMutateOperations(), key, ...items);
        this.emit('append', key, result);
        return result;
    }
    /**
     * Merge values based on type:
     * - Objects: Shallow merge properties
     * - Arrays: Concatenate (with optional duplicate filtering)
     * - Strings: Concatenate
     * - Numbers: Concatenate as strings then convert back to number (4 + 2 = 42)
     */
    merge(key, updates, options) {
        const mergeOptions = {
            allowDuplicates: options?.allowDuplicates ?? this.mergeAllowDuplicates ?? false,
        };
        const result = merge(this.getMutateOperations(), key, updates, mergeOptions);
        this.emit('merge', key, result);
        return result;
    }
    // ========== Utility Operations ==========
    /**
     * Get the size of the cache (number of entries)
     */
    size() {
        const result = size(this.getUtilityOperations());
        this.emit('size', undefined, undefined);
        return result;
    }
    /**
     * Get the size of the cache in bytes
     */
    sizeInBytes() {
        const result = sizeInBytes(this.getUtilityOperations());
        this.emit('sizeInBytes', undefined, undefined);
        return result;
    }
    /**
     * Get all keys in the cache
     */
    keys() {
        const result = keys(this.getUtilityOperations());
        this.emit('keys', undefined, result);
        return result;
    }
    /**
     * Get all values in the cache
     */
    values() {
        const result = values(this.getUtilityOperations());
        this.emit('values', undefined, result);
        return result;
    }
    /**
     * Get all entries in the cache
     */
    entries() {
        const result = entries(this.getUtilityOperations());
        this.emit('entries', undefined, result);
        return result;
    }
    /**
     * Check if cache is empty
     */
    isEmpty() {
        const result = isEmpty(this.getUtilityOperations());
        this.emit('isEmpty', undefined, result);
        return result;
    }
    /**
     * Get a random key from the cache
     */
    randomKey() {
        const result = randomKey(this.getUtilityOperations());
        this.emit('randomKey', undefined, undefined);
        return result;
    }
    // ========== Cleanup Operations ==========
    /**
     * Cleanup expired entries manually
     */
    cleanupExpired() {
        return cleanupExpired(this.getCleanupOperations());
    }
    /**
     * Start automatic cleanup of expired entries
     */
    startCleanup() {
        this.cleanupTimer = startCleanup(this.getCleanupOperations());
    }
    /**
     * Stop automatic cleanup
     */
    stopCleanup() {
        stopCleanup(this.cleanupTimer);
        this.cleanupTimer = undefined;
    }
    /**
     * Destroy the cache and cleanup resources
     */
    destroy() {
        this.stopCleanup();
        this.clear();
        this.eventListeners.clear();
        CacheRegistry.unregister(this);
    }
    // ========== Event System ==========
    /**
     * Register an event listener
     * @param key - The key to listen to, or '*' for all keys
     * @param eventOrHandler - The event name, or handler if event is omitted
     * @param handler - The handler function (optional if event is omitted)
     */
    on(key, eventOrHandler, handler) {
        let event;
        let callback;
        // Handle: on(key, handler) - all events for this key
        if (typeof eventOrHandler === 'function') {
            event = '*';
            callback = eventOrHandler;
        }
        // Handle: on(key, event, handler) - specific event for this key
        else {
            event = eventOrHandler;
            if (!handler) {
                throw new Error('Handler function is required when event is specified');
            }
            callback = handler;
        }
        // Get or create listener map for this key
        if (!this.eventListeners.has(key)) {
            this.eventListeners.set(key, new Map());
        }
        const keyListeners = this.eventListeners.get(key);
        // Get or create listener set for this event
        if (!keyListeners.has(event)) {
            keyListeners.set(event, new Set());
        }
        keyListeners.get(event).add(callback);
    }
    /**
     * Remove an event listener
     */
    off(key, eventOrHandler, handler) {
        if (!this.eventListeners.has(key)) {
            return;
        }
        const keyListeners = this.eventListeners.get(key);
        // Handle: off(key) - remove all listeners for this key
        if (eventOrHandler === undefined) {
            keyListeners.clear();
            return;
        }
        // Handle: off(key, handler) - remove handler from all events
        if (typeof eventOrHandler === 'function') {
            for (const listeners of keyListeners.values()) {
                listeners.delete(eventOrHandler);
            }
            return;
        }
        // Handle: off(key, event) - remove all handlers for this event
        if (handler === undefined) {
            keyListeners.delete(eventOrHandler);
            return;
        }
        // Handle: off(key, event, handler) - remove specific handler
        const eventListeners = keyListeners.get(eventOrHandler);
        if (eventListeners) {
            eventListeners.delete(handler);
        }
    }
    /**
     * Emit an event (internal use)
     */
    emit(event, key, value) {
        // Emit for specific keys
        if (key !== undefined) {
            if (Array.isArray(key)) {
                // For array keys, emit to each key individually
                for (const k of key) {
                    this.emitForKey(event, k, k, value);
                }
                // Also emit to wildcard listeners with the array
                this.emitForKey(event, '*', key, value);
            }
            else {
                // For single key, emit to that key and wildcard
                this.emitForKey(event, key, key, value);
                this.emitForKey(event, '*', key, value);
            }
        }
        else {
            // Emit for wildcard key listeners when no key specified
            this.emitForKey(event, '*', undefined, value);
        }
    }
    /**
     * Emit event for a specific key (internal use)
     */
    emitForKey(event, listenerKey, actualKey, value) {
        const keyListeners = this.eventListeners.get(listenerKey);
        if (!keyListeners) {
            return;
        }
        // Emit for specific event listeners
        const eventListeners = keyListeners.get(event);
        if (eventListeners) {
            for (const handler of eventListeners) {
                try {
                    handler(actualKey, value, event);
                }
                catch (error) {
                    // Don't let event handler errors break the cache
                    console.error('Error in cache event handler:', error);
                }
            }
        }
        // Emit for wildcard event listeners
        const wildcardListeners = keyListeners.get('*');
        if (wildcardListeners) {
            for (const handler of wildcardListeners) {
                try {
                    handler(actualKey, value, event);
                }
                catch (error) {
                    console.error('Error in cache event handler:', error);
                }
            }
        }
    }
    /**
     * Get alarm configuration (used internally by registry)
     */
    getAlarmConfig() {
        return this.alarm;
    }
    // ========== Internal Helpers ==========
    getSetOperations() {
        return {
            storage: this.storage,
            maxEntries: this.maxEntries,
            maxBytes: this.maxBytes,
            ttl: this.ttl,
            evictionPolicy: this.evictionPolicy,
        };
    }
    getGetOperations() {
        return {
            storage: this.storage,
            autoDeleteAfterUse: this.autoDeleteAfterUse,
            evictionPolicy: this.evictionPolicy,
        };
    }
    getDeleteOperations() {
        return {
            storage: this.storage,
        };
    }
    getMutateOperations() {
        return {
            storage: this.storage,
            maxEntries: this.maxEntries,
            maxBytes: this.maxBytes,
            ttl: this.ttl,
        };
    }
    getUtilityOperations() {
        return {
            storage: this.storage,
            ttl: this.ttl,
        };
    }
    getCleanupOperations() {
        return {
            storage: this.storage,
            ttl: this.ttl,
            cleanupInterval: this.cleanupInterval,
        };
    }
}

// Start monitoring automatically (works in both Node.js and browser)
CacheRegistry.startMonitoring(5000);

exports.Cache = Cache;
exports.append = append;
exports.cleanupExpired = cleanupExpired;
exports.clear = clear;
exports.decrement = decrement;
exports.del = del;
exports.deleteMany = deleteMany;
exports.entries = entries;
exports.get = get;
exports.getEntry = getEntry;
exports.getMany = getMany;
exports.has = has;
exports.increment = increment;
exports.isEmpty = isEmpty;
exports.keys = keys;
exports.merge = merge;
exports.mutate = mutate;
exports.peek = peek;
exports.randomKey = randomKey;
exports.set = set;
exports.setMany = setMany;
exports.size = size;
exports.sizeInBytes = sizeInBytes;
exports.startCleanup = startCleanup;
exports.stopCleanup = stopCleanup;
exports.upsert = upsert;
exports.values = values;
//# sourceMappingURL=index.js.map
