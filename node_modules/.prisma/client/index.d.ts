
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * *
 *  * TODO:
 *  * We need to expand this table to multiple tables.
 *  * We should be able to create a whole profile on the user
 *  * ‚Üí Qualities
 *  * ‚Üí Knowledge areas
 *  * ‚Üí Work experiances
 *  * ‚Üí Educations
 *  * ‚Üí Phone number
 *  * ‚Üí Where they live
 *  * ‚Üí Maybe more
 *  * ‚òùüèº This is or later when before we write logic of creating a RESUME or Cover letter
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Provider
 * Login method (Google, GitHub, etc.) ‚Äì stores external ID + tokens
 */
export type Provider = $Result.DefaultSelection<Prisma.$ProviderPayload>
/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model JobPosting
 * 
 */
export type JobPosting = $Result.DefaultSelection<Prisma.$JobPostingPayload>
/**
 * Model JobPostingLanguage
 * 
 */
export type JobPostingLanguage = $Result.DefaultSelection<Prisma.$JobPostingLanguagePayload>
/**
 * Model JobPostingRequirement
 * 
 */
export type JobPostingRequirement = $Result.DefaultSelection<Prisma.$JobPostingRequirementPayload>
/**
 * Model JobPostingMerit
 * 
 */
export type JobPostingMerit = $Result.DefaultSelection<Prisma.$JobPostingMeritPayload>
/**
 * Model JobPostingApplicantQuality
 * 
 */
export type JobPostingApplicantQuality = $Result.DefaultSelection<Prisma.$JobPostingApplicantQualityPayload>
/**
 * Model JobPostingLocation
 * 
 */
export type JobPostingLocation = $Result.DefaultSelection<Prisma.$JobPostingLocationPayload>
/**
 * Model JobPostingWorkArrengment
 * 
 */
export type JobPostingWorkArrengment = $Result.DefaultSelection<Prisma.$JobPostingWorkArrengmentPayload>
/**
 * Model JobPostingEmploymentType
 * 
 */
export type JobPostingEmploymentType = $Result.DefaultSelection<Prisma.$JobPostingEmploymentTypePayload>
/**
 * Model JobPostingSalary
 * 
 */
export type JobPostingSalary = $Result.DefaultSelection<Prisma.$JobPostingSalaryPayload>
/**
 * Model CreatedJobPosting
 * *
 *  * Handle
 *  * Did we scrape it by our self or via user or did a recruiter create a job posting
 */
export type CreatedJobPosting = $Result.DefaultSelection<Prisma.$CreatedJobPostingPayload>
/**
 * Model JobApplicants
 * *
 *  * Applications for a specific job posting.
 *  * Help us with
 *  * ‚Üí Get all users for a specific job posting
 *  * ‚Üí Do analytics of a specific job posting
 */
export type JobApplicants = $Result.DefaultSelection<Prisma.$JobApplicantsPayload>
/**
 * Model UserProcess
 * *
 *  * Connect a Process with a jobPosting
 */
export type UserProcess = $Result.DefaultSelection<Prisma.$UserProcessPayload>
/**
 * Model UserProcessStep
 * User‚Äôs progress on a specific step
 */
export type UserProcessStep = $Result.DefaultSelection<Prisma.$UserProcessStepPayload>
/**
 * Model UserPipelineStepComment
 * Comment on a pipeline step
 */
export type UserPipelineStepComment = $Result.DefaultSelection<Prisma.$UserPipelineStepCommentPayload>
/**
 * Model Process
 * *
 *  * Collection of reusable pipelines (e.g. "Standard Job Application Pipeline")
 *  * One template can be used by many users and many UserJobProcess records.
 */
export type Process = $Result.DefaultSelection<Prisma.$ProcessPayload>
/**
 * Model ProcessStep
 * *
 *  * One step inside a PipelineTemplate (the reusable definition)
 *  * This is the "master" version ‚Äì never changed by a user directly.
 */
export type ProcessStep = $Result.DefaultSelection<Prisma.$ProcessStepPayload>
/**
 * Model ActionDefinition
 * *
 *  * READY-MADE ACTION TEMPLATES
 *  * These are the actual actions users see and pick in the UI.
 *  * One ActionCatalog entry can power many ActionDefinitions
 *  * (e.g. "Send email" ‚Üí "Friendly follow-up", "Thank you after interview", etc.).
 */
export type ActionDefinition = $Result.DefaultSelection<Prisma.$ActionDefinitionPayload>
/**
 * Model TriggerDefinition
 * *
 *  * READY-MADE TRIGGER TEMPLATES (Uppdaterad f√∂r Nestling)
 *  * Definierar en regel och √§r √§gare till de logiska grupperna.
 */
export type TriggerDefinition = $Result.DefaultSelection<Prisma.$TriggerDefinitionPayload>
/**
 * Model Conditional
 * *
 *  * NEW MODEL: The individual conditions (if-statements) som nu tillh√∂r en TriggerGroup.
 *  * Denna modell √§r ett L√ñV i logiktr√§det och l√§nkar ENDAST till sin f√∂r√§ldragrupp.
 */
export type Conditional = $Result.DefaultSelection<Prisma.$ConditionalPayload>
/**
 * Model Todo
 * 
 */
export type Todo = $Result.DefaultSelection<Prisma.$TodoPayload>
/**
 * Model TodoItem
 * 
 */
export type TodoItem = $Result.DefaultSelection<Prisma.$TodoItemPayload>
/**
 * Model TodoUserProcess
 * 
 */
export type TodoUserProcess = $Result.DefaultSelection<Prisma.$TodoUserProcessPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const WorkArrangementEnum: {
  remote_full_time: 'remote_full_time',
  remote_part_time: 'remote_part_time',
  hybrid_full_time: 'hybrid_full_time',
  hybrid_part_time: 'hybrid_part_time',
  onsite_full_time: 'onsite_full_time',
  onsite_part_time: 'onsite_part_time',
  flexible_full_time: 'flexible_full_time',
  flexible_part_time: 'flexible_part_time'
};

export type WorkArrangementEnum = (typeof WorkArrangementEnum)[keyof typeof WorkArrangementEnum]


export const EmploymentEnum: {
  full_time: 'full_time',
  part_time: 'part_time',
  contract: 'contract',
  temporary: 'temporary',
  internship: 'internship',
  freelance: 'freelance'
};

export type EmploymentEnum = (typeof EmploymentEnum)[keyof typeof EmploymentEnum]


export const SalaryTypeEnum: {
  range: 'range',
  fixed: 'fixed',
  competitive: 'competitive',
  negotiable: 'negotiable',
  not_specified: 'not_specified'
};

export type SalaryTypeEnum = (typeof SalaryTypeEnum)[keyof typeof SalaryTypeEnum]


export const SalaryPeriodEnum: {
  monthly: 'monthly',
  annually: 'annually',
  hourly: 'hourly',
  weekly: 'weekly'
};

export type SalaryPeriodEnum = (typeof SalaryPeriodEnum)[keyof typeof SalaryPeriodEnum]


export const CreatedByEnum: {
  system: 'system',
  user: 'user',
  admin: 'admin'
};

export type CreatedByEnum = (typeof CreatedByEnum)[keyof typeof CreatedByEnum]


export const JobSourceEnum: {
  linkedin: 'linkedin',
  file_import: 'file_import',
  api: 'api',
  url: 'url'
};

export type JobSourceEnum = (typeof JobSourceEnum)[keyof typeof JobSourceEnum]


export const ProviderEnum: {
  github: 'github',
  google: 'google',
  linkedin: 'linkedin'
};

export type ProviderEnum = (typeof ProviderEnum)[keyof typeof ProviderEnum]


export const UserRoleEnum: {
  APPLICANT: 'APPLICANT',
  RECRUITER: 'RECRUITER',
  COMPANY_ADMIN: 'COMPANY_ADMIN'
};

export type UserRoleEnum = (typeof UserRoleEnum)[keyof typeof UserRoleEnum]


export const StatusUserJobProcesses: {
  not_started: 'not_started',
  started: 'started',
  waiting_for_reply: 'waiting_for_reply',
  interview_booked: 'interview_booked',
  interview_completed: 'interview_completed',
  offer_received: 'offer_received',
  rejected: 'rejected',
  hired: 'hired',
  archived: 'archived'
};

export type StatusUserJobProcesses = (typeof StatusUserJobProcesses)[keyof typeof StatusUserJobProcesses]


export const ComparisonOperatorEnum: {
  EQ: 'EQ',
  NE: 'NE',
  GT: 'GT',
  GTE: 'GTE',
  LT: 'LT',
  LTE: 'LTE',
  CONTAINS: 'CONTAINS',
  STARTS_WITH: 'STARTS_WITH',
  ENDS_WITH: 'ENDS_WITH',
  IN: 'IN',
  NOT_IN: 'NOT_IN',
  IS_NULL: 'IS_NULL',
  IS_NOT_NULL: 'IS_NOT_NULL'
};

export type ComparisonOperatorEnum = (typeof ComparisonOperatorEnum)[keyof typeof ComparisonOperatorEnum]


export const CombinatorEnum: {
  AND: 'AND',
  OR: 'OR'
};

export type CombinatorEnum = (typeof CombinatorEnum)[keyof typeof CombinatorEnum]


export const TriggerCategoryCodeEnum: {
  TIME_BASED: 'TIME_BASED',
  STATUS_CHANGE: 'STATUS_CHANGE',
  STATUS_EVENT: 'STATUS_EVENT',
  MANUAL: 'MANUAL'
};

export type TriggerCategoryCodeEnum = (typeof TriggerCategoryCodeEnum)[keyof typeof TriggerCategoryCodeEnum]


export const TriggerEventCode: {
  REMINDER: 'REMINDER',
  EMAIL_SENT: 'EMAIL_SENT',
  EMAIL_RECEIVED: 'EMAIL_RECEIVED',
  NO_REPLY: 'NO_REPLY',
  INTERVIEW_BOOKED: 'INTERVIEW_BOOKED',
  INTERVIEW_COMPLETED: 'INTERVIEW_COMPLETED',
  INTERVIEW_OFFER: 'INTERVIEW_OFFER',
  APPLICATION_SUBMITTED: 'APPLICATION_SUBMITTED',
  APPLICATION_REJECTED: 'APPLICATION_REJECTED',
  APPLICATION_RECEIVED: 'APPLICATION_RECEIVED',
  OFFER_RECEIVED: 'OFFER_RECEIVED',
  MANUAL_TRIGGER: 'MANUAL_TRIGGER',
  STEP_COMPLETED: 'STEP_COMPLETED',
  STEP_SKIPPED: 'STEP_SKIPPED'
};

export type TriggerEventCode = (typeof TriggerEventCode)[keyof typeof TriggerEventCode]


export const ActionKey: {
  SEND_EMAIL_REMINDER: 'SEND_EMAIL_REMINDER',
  CREATE_CALENDAR_EVENT: 'CREATE_CALENDAR_EVENT',
  CALL_REMINDER: 'CALL_REMINDER',
  SEND_SMS: 'SEND_SMS',
  WEBHOOK: 'WEBHOOK',
  UPDATE_STEP_STATUS: 'UPDATE_STEP_STATUS'
};

export type ActionKey = (typeof ActionKey)[keyof typeof ActionKey]


export const TodoItemTypeEnum: {
  TEXT: 'TEXT',
  USER_PROCESS: 'USER_PROCESS'
};

export type TodoItemTypeEnum = (typeof TodoItemTypeEnum)[keyof typeof TodoItemTypeEnum]

}

export type WorkArrangementEnum = $Enums.WorkArrangementEnum

export const WorkArrangementEnum: typeof $Enums.WorkArrangementEnum

export type EmploymentEnum = $Enums.EmploymentEnum

export const EmploymentEnum: typeof $Enums.EmploymentEnum

export type SalaryTypeEnum = $Enums.SalaryTypeEnum

export const SalaryTypeEnum: typeof $Enums.SalaryTypeEnum

export type SalaryPeriodEnum = $Enums.SalaryPeriodEnum

export const SalaryPeriodEnum: typeof $Enums.SalaryPeriodEnum

export type CreatedByEnum = $Enums.CreatedByEnum

export const CreatedByEnum: typeof $Enums.CreatedByEnum

export type JobSourceEnum = $Enums.JobSourceEnum

export const JobSourceEnum: typeof $Enums.JobSourceEnum

export type ProviderEnum = $Enums.ProviderEnum

export const ProviderEnum: typeof $Enums.ProviderEnum

export type UserRoleEnum = $Enums.UserRoleEnum

export const UserRoleEnum: typeof $Enums.UserRoleEnum

export type StatusUserJobProcesses = $Enums.StatusUserJobProcesses

export const StatusUserJobProcesses: typeof $Enums.StatusUserJobProcesses

export type ComparisonOperatorEnum = $Enums.ComparisonOperatorEnum

export const ComparisonOperatorEnum: typeof $Enums.ComparisonOperatorEnum

export type CombinatorEnum = $Enums.CombinatorEnum

export const CombinatorEnum: typeof $Enums.CombinatorEnum

export type TriggerCategoryCodeEnum = $Enums.TriggerCategoryCodeEnum

export const TriggerCategoryCodeEnum: typeof $Enums.TriggerCategoryCodeEnum

export type TriggerEventCode = $Enums.TriggerEventCode

export const TriggerEventCode: typeof $Enums.TriggerEventCode

export type ActionKey = $Enums.ActionKey

export const ActionKey: typeof $Enums.ActionKey

export type TodoItemTypeEnum = $Enums.TodoItemTypeEnum

export const TodoItemTypeEnum: typeof $Enums.TodoItemTypeEnum

/**
 * ##  Prisma Client  ≤À¢
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client  ≤À¢
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider`: Exposes CRUD operations for the **Provider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.provider.findMany()
    * ```
    */
  get provider(): Prisma.ProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobPosting`: Exposes CRUD operations for the **JobPosting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPostings
    * const jobPostings = await prisma.jobPosting.findMany()
    * ```
    */
  get jobPosting(): Prisma.JobPostingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobPostingLanguage`: Exposes CRUD operations for the **JobPostingLanguage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPostingLanguages
    * const jobPostingLanguages = await prisma.jobPostingLanguage.findMany()
    * ```
    */
  get jobPostingLanguage(): Prisma.JobPostingLanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobPostingRequirement`: Exposes CRUD operations for the **JobPostingRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPostingRequirements
    * const jobPostingRequirements = await prisma.jobPostingRequirement.findMany()
    * ```
    */
  get jobPostingRequirement(): Prisma.JobPostingRequirementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobPostingMerit`: Exposes CRUD operations for the **JobPostingMerit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPostingMerits
    * const jobPostingMerits = await prisma.jobPostingMerit.findMany()
    * ```
    */
  get jobPostingMerit(): Prisma.JobPostingMeritDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobPostingApplicantQuality`: Exposes CRUD operations for the **JobPostingApplicantQuality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPostingApplicantQualities
    * const jobPostingApplicantQualities = await prisma.jobPostingApplicantQuality.findMany()
    * ```
    */
  get jobPostingApplicantQuality(): Prisma.JobPostingApplicantQualityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobPostingLocation`: Exposes CRUD operations for the **JobPostingLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPostingLocations
    * const jobPostingLocations = await prisma.jobPostingLocation.findMany()
    * ```
    */
  get jobPostingLocation(): Prisma.JobPostingLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobPostingWorkArrengment`: Exposes CRUD operations for the **JobPostingWorkArrengment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPostingWorkArrengments
    * const jobPostingWorkArrengments = await prisma.jobPostingWorkArrengment.findMany()
    * ```
    */
  get jobPostingWorkArrengment(): Prisma.JobPostingWorkArrengmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobPostingEmploymentType`: Exposes CRUD operations for the **JobPostingEmploymentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPostingEmploymentTypes
    * const jobPostingEmploymentTypes = await prisma.jobPostingEmploymentType.findMany()
    * ```
    */
  get jobPostingEmploymentType(): Prisma.JobPostingEmploymentTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobPostingSalary`: Exposes CRUD operations for the **JobPostingSalary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPostingSalaries
    * const jobPostingSalaries = await prisma.jobPostingSalary.findMany()
    * ```
    */
  get jobPostingSalary(): Prisma.JobPostingSalaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.createdJobPosting`: Exposes CRUD operations for the **CreatedJobPosting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatedJobPostings
    * const createdJobPostings = await prisma.createdJobPosting.findMany()
    * ```
    */
  get createdJobPosting(): Prisma.CreatedJobPostingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobApplicants`: Exposes CRUD operations for the **JobApplicants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobApplicants
    * const jobApplicants = await prisma.jobApplicants.findMany()
    * ```
    */
  get jobApplicants(): Prisma.JobApplicantsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProcess`: Exposes CRUD operations for the **UserProcess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProcesses
    * const userProcesses = await prisma.userProcess.findMany()
    * ```
    */
  get userProcess(): Prisma.UserProcessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProcessStep`: Exposes CRUD operations for the **UserProcessStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProcessSteps
    * const userProcessSteps = await prisma.userProcessStep.findMany()
    * ```
    */
  get userProcessStep(): Prisma.UserProcessStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPipelineStepComment`: Exposes CRUD operations for the **UserPipelineStepComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPipelineStepComments
    * const userPipelineStepComments = await prisma.userPipelineStepComment.findMany()
    * ```
    */
  get userPipelineStepComment(): Prisma.UserPipelineStepCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.process`: Exposes CRUD operations for the **Process** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Processes
    * const processes = await prisma.process.findMany()
    * ```
    */
  get process(): Prisma.ProcessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.processStep`: Exposes CRUD operations for the **ProcessStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessSteps
    * const processSteps = await prisma.processStep.findMany()
    * ```
    */
  get processStep(): Prisma.ProcessStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.actionDefinition`: Exposes CRUD operations for the **ActionDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActionDefinitions
    * const actionDefinitions = await prisma.actionDefinition.findMany()
    * ```
    */
  get actionDefinition(): Prisma.ActionDefinitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.triggerDefinition`: Exposes CRUD operations for the **TriggerDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TriggerDefinitions
    * const triggerDefinitions = await prisma.triggerDefinition.findMany()
    * ```
    */
  get triggerDefinition(): Prisma.TriggerDefinitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conditional`: Exposes CRUD operations for the **Conditional** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conditionals
    * const conditionals = await prisma.conditional.findMany()
    * ```
    */
  get conditional(): Prisma.ConditionalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.todo`: Exposes CRUD operations for the **Todo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Todos
    * const todos = await prisma.todo.findMany()
    * ```
    */
  get todo(): Prisma.TodoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.todoItem`: Exposes CRUD operations for the **TodoItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TodoItems
    * const todoItems = await prisma.todoItem.findMany()
    * ```
    */
  get todoItem(): Prisma.TodoItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.todoUserProcess`: Exposes CRUD operations for the **TodoUserProcess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TodoUserProcesses
    * const todoUserProcesses = await prisma.todoUserProcess.findMany()
    * ```
    */
  get todoUserProcess(): Prisma.TodoUserProcessDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Provider: 'Provider',
    Token: 'Token',
    Company: 'Company',
    JobPosting: 'JobPosting',
    JobPostingLanguage: 'JobPostingLanguage',
    JobPostingRequirement: 'JobPostingRequirement',
    JobPostingMerit: 'JobPostingMerit',
    JobPostingApplicantQuality: 'JobPostingApplicantQuality',
    JobPostingLocation: 'JobPostingLocation',
    JobPostingWorkArrengment: 'JobPostingWorkArrengment',
    JobPostingEmploymentType: 'JobPostingEmploymentType',
    JobPostingSalary: 'JobPostingSalary',
    CreatedJobPosting: 'CreatedJobPosting',
    JobApplicants: 'JobApplicants',
    UserProcess: 'UserProcess',
    UserProcessStep: 'UserProcessStep',
    UserPipelineStepComment: 'UserPipelineStepComment',
    Process: 'Process',
    ProcessStep: 'ProcessStep',
    ActionDefinition: 'ActionDefinition',
    TriggerDefinition: 'TriggerDefinition',
    Conditional: 'Conditional',
    Todo: 'Todo',
    TodoItem: 'TodoItem',
    TodoUserProcess: 'TodoUserProcess'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "provider" | "token" | "company" | "jobPosting" | "jobPostingLanguage" | "jobPostingRequirement" | "jobPostingMerit" | "jobPostingApplicantQuality" | "jobPostingLocation" | "jobPostingWorkArrengment" | "jobPostingEmploymentType" | "jobPostingSalary" | "createdJobPosting" | "jobApplicants" | "userProcess" | "userProcessStep" | "userPipelineStepComment" | "process" | "processStep" | "actionDefinition" | "triggerDefinition" | "conditional" | "todo" | "todoItem" | "todoUserProcess"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Provider: {
        payload: Prisma.$ProviderPayload<ExtArgs>
        fields: Prisma.ProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findFirst: {
            args: Prisma.ProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findMany: {
            args: Prisma.ProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          create: {
            args: Prisma.ProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          createMany: {
            args: Prisma.ProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          delete: {
            args: Prisma.ProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          update: {
            args: Prisma.ProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          deleteMany: {
            args: Prisma.ProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProviderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          upsert: {
            args: Prisma.ProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          aggregate: {
            args: Prisma.ProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvider>
          }
          groupBy: {
            args: Prisma.ProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderCountAggregateOutputType> | number
          }
        }
      }
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      JobPosting: {
        payload: Prisma.$JobPostingPayload<ExtArgs>
        fields: Prisma.JobPostingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPostingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPostingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>
          }
          findFirst: {
            args: Prisma.JobPostingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPostingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>
          }
          findMany: {
            args: Prisma.JobPostingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>[]
          }
          create: {
            args: Prisma.JobPostingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>
          }
          createMany: {
            args: Prisma.JobPostingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobPostingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>[]
          }
          delete: {
            args: Prisma.JobPostingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>
          }
          update: {
            args: Prisma.JobPostingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>
          }
          deleteMany: {
            args: Prisma.JobPostingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobPostingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobPostingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>[]
          }
          upsert: {
            args: Prisma.JobPostingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>
          }
          aggregate: {
            args: Prisma.JobPostingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobPosting>
          }
          groupBy: {
            args: Prisma.JobPostingGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobPostingGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPostingCountArgs<ExtArgs>
            result: $Utils.Optional<JobPostingCountAggregateOutputType> | number
          }
        }
      }
      JobPostingLanguage: {
        payload: Prisma.$JobPostingLanguagePayload<ExtArgs>
        fields: Prisma.JobPostingLanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPostingLanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPostingLanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLanguagePayload>
          }
          findFirst: {
            args: Prisma.JobPostingLanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPostingLanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLanguagePayload>
          }
          findMany: {
            args: Prisma.JobPostingLanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLanguagePayload>[]
          }
          create: {
            args: Prisma.JobPostingLanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLanguagePayload>
          }
          createMany: {
            args: Prisma.JobPostingLanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobPostingLanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLanguagePayload>[]
          }
          delete: {
            args: Prisma.JobPostingLanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLanguagePayload>
          }
          update: {
            args: Prisma.JobPostingLanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLanguagePayload>
          }
          deleteMany: {
            args: Prisma.JobPostingLanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobPostingLanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobPostingLanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLanguagePayload>[]
          }
          upsert: {
            args: Prisma.JobPostingLanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLanguagePayload>
          }
          aggregate: {
            args: Prisma.JobPostingLanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobPostingLanguage>
          }
          groupBy: {
            args: Prisma.JobPostingLanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobPostingLanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPostingLanguageCountArgs<ExtArgs>
            result: $Utils.Optional<JobPostingLanguageCountAggregateOutputType> | number
          }
        }
      }
      JobPostingRequirement: {
        payload: Prisma.$JobPostingRequirementPayload<ExtArgs>
        fields: Prisma.JobPostingRequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPostingRequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingRequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPostingRequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingRequirementPayload>
          }
          findFirst: {
            args: Prisma.JobPostingRequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingRequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPostingRequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingRequirementPayload>
          }
          findMany: {
            args: Prisma.JobPostingRequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingRequirementPayload>[]
          }
          create: {
            args: Prisma.JobPostingRequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingRequirementPayload>
          }
          createMany: {
            args: Prisma.JobPostingRequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobPostingRequirementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingRequirementPayload>[]
          }
          delete: {
            args: Prisma.JobPostingRequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingRequirementPayload>
          }
          update: {
            args: Prisma.JobPostingRequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingRequirementPayload>
          }
          deleteMany: {
            args: Prisma.JobPostingRequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobPostingRequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobPostingRequirementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingRequirementPayload>[]
          }
          upsert: {
            args: Prisma.JobPostingRequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingRequirementPayload>
          }
          aggregate: {
            args: Prisma.JobPostingRequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobPostingRequirement>
          }
          groupBy: {
            args: Prisma.JobPostingRequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobPostingRequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPostingRequirementCountArgs<ExtArgs>
            result: $Utils.Optional<JobPostingRequirementCountAggregateOutputType> | number
          }
        }
      }
      JobPostingMerit: {
        payload: Prisma.$JobPostingMeritPayload<ExtArgs>
        fields: Prisma.JobPostingMeritFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPostingMeritFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingMeritPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPostingMeritFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingMeritPayload>
          }
          findFirst: {
            args: Prisma.JobPostingMeritFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingMeritPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPostingMeritFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingMeritPayload>
          }
          findMany: {
            args: Prisma.JobPostingMeritFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingMeritPayload>[]
          }
          create: {
            args: Prisma.JobPostingMeritCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingMeritPayload>
          }
          createMany: {
            args: Prisma.JobPostingMeritCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobPostingMeritCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingMeritPayload>[]
          }
          delete: {
            args: Prisma.JobPostingMeritDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingMeritPayload>
          }
          update: {
            args: Prisma.JobPostingMeritUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingMeritPayload>
          }
          deleteMany: {
            args: Prisma.JobPostingMeritDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobPostingMeritUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobPostingMeritUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingMeritPayload>[]
          }
          upsert: {
            args: Prisma.JobPostingMeritUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingMeritPayload>
          }
          aggregate: {
            args: Prisma.JobPostingMeritAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobPostingMerit>
          }
          groupBy: {
            args: Prisma.JobPostingMeritGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobPostingMeritGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPostingMeritCountArgs<ExtArgs>
            result: $Utils.Optional<JobPostingMeritCountAggregateOutputType> | number
          }
        }
      }
      JobPostingApplicantQuality: {
        payload: Prisma.$JobPostingApplicantQualityPayload<ExtArgs>
        fields: Prisma.JobPostingApplicantQualityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPostingApplicantQualityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingApplicantQualityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPostingApplicantQualityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingApplicantQualityPayload>
          }
          findFirst: {
            args: Prisma.JobPostingApplicantQualityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingApplicantQualityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPostingApplicantQualityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingApplicantQualityPayload>
          }
          findMany: {
            args: Prisma.JobPostingApplicantQualityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingApplicantQualityPayload>[]
          }
          create: {
            args: Prisma.JobPostingApplicantQualityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingApplicantQualityPayload>
          }
          createMany: {
            args: Prisma.JobPostingApplicantQualityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobPostingApplicantQualityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingApplicantQualityPayload>[]
          }
          delete: {
            args: Prisma.JobPostingApplicantQualityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingApplicantQualityPayload>
          }
          update: {
            args: Prisma.JobPostingApplicantQualityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingApplicantQualityPayload>
          }
          deleteMany: {
            args: Prisma.JobPostingApplicantQualityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobPostingApplicantQualityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobPostingApplicantQualityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingApplicantQualityPayload>[]
          }
          upsert: {
            args: Prisma.JobPostingApplicantQualityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingApplicantQualityPayload>
          }
          aggregate: {
            args: Prisma.JobPostingApplicantQualityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobPostingApplicantQuality>
          }
          groupBy: {
            args: Prisma.JobPostingApplicantQualityGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobPostingApplicantQualityGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPostingApplicantQualityCountArgs<ExtArgs>
            result: $Utils.Optional<JobPostingApplicantQualityCountAggregateOutputType> | number
          }
        }
      }
      JobPostingLocation: {
        payload: Prisma.$JobPostingLocationPayload<ExtArgs>
        fields: Prisma.JobPostingLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPostingLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPostingLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLocationPayload>
          }
          findFirst: {
            args: Prisma.JobPostingLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPostingLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLocationPayload>
          }
          findMany: {
            args: Prisma.JobPostingLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLocationPayload>[]
          }
          create: {
            args: Prisma.JobPostingLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLocationPayload>
          }
          createMany: {
            args: Prisma.JobPostingLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobPostingLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLocationPayload>[]
          }
          delete: {
            args: Prisma.JobPostingLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLocationPayload>
          }
          update: {
            args: Prisma.JobPostingLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLocationPayload>
          }
          deleteMany: {
            args: Prisma.JobPostingLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobPostingLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobPostingLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLocationPayload>[]
          }
          upsert: {
            args: Prisma.JobPostingLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingLocationPayload>
          }
          aggregate: {
            args: Prisma.JobPostingLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobPostingLocation>
          }
          groupBy: {
            args: Prisma.JobPostingLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobPostingLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPostingLocationCountArgs<ExtArgs>
            result: $Utils.Optional<JobPostingLocationCountAggregateOutputType> | number
          }
        }
      }
      JobPostingWorkArrengment: {
        payload: Prisma.$JobPostingWorkArrengmentPayload<ExtArgs>
        fields: Prisma.JobPostingWorkArrengmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPostingWorkArrengmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingWorkArrengmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPostingWorkArrengmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingWorkArrengmentPayload>
          }
          findFirst: {
            args: Prisma.JobPostingWorkArrengmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingWorkArrengmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPostingWorkArrengmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingWorkArrengmentPayload>
          }
          findMany: {
            args: Prisma.JobPostingWorkArrengmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingWorkArrengmentPayload>[]
          }
          create: {
            args: Prisma.JobPostingWorkArrengmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingWorkArrengmentPayload>
          }
          createMany: {
            args: Prisma.JobPostingWorkArrengmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobPostingWorkArrengmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingWorkArrengmentPayload>[]
          }
          delete: {
            args: Prisma.JobPostingWorkArrengmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingWorkArrengmentPayload>
          }
          update: {
            args: Prisma.JobPostingWorkArrengmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingWorkArrengmentPayload>
          }
          deleteMany: {
            args: Prisma.JobPostingWorkArrengmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobPostingWorkArrengmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobPostingWorkArrengmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingWorkArrengmentPayload>[]
          }
          upsert: {
            args: Prisma.JobPostingWorkArrengmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingWorkArrengmentPayload>
          }
          aggregate: {
            args: Prisma.JobPostingWorkArrengmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobPostingWorkArrengment>
          }
          groupBy: {
            args: Prisma.JobPostingWorkArrengmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobPostingWorkArrengmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPostingWorkArrengmentCountArgs<ExtArgs>
            result: $Utils.Optional<JobPostingWorkArrengmentCountAggregateOutputType> | number
          }
        }
      }
      JobPostingEmploymentType: {
        payload: Prisma.$JobPostingEmploymentTypePayload<ExtArgs>
        fields: Prisma.JobPostingEmploymentTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPostingEmploymentTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingEmploymentTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPostingEmploymentTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingEmploymentTypePayload>
          }
          findFirst: {
            args: Prisma.JobPostingEmploymentTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingEmploymentTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPostingEmploymentTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingEmploymentTypePayload>
          }
          findMany: {
            args: Prisma.JobPostingEmploymentTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingEmploymentTypePayload>[]
          }
          create: {
            args: Prisma.JobPostingEmploymentTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingEmploymentTypePayload>
          }
          createMany: {
            args: Prisma.JobPostingEmploymentTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobPostingEmploymentTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingEmploymentTypePayload>[]
          }
          delete: {
            args: Prisma.JobPostingEmploymentTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingEmploymentTypePayload>
          }
          update: {
            args: Prisma.JobPostingEmploymentTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingEmploymentTypePayload>
          }
          deleteMany: {
            args: Prisma.JobPostingEmploymentTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobPostingEmploymentTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobPostingEmploymentTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingEmploymentTypePayload>[]
          }
          upsert: {
            args: Prisma.JobPostingEmploymentTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingEmploymentTypePayload>
          }
          aggregate: {
            args: Prisma.JobPostingEmploymentTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobPostingEmploymentType>
          }
          groupBy: {
            args: Prisma.JobPostingEmploymentTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobPostingEmploymentTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPostingEmploymentTypeCountArgs<ExtArgs>
            result: $Utils.Optional<JobPostingEmploymentTypeCountAggregateOutputType> | number
          }
        }
      }
      JobPostingSalary: {
        payload: Prisma.$JobPostingSalaryPayload<ExtArgs>
        fields: Prisma.JobPostingSalaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPostingSalaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingSalaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPostingSalaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingSalaryPayload>
          }
          findFirst: {
            args: Prisma.JobPostingSalaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingSalaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPostingSalaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingSalaryPayload>
          }
          findMany: {
            args: Prisma.JobPostingSalaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingSalaryPayload>[]
          }
          create: {
            args: Prisma.JobPostingSalaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingSalaryPayload>
          }
          createMany: {
            args: Prisma.JobPostingSalaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobPostingSalaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingSalaryPayload>[]
          }
          delete: {
            args: Prisma.JobPostingSalaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingSalaryPayload>
          }
          update: {
            args: Prisma.JobPostingSalaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingSalaryPayload>
          }
          deleteMany: {
            args: Prisma.JobPostingSalaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobPostingSalaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobPostingSalaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingSalaryPayload>[]
          }
          upsert: {
            args: Prisma.JobPostingSalaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingSalaryPayload>
          }
          aggregate: {
            args: Prisma.JobPostingSalaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobPostingSalary>
          }
          groupBy: {
            args: Prisma.JobPostingSalaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobPostingSalaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPostingSalaryCountArgs<ExtArgs>
            result: $Utils.Optional<JobPostingSalaryCountAggregateOutputType> | number
          }
        }
      }
      CreatedJobPosting: {
        payload: Prisma.$CreatedJobPostingPayload<ExtArgs>
        fields: Prisma.CreatedJobPostingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatedJobPostingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatedJobPostingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatedJobPostingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatedJobPostingPayload>
          }
          findFirst: {
            args: Prisma.CreatedJobPostingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatedJobPostingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatedJobPostingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatedJobPostingPayload>
          }
          findMany: {
            args: Prisma.CreatedJobPostingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatedJobPostingPayload>[]
          }
          create: {
            args: Prisma.CreatedJobPostingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatedJobPostingPayload>
          }
          createMany: {
            args: Prisma.CreatedJobPostingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatedJobPostingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatedJobPostingPayload>[]
          }
          delete: {
            args: Prisma.CreatedJobPostingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatedJobPostingPayload>
          }
          update: {
            args: Prisma.CreatedJobPostingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatedJobPostingPayload>
          }
          deleteMany: {
            args: Prisma.CreatedJobPostingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatedJobPostingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreatedJobPostingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatedJobPostingPayload>[]
          }
          upsert: {
            args: Prisma.CreatedJobPostingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatedJobPostingPayload>
          }
          aggregate: {
            args: Prisma.CreatedJobPostingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreatedJobPosting>
          }
          groupBy: {
            args: Prisma.CreatedJobPostingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatedJobPostingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatedJobPostingCountArgs<ExtArgs>
            result: $Utils.Optional<CreatedJobPostingCountAggregateOutputType> | number
          }
        }
      }
      JobApplicants: {
        payload: Prisma.$JobApplicantsPayload<ExtArgs>
        fields: Prisma.JobApplicantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobApplicantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobApplicantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicantsPayload>
          }
          findFirst: {
            args: Prisma.JobApplicantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobApplicantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicantsPayload>
          }
          findMany: {
            args: Prisma.JobApplicantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicantsPayload>[]
          }
          create: {
            args: Prisma.JobApplicantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicantsPayload>
          }
          createMany: {
            args: Prisma.JobApplicantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobApplicantsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicantsPayload>[]
          }
          delete: {
            args: Prisma.JobApplicantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicantsPayload>
          }
          update: {
            args: Prisma.JobApplicantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicantsPayload>
          }
          deleteMany: {
            args: Prisma.JobApplicantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobApplicantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobApplicantsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicantsPayload>[]
          }
          upsert: {
            args: Prisma.JobApplicantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicantsPayload>
          }
          aggregate: {
            args: Prisma.JobApplicantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobApplicants>
          }
          groupBy: {
            args: Prisma.JobApplicantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobApplicantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobApplicantsCountArgs<ExtArgs>
            result: $Utils.Optional<JobApplicantsCountAggregateOutputType> | number
          }
        }
      }
      UserProcess: {
        payload: Prisma.$UserProcessPayload<ExtArgs>
        fields: Prisma.UserProcessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProcessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProcessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessPayload>
          }
          findFirst: {
            args: Prisma.UserProcessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProcessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessPayload>
          }
          findMany: {
            args: Prisma.UserProcessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessPayload>[]
          }
          create: {
            args: Prisma.UserProcessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessPayload>
          }
          createMany: {
            args: Prisma.UserProcessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProcessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessPayload>[]
          }
          delete: {
            args: Prisma.UserProcessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessPayload>
          }
          update: {
            args: Prisma.UserProcessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessPayload>
          }
          deleteMany: {
            args: Prisma.UserProcessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProcessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProcessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessPayload>[]
          }
          upsert: {
            args: Prisma.UserProcessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessPayload>
          }
          aggregate: {
            args: Prisma.UserProcessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProcess>
          }
          groupBy: {
            args: Prisma.UserProcessGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProcessGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProcessCountArgs<ExtArgs>
            result: $Utils.Optional<UserProcessCountAggregateOutputType> | number
          }
        }
      }
      UserProcessStep: {
        payload: Prisma.$UserProcessStepPayload<ExtArgs>
        fields: Prisma.UserProcessStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProcessStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProcessStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessStepPayload>
          }
          findFirst: {
            args: Prisma.UserProcessStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProcessStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessStepPayload>
          }
          findMany: {
            args: Prisma.UserProcessStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessStepPayload>[]
          }
          create: {
            args: Prisma.UserProcessStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessStepPayload>
          }
          createMany: {
            args: Prisma.UserProcessStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProcessStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessStepPayload>[]
          }
          delete: {
            args: Prisma.UserProcessStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessStepPayload>
          }
          update: {
            args: Prisma.UserProcessStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessStepPayload>
          }
          deleteMany: {
            args: Prisma.UserProcessStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProcessStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProcessStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessStepPayload>[]
          }
          upsert: {
            args: Prisma.UserProcessStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProcessStepPayload>
          }
          aggregate: {
            args: Prisma.UserProcessStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProcessStep>
          }
          groupBy: {
            args: Prisma.UserProcessStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProcessStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProcessStepCountArgs<ExtArgs>
            result: $Utils.Optional<UserProcessStepCountAggregateOutputType> | number
          }
        }
      }
      UserPipelineStepComment: {
        payload: Prisma.$UserPipelineStepCommentPayload<ExtArgs>
        fields: Prisma.UserPipelineStepCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPipelineStepCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPipelineStepCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPipelineStepCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPipelineStepCommentPayload>
          }
          findFirst: {
            args: Prisma.UserPipelineStepCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPipelineStepCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPipelineStepCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPipelineStepCommentPayload>
          }
          findMany: {
            args: Prisma.UserPipelineStepCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPipelineStepCommentPayload>[]
          }
          create: {
            args: Prisma.UserPipelineStepCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPipelineStepCommentPayload>
          }
          createMany: {
            args: Prisma.UserPipelineStepCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPipelineStepCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPipelineStepCommentPayload>[]
          }
          delete: {
            args: Prisma.UserPipelineStepCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPipelineStepCommentPayload>
          }
          update: {
            args: Prisma.UserPipelineStepCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPipelineStepCommentPayload>
          }
          deleteMany: {
            args: Prisma.UserPipelineStepCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPipelineStepCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPipelineStepCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPipelineStepCommentPayload>[]
          }
          upsert: {
            args: Prisma.UserPipelineStepCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPipelineStepCommentPayload>
          }
          aggregate: {
            args: Prisma.UserPipelineStepCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPipelineStepComment>
          }
          groupBy: {
            args: Prisma.UserPipelineStepCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPipelineStepCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPipelineStepCommentCountArgs<ExtArgs>
            result: $Utils.Optional<UserPipelineStepCommentCountAggregateOutputType> | number
          }
        }
      }
      Process: {
        payload: Prisma.$ProcessPayload<ExtArgs>
        fields: Prisma.ProcessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          findFirst: {
            args: Prisma.ProcessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          findMany: {
            args: Prisma.ProcessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>[]
          }
          create: {
            args: Prisma.ProcessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          createMany: {
            args: Prisma.ProcessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>[]
          }
          delete: {
            args: Prisma.ProcessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          update: {
            args: Prisma.ProcessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          deleteMany: {
            args: Prisma.ProcessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>[]
          }
          upsert: {
            args: Prisma.ProcessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          aggregate: {
            args: Prisma.ProcessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcess>
          }
          groupBy: {
            args: Prisma.ProcessGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessCountAggregateOutputType> | number
          }
        }
      }
      ProcessStep: {
        payload: Prisma.$ProcessStepPayload<ExtArgs>
        fields: Prisma.ProcessStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          findFirst: {
            args: Prisma.ProcessStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          findMany: {
            args: Prisma.ProcessStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>[]
          }
          create: {
            args: Prisma.ProcessStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          createMany: {
            args: Prisma.ProcessStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>[]
          }
          delete: {
            args: Prisma.ProcessStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          update: {
            args: Prisma.ProcessStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          deleteMany: {
            args: Prisma.ProcessStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcessStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>[]
          }
          upsert: {
            args: Prisma.ProcessStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessStepPayload>
          }
          aggregate: {
            args: Prisma.ProcessStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessStep>
          }
          groupBy: {
            args: Prisma.ProcessStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessStepCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessStepCountAggregateOutputType> | number
          }
        }
      }
      ActionDefinition: {
        payload: Prisma.$ActionDefinitionPayload<ExtArgs>
        fields: Prisma.ActionDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionDefinitionPayload>
          }
          findFirst: {
            args: Prisma.ActionDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionDefinitionPayload>
          }
          findMany: {
            args: Prisma.ActionDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionDefinitionPayload>[]
          }
          create: {
            args: Prisma.ActionDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionDefinitionPayload>
          }
          createMany: {
            args: Prisma.ActionDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionDefinitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionDefinitionPayload>[]
          }
          delete: {
            args: Prisma.ActionDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionDefinitionPayload>
          }
          update: {
            args: Prisma.ActionDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.ActionDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActionDefinitionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionDefinitionPayload>[]
          }
          upsert: {
            args: Prisma.ActionDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionDefinitionPayload>
          }
          aggregate: {
            args: Prisma.ActionDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActionDefinition>
          }
          groupBy: {
            args: Prisma.ActionDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<ActionDefinitionCountAggregateOutputType> | number
          }
        }
      }
      TriggerDefinition: {
        payload: Prisma.$TriggerDefinitionPayload<ExtArgs>
        fields: Prisma.TriggerDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TriggerDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TriggerDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerDefinitionPayload>
          }
          findFirst: {
            args: Prisma.TriggerDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TriggerDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerDefinitionPayload>
          }
          findMany: {
            args: Prisma.TriggerDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerDefinitionPayload>[]
          }
          create: {
            args: Prisma.TriggerDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerDefinitionPayload>
          }
          createMany: {
            args: Prisma.TriggerDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TriggerDefinitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerDefinitionPayload>[]
          }
          delete: {
            args: Prisma.TriggerDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerDefinitionPayload>
          }
          update: {
            args: Prisma.TriggerDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.TriggerDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TriggerDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TriggerDefinitionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerDefinitionPayload>[]
          }
          upsert: {
            args: Prisma.TriggerDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerDefinitionPayload>
          }
          aggregate: {
            args: Prisma.TriggerDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTriggerDefinition>
          }
          groupBy: {
            args: Prisma.TriggerDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TriggerDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TriggerDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<TriggerDefinitionCountAggregateOutputType> | number
          }
        }
      }
      Conditional: {
        payload: Prisma.$ConditionalPayload<ExtArgs>
        fields: Prisma.ConditionalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConditionalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConditionalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionalPayload>
          }
          findFirst: {
            args: Prisma.ConditionalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConditionalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionalPayload>
          }
          findMany: {
            args: Prisma.ConditionalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionalPayload>[]
          }
          create: {
            args: Prisma.ConditionalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionalPayload>
          }
          createMany: {
            args: Prisma.ConditionalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConditionalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionalPayload>[]
          }
          delete: {
            args: Prisma.ConditionalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionalPayload>
          }
          update: {
            args: Prisma.ConditionalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionalPayload>
          }
          deleteMany: {
            args: Prisma.ConditionalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConditionalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConditionalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionalPayload>[]
          }
          upsert: {
            args: Prisma.ConditionalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionalPayload>
          }
          aggregate: {
            args: Prisma.ConditionalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConditional>
          }
          groupBy: {
            args: Prisma.ConditionalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConditionalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConditionalCountArgs<ExtArgs>
            result: $Utils.Optional<ConditionalCountAggregateOutputType> | number
          }
        }
      }
      Todo: {
        payload: Prisma.$TodoPayload<ExtArgs>
        fields: Prisma.TodoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TodoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TodoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>
          }
          findFirst: {
            args: Prisma.TodoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TodoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>
          }
          findMany: {
            args: Prisma.TodoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>[]
          }
          create: {
            args: Prisma.TodoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>
          }
          createMany: {
            args: Prisma.TodoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TodoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>[]
          }
          delete: {
            args: Prisma.TodoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>
          }
          update: {
            args: Prisma.TodoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>
          }
          deleteMany: {
            args: Prisma.TodoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TodoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TodoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>[]
          }
          upsert: {
            args: Prisma.TodoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>
          }
          aggregate: {
            args: Prisma.TodoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTodo>
          }
          groupBy: {
            args: Prisma.TodoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TodoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TodoCountArgs<ExtArgs>
            result: $Utils.Optional<TodoCountAggregateOutputType> | number
          }
        }
      }
      TodoItem: {
        payload: Prisma.$TodoItemPayload<ExtArgs>
        fields: Prisma.TodoItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TodoItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TodoItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>
          }
          findFirst: {
            args: Prisma.TodoItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TodoItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>
          }
          findMany: {
            args: Prisma.TodoItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>[]
          }
          create: {
            args: Prisma.TodoItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>
          }
          createMany: {
            args: Prisma.TodoItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TodoItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>[]
          }
          delete: {
            args: Prisma.TodoItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>
          }
          update: {
            args: Prisma.TodoItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>
          }
          deleteMany: {
            args: Prisma.TodoItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TodoItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TodoItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>[]
          }
          upsert: {
            args: Prisma.TodoItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoItemPayload>
          }
          aggregate: {
            args: Prisma.TodoItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTodoItem>
          }
          groupBy: {
            args: Prisma.TodoItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TodoItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TodoItemCountArgs<ExtArgs>
            result: $Utils.Optional<TodoItemCountAggregateOutputType> | number
          }
        }
      }
      TodoUserProcess: {
        payload: Prisma.$TodoUserProcessPayload<ExtArgs>
        fields: Prisma.TodoUserProcessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TodoUserProcessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoUserProcessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TodoUserProcessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoUserProcessPayload>
          }
          findFirst: {
            args: Prisma.TodoUserProcessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoUserProcessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TodoUserProcessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoUserProcessPayload>
          }
          findMany: {
            args: Prisma.TodoUserProcessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoUserProcessPayload>[]
          }
          create: {
            args: Prisma.TodoUserProcessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoUserProcessPayload>
          }
          createMany: {
            args: Prisma.TodoUserProcessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TodoUserProcessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoUserProcessPayload>[]
          }
          delete: {
            args: Prisma.TodoUserProcessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoUserProcessPayload>
          }
          update: {
            args: Prisma.TodoUserProcessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoUserProcessPayload>
          }
          deleteMany: {
            args: Prisma.TodoUserProcessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TodoUserProcessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TodoUserProcessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoUserProcessPayload>[]
          }
          upsert: {
            args: Prisma.TodoUserProcessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoUserProcessPayload>
          }
          aggregate: {
            args: Prisma.TodoUserProcessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTodoUserProcess>
          }
          groupBy: {
            args: Prisma.TodoUserProcessGroupByArgs<ExtArgs>
            result: $Utils.Optional<TodoUserProcessGroupByOutputType>[]
          }
          count: {
            args: Prisma.TodoUserProcessCountArgs<ExtArgs>
            result: $Utils.Optional<TodoUserProcessCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    provider?: ProviderOmit
    token?: TokenOmit
    company?: CompanyOmit
    jobPosting?: JobPostingOmit
    jobPostingLanguage?: JobPostingLanguageOmit
    jobPostingRequirement?: JobPostingRequirementOmit
    jobPostingMerit?: JobPostingMeritOmit
    jobPostingApplicantQuality?: JobPostingApplicantQualityOmit
    jobPostingLocation?: JobPostingLocationOmit
    jobPostingWorkArrengment?: JobPostingWorkArrengmentOmit
    jobPostingEmploymentType?: JobPostingEmploymentTypeOmit
    jobPostingSalary?: JobPostingSalaryOmit
    createdJobPosting?: CreatedJobPostingOmit
    jobApplicants?: JobApplicantsOmit
    userProcess?: UserProcessOmit
    userProcessStep?: UserProcessStepOmit
    userPipelineStepComment?: UserPipelineStepCommentOmit
    process?: ProcessOmit
    processStep?: ProcessStepOmit
    actionDefinition?: ActionDefinitionOmit
    triggerDefinition?: TriggerDefinitionOmit
    conditional?: ConditionalOmit
    todo?: TodoOmit
    todoItem?: TodoItemOmit
    todoUserProcess?: TodoUserProcessOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    providers: number
    applications: number
    userProcess: number
    createdJobPostings: number
    userPipelineStepComments: number
    processSteps: number
    processes: number
    todos: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | UserCountOutputTypeCountProvidersArgs
    applications?: boolean | UserCountOutputTypeCountApplicationsArgs
    userProcess?: boolean | UserCountOutputTypeCountUserProcessArgs
    createdJobPostings?: boolean | UserCountOutputTypeCountCreatedJobPostingsArgs
    userPipelineStepComments?: boolean | UserCountOutputTypeCountUserPipelineStepCommentsArgs
    processSteps?: boolean | UserCountOutputTypeCountProcessStepsArgs
    processes?: boolean | UserCountOutputTypeCountProcessesArgs
    todos?: boolean | UserCountOutputTypeCountTodosArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicantsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProcessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedJobPostingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatedJobPostingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserPipelineStepCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPipelineStepCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessStepWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTodosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TodoWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    users: number
    jobPostings: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    jobPostings?: boolean | CompanyCountOutputTypeCountJobPostingsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountJobPostingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingWhereInput
  }


  /**
   * Count Type JobPostingCountOutputType
   */

  export type JobPostingCountOutputType = {
    language: number
    jobRequirements: number
    merits: number
    applicantQualities: number
    userJobApplications: number
    userProcesses: number
  }

  export type JobPostingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    language?: boolean | JobPostingCountOutputTypeCountLanguageArgs
    jobRequirements?: boolean | JobPostingCountOutputTypeCountJobRequirementsArgs
    merits?: boolean | JobPostingCountOutputTypeCountMeritsArgs
    applicantQualities?: boolean | JobPostingCountOutputTypeCountApplicantQualitiesArgs
    userJobApplications?: boolean | JobPostingCountOutputTypeCountUserJobApplicationsArgs
    userProcesses?: boolean | JobPostingCountOutputTypeCountUserProcessesArgs
  }

  // Custom InputTypes
  /**
   * JobPostingCountOutputType without action
   */
  export type JobPostingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingCountOutputType
     */
    select?: JobPostingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobPostingCountOutputType without action
   */
  export type JobPostingCountOutputTypeCountLanguageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingLanguageWhereInput
  }

  /**
   * JobPostingCountOutputType without action
   */
  export type JobPostingCountOutputTypeCountJobRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingRequirementWhereInput
  }

  /**
   * JobPostingCountOutputType without action
   */
  export type JobPostingCountOutputTypeCountMeritsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingMeritWhereInput
  }

  /**
   * JobPostingCountOutputType without action
   */
  export type JobPostingCountOutputTypeCountApplicantQualitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingApplicantQualityWhereInput
  }

  /**
   * JobPostingCountOutputType without action
   */
  export type JobPostingCountOutputTypeCountUserJobApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicantsWhereInput
  }

  /**
   * JobPostingCountOutputType without action
   */
  export type JobPostingCountOutputTypeCountUserProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProcessWhereInput
  }


  /**
   * Count Type UserProcessCountOutputType
   */

  export type UserProcessCountOutputType = {
    steps: number
    todos: number
  }

  export type UserProcessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | UserProcessCountOutputTypeCountStepsArgs
    todos?: boolean | UserProcessCountOutputTypeCountTodosArgs
  }

  // Custom InputTypes
  /**
   * UserProcessCountOutputType without action
   */
  export type UserProcessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessCountOutputType
     */
    select?: UserProcessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserProcessCountOutputType without action
   */
  export type UserProcessCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProcessStepWhereInput
  }

  /**
   * UserProcessCountOutputType without action
   */
  export type UserProcessCountOutputTypeCountTodosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TodoUserProcessWhereInput
  }


  /**
   * Count Type UserProcessStepCountOutputType
   */

  export type UserProcessStepCountOutputType = {
    comments: number
  }

  export type UserProcessStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | UserProcessStepCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * UserProcessStepCountOutputType without action
   */
  export type UserProcessStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStepCountOutputType
     */
    select?: UserProcessStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserProcessStepCountOutputType without action
   */
  export type UserProcessStepCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPipelineStepCommentWhereInput
  }


  /**
   * Count Type ProcessCountOutputType
   */

  export type ProcessCountOutputType = {
    steps: number
    processes: number
  }

  export type ProcessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | ProcessCountOutputTypeCountStepsArgs
    processes?: boolean | ProcessCountOutputTypeCountProcessesArgs
  }

  // Custom InputTypes
  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCountOutputType
     */
    select?: ProcessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessStepWhereInput
  }

  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeCountProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProcessWhereInput
  }


  /**
   * Count Type ProcessStepCountOutputType
   */

  export type ProcessStepCountOutputType = {
    triggers: number
    actions: number
    userProcessSteps: number
  }

  export type ProcessStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    triggers?: boolean | ProcessStepCountOutputTypeCountTriggersArgs
    actions?: boolean | ProcessStepCountOutputTypeCountActionsArgs
    userProcessSteps?: boolean | ProcessStepCountOutputTypeCountUserProcessStepsArgs
  }

  // Custom InputTypes
  /**
   * ProcessStepCountOutputType without action
   */
  export type ProcessStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStepCountOutputType
     */
    select?: ProcessStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcessStepCountOutputType without action
   */
  export type ProcessStepCountOutputTypeCountTriggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriggerDefinitionWhereInput
  }

  /**
   * ProcessStepCountOutputType without action
   */
  export type ProcessStepCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionDefinitionWhereInput
  }

  /**
   * ProcessStepCountOutputType without action
   */
  export type ProcessStepCountOutputTypeCountUserProcessStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProcessStepWhereInput
  }


  /**
   * Count Type TriggerDefinitionCountOutputType
   */

  export type TriggerDefinitionCountOutputType = {
    conditions: number
  }

  export type TriggerDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conditions?: boolean | TriggerDefinitionCountOutputTypeCountConditionsArgs
  }

  // Custom InputTypes
  /**
   * TriggerDefinitionCountOutputType without action
   */
  export type TriggerDefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerDefinitionCountOutputType
     */
    select?: TriggerDefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TriggerDefinitionCountOutputType without action
   */
  export type TriggerDefinitionCountOutputTypeCountConditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConditionalWhereInput
  }


  /**
   * Count Type TodoCountOutputType
   */

  export type TodoCountOutputType = {
    items: number
    userProcesses: number
  }

  export type TodoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TodoCountOutputTypeCountItemsArgs
    userProcesses?: boolean | TodoCountOutputTypeCountUserProcessesArgs
  }

  // Custom InputTypes
  /**
   * TodoCountOutputType without action
   */
  export type TodoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoCountOutputType
     */
    select?: TodoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TodoCountOutputType without action
   */
  export type TodoCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TodoItemWhereInput
  }

  /**
   * TodoCountOutputType without action
   */
  export type TodoCountOutputTypeCountUserProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TodoUserProcessWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: string | null
    image: string | null
    companyId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: string | null
    image: string | null
    companyId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    companyId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    companyId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    companyId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    companyId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: string | null
    image: string | null
    companyId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    companyId?: boolean
    providers?: boolean | User$providersArgs<ExtArgs>
    applications?: boolean | User$applicationsArgs<ExtArgs>
    userProcess?: boolean | User$userProcessArgs<ExtArgs>
    company?: boolean | User$companyArgs<ExtArgs>
    createdJobPostings?: boolean | User$createdJobPostingsArgs<ExtArgs>
    userPipelineStepComments?: boolean | User$userPipelineStepCommentsArgs<ExtArgs>
    processSteps?: boolean | User$processStepsArgs<ExtArgs>
    processes?: boolean | User$processesArgs<ExtArgs>
    todos?: boolean | User$todosArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    companyId?: boolean
    company?: boolean | User$companyArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    companyId?: boolean
    company?: boolean | User$companyArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    companyId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "companyId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | User$providersArgs<ExtArgs>
    applications?: boolean | User$applicationsArgs<ExtArgs>
    userProcess?: boolean | User$userProcessArgs<ExtArgs>
    company?: boolean | User$companyArgs<ExtArgs>
    createdJobPostings?: boolean | User$createdJobPostingsArgs<ExtArgs>
    userPipelineStepComments?: boolean | User$userPipelineStepCommentsArgs<ExtArgs>
    processSteps?: boolean | User$processStepsArgs<ExtArgs>
    processes?: boolean | User$processesArgs<ExtArgs>
    todos?: boolean | User$todosArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | User$companyArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | User$companyArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      providers: Prisma.$ProviderPayload<ExtArgs>[]
      applications: Prisma.$JobApplicantsPayload<ExtArgs>[]
      userProcess: Prisma.$UserProcessPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs> | null
      createdJobPostings: Prisma.$CreatedJobPostingPayload<ExtArgs>[]
      userPipelineStepComments: Prisma.$UserPipelineStepCommentPayload<ExtArgs>[]
      processSteps: Prisma.$ProcessStepPayload<ExtArgs>[]
      processes: Prisma.$ProcessPayload<ExtArgs>[]
      todos: Prisma.$TodoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: string | null
      image: string | null
      companyId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    providers<T extends User$providersArgs<ExtArgs> = {}>(args?: Subset<T, User$providersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applications<T extends User$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userProcess<T extends User$userProcessArgs<ExtArgs> = {}>(args?: Subset<T, User$userProcessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends User$companyArgs<ExtArgs> = {}>(args?: Subset<T, User$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdJobPostings<T extends User$createdJobPostingsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdJobPostingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatedJobPostingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPipelineStepComments<T extends User$userPipelineStepCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$userPipelineStepCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPipelineStepCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processSteps<T extends User$processStepsArgs<ExtArgs> = {}>(args?: Subset<T, User$processStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processes<T extends User$processesArgs<ExtArgs> = {}>(args?: Subset<T, User$processesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    todos<T extends User$todosArgs<ExtArgs> = {}>(args?: Subset<T, User$todosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly companyId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.providers
   */
  export type User$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    where?: ProviderWhereInput
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    cursor?: ProviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * User.applications
   */
  export type User$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicants
     */
    select?: JobApplicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicants
     */
    omit?: JobApplicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicantsInclude<ExtArgs> | null
    where?: JobApplicantsWhereInput
    orderBy?: JobApplicantsOrderByWithRelationInput | JobApplicantsOrderByWithRelationInput[]
    cursor?: JobApplicantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobApplicantsScalarFieldEnum | JobApplicantsScalarFieldEnum[]
  }

  /**
   * User.userProcess
   */
  export type User$userProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessInclude<ExtArgs> | null
    where?: UserProcessWhereInput
    orderBy?: UserProcessOrderByWithRelationInput | UserProcessOrderByWithRelationInput[]
    cursor?: UserProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProcessScalarFieldEnum | UserProcessScalarFieldEnum[]
  }

  /**
   * User.company
   */
  export type User$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * User.createdJobPostings
   */
  export type User$createdJobPostingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatedJobPosting
     */
    select?: CreatedJobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatedJobPosting
     */
    omit?: CreatedJobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatedJobPostingInclude<ExtArgs> | null
    where?: CreatedJobPostingWhereInput
    orderBy?: CreatedJobPostingOrderByWithRelationInput | CreatedJobPostingOrderByWithRelationInput[]
    cursor?: CreatedJobPostingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatedJobPostingScalarFieldEnum | CreatedJobPostingScalarFieldEnum[]
  }

  /**
   * User.userPipelineStepComments
   */
  export type User$userPipelineStepCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPipelineStepComment
     */
    select?: UserPipelineStepCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPipelineStepComment
     */
    omit?: UserPipelineStepCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPipelineStepCommentInclude<ExtArgs> | null
    where?: UserPipelineStepCommentWhereInput
    orderBy?: UserPipelineStepCommentOrderByWithRelationInput | UserPipelineStepCommentOrderByWithRelationInput[]
    cursor?: UserPipelineStepCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPipelineStepCommentScalarFieldEnum | UserPipelineStepCommentScalarFieldEnum[]
  }

  /**
   * User.processSteps
   */
  export type User$processStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    cursor?: ProcessStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * User.processes
   */
  export type User$processesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    cursor?: ProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * User.todos
   */
  export type User$todosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    where?: TodoWhereInput
    orderBy?: TodoOrderByWithRelationInput | TodoOrderByWithRelationInput[]
    cursor?: TodoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TodoScalarFieldEnum | TodoScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Provider
   */

  export type AggregateProvider = {
    _count: ProviderCountAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  export type ProviderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: $Enums.ProviderEnum | null
    providerAccountId: string | null
  }

  export type ProviderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: $Enums.ProviderEnum | null
    providerAccountId: string | null
  }

  export type ProviderCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    providerAccountId: number
    _all: number
  }


  export type ProviderMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
  }

  export type ProviderMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
  }

  export type ProviderCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    _all?: true
  }

  export type ProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provider to aggregate.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Providers
    **/
    _count?: true | ProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderMaxAggregateInputType
  }

  export type GetProviderAggregateType<T extends ProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider[P]>
      : GetScalarType<T[P], AggregateProvider[P]>
  }




  export type ProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderWhereInput
    orderBy?: ProviderOrderByWithAggregationInput | ProviderOrderByWithAggregationInput[]
    by: ProviderScalarFieldEnum[] | ProviderScalarFieldEnum
    having?: ProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderCountAggregateInputType | true
    _min?: ProviderMinAggregateInputType
    _max?: ProviderMaxAggregateInputType
  }

  export type ProviderGroupByOutputType = {
    id: string
    userId: string
    provider: $Enums.ProviderEnum
    providerAccountId: string
    _count: ProviderCountAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  type GetProviderGroupByPayload<T extends ProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderGroupByOutputType[P]>
        }
      >
    >


  export type ProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    token?: boolean | Provider$tokenArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
  }

  export type ProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "providerAccountId", ExtArgs["result"]["provider"]>
  export type ProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | Provider$tokenArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProviderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Provider"
    objects: {
      token: Prisma.$TokenPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: $Enums.ProviderEnum
      providerAccountId: string
    }, ExtArgs["result"]["provider"]>
    composites: {}
  }

  type ProviderGetPayload<S extends boolean | null | undefined | ProviderDefaultArgs> = $Result.GetResult<Prisma.$ProviderPayload, S>

  type ProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderCountAggregateInputType | true
    }

  export interface ProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Provider'], meta: { name: 'Provider' } }
    /**
     * Find zero or one Provider that matches the filter.
     * @param {ProviderFindUniqueArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderFindUniqueArgs>(args: SelectSubset<T, ProviderFindUniqueArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderFindUniqueOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderFindFirstArgs>(args?: SelectSubset<T, ProviderFindFirstArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.provider.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.provider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerWithIdOnly = await prisma.provider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderFindManyArgs>(args?: SelectSubset<T, ProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provider.
     * @param {ProviderCreateArgs} args - Arguments to create a Provider.
     * @example
     * // Create one Provider
     * const Provider = await prisma.provider.create({
     *   data: {
     *     // ... data to create a Provider
     *   }
     * })
     * 
     */
    create<T extends ProviderCreateArgs>(args: SelectSubset<T, ProviderCreateArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Providers.
     * @param {ProviderCreateManyArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderCreateManyArgs>(args?: SelectSubset<T, ProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Providers and returns the data saved in the database.
     * @param {ProviderCreateManyAndReturnArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Providers and only return the `id`
     * const providerWithIdOnly = await prisma.provider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, ProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provider.
     * @param {ProviderDeleteArgs} args - Arguments to delete one Provider.
     * @example
     * // Delete one Provider
     * const Provider = await prisma.provider.delete({
     *   where: {
     *     // ... filter to delete one Provider
     *   }
     * })
     * 
     */
    delete<T extends ProviderDeleteArgs>(args: SelectSubset<T, ProviderDeleteArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provider.
     * @param {ProviderUpdateArgs} args - Arguments to update one Provider.
     * @example
     * // Update one Provider
     * const provider = await prisma.provider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderUpdateArgs>(args: SelectSubset<T, ProviderUpdateArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Providers.
     * @param {ProviderDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.provider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderDeleteManyArgs>(args?: SelectSubset<T, ProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderUpdateManyArgs>(args: SelectSubset<T, ProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers and returns the data updated in the database.
     * @param {ProviderUpdateManyAndReturnArgs} args - Arguments to update many Providers.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Providers and only return the `id`
     * const providerWithIdOnly = await prisma.provider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProviderUpdateManyAndReturnArgs>(args: SelectSubset<T, ProviderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provider.
     * @param {ProviderUpsertArgs} args - Arguments to update or create a Provider.
     * @example
     * // Update or create a Provider
     * const provider = await prisma.provider.upsert({
     *   create: {
     *     // ... data to create a Provider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider we want to update
     *   }
     * })
     */
    upsert<T extends ProviderUpsertArgs>(args: SelectSubset<T, ProviderUpsertArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.provider.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends ProviderCountArgs>(
      args?: Subset<T, ProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAggregateArgs>(args: Subset<T, ProviderAggregateArgs>): Prisma.PrismaPromise<GetProviderAggregateType<T>>

    /**
     * Group by Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderGroupByArgs['orderBy'] }
        : { orderBy?: ProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Provider model
   */
  readonly fields: ProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Provider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    token<T extends Provider$tokenArgs<ExtArgs> = {}>(args?: Subset<T, Provider$tokenArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Provider model
   */
  interface ProviderFieldRefs {
    readonly id: FieldRef<"Provider", 'String'>
    readonly userId: FieldRef<"Provider", 'String'>
    readonly provider: FieldRef<"Provider", 'ProviderEnum'>
    readonly providerAccountId: FieldRef<"Provider", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Provider findUnique
   */
  export type ProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findUniqueOrThrow
   */
  export type ProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findFirst
   */
  export type ProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findFirstOrThrow
   */
  export type ProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findMany
   */
  export type ProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider create
   */
  export type ProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a Provider.
     */
    data: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
  }

  /**
   * Provider createMany
   */
  export type ProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Provider createManyAndReturn
   */
  export type ProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Provider update
   */
  export type ProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a Provider.
     */
    data: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
    /**
     * Choose, which Provider to update.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider updateMany
   */
  export type ProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to update.
     */
    limit?: number
  }

  /**
   * Provider updateManyAndReturn
   */
  export type ProviderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Provider upsert
   */
  export type ProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the Provider to update in case it exists.
     */
    where: ProviderWhereUniqueInput
    /**
     * In case the Provider found by the `where` argument doesn't exist, create a new Provider with this data.
     */
    create: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
    /**
     * In case the Provider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
  }

  /**
   * Provider delete
   */
  export type ProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter which Provider to delete.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider deleteMany
   */
  export type ProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Providers to delete
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to delete.
     */
    limit?: number
  }

  /**
   * Provider.token
   */
  export type Provider$tokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
  }

  /**
   * Provider without action
   */
  export type ProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
  }


  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type TokenSumAggregateOutputType = {
    expires_at: number | null
  }

  export type TokenMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type TokenMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    providerId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type TokenAvgAggregateInputType = {
    expires_at?: true
  }

  export type TokenSumAggregateInputType = {
    expires_at?: true
  }

  export type TokenMinAggregateInputType = {
    id?: true
    providerId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    providerId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    providerId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _avg?: TokenAvgAggregateInputType
    _sum?: TokenSumAggregateInputType
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    id: string
    providerId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectScalar = {
    id?: boolean
    providerId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type TokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["token"]>
  export type TokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type TokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type TokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }

  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["token"]>
    composites: {}
  }

  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenFindUniqueArgs>(args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenFindFirstArgs>(args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenFindManyArgs>(args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
     */
    create<T extends TokenCreateArgs>(args: SelectSubset<T, TokenCreateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tokens.
     * @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenCreateManyArgs>(args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {TokenCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
     */
    delete<T extends TokenDeleteArgs>(args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenUpdateArgs>(args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenDeleteManyArgs>(args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenUpdateManyArgs>(args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens and returns the data updated in the database.
     * @param {TokenUpdateManyAndReturnArgs} args - Arguments to update many Tokens.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TokenUpdateManyAndReturnArgs>(args: SelectSubset<T, TokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
     */
    upsert<T extends TokenUpsertArgs>(args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Token model
   */
  interface TokenFieldRefs {
    readonly id: FieldRef<"Token", 'String'>
    readonly providerId: FieldRef<"Token", 'String'>
    readonly refresh_token: FieldRef<"Token", 'String'>
    readonly access_token: FieldRef<"Token", 'String'>
    readonly expires_at: FieldRef<"Token", 'Int'>
    readonly token_type: FieldRef<"Token", 'String'>
    readonly scope: FieldRef<"Token", 'String'>
    readonly id_token: FieldRef<"Token", 'String'>
    readonly session_state: FieldRef<"Token", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }

  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token createManyAndReturn
   */
  export type TokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
  }

  /**
   * Token updateManyAndReturn
   */
  export type TokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }

  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to delete.
     */
    limit?: number
  }

  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    logo: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    logo?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    logo?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    logo: string | null
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    users?: boolean | Company$usersArgs<ExtArgs>
    jobPostings?: boolean | Company$jobPostingsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    logo?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "logo", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Company$usersArgs<ExtArgs>
    jobPostings?: boolean | Company$jobPostingsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      jobPostings: Prisma.$JobPostingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      logo: string | null
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobPostings<T extends Company$jobPostingsArgs<ExtArgs> = {}>(args?: Subset<T, Company$jobPostingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly logo: FieldRef<"Company", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company.jobPostings
   */
  export type Company$jobPostingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    where?: JobPostingWhereInput
    orderBy?: JobPostingOrderByWithRelationInput | JobPostingOrderByWithRelationInput[]
    cursor?: JobPostingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobPostingScalarFieldEnum | JobPostingScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model JobPosting
   */

  export type AggregateJobPosting = {
    _count: JobPostingCountAggregateOutputType | null
    _min: JobPostingMinAggregateOutputType | null
    _max: JobPostingMaxAggregateOutputType | null
  }

  export type JobPostingMinAggregateOutputType = {
    id: string | null
    title: string | null
    companyName: string | null
    companyLogo: string | null
    jobPostingUrl: string | null
    jobDescription: string | null
    markdownText: string | null
    status: string | null
    endsAt: string | null
    createdAt: string | null
    updatedAt: string | null
    companyId: string | null
  }

  export type JobPostingMaxAggregateOutputType = {
    id: string | null
    title: string | null
    companyName: string | null
    companyLogo: string | null
    jobPostingUrl: string | null
    jobDescription: string | null
    markdownText: string | null
    status: string | null
    endsAt: string | null
    createdAt: string | null
    updatedAt: string | null
    companyId: string | null
  }

  export type JobPostingCountAggregateOutputType = {
    id: number
    title: number
    companyName: number
    companyLogo: number
    jobPostingUrl: number
    jobDescription: number
    markdownText: number
    status: number
    endsAt: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type JobPostingMinAggregateInputType = {
    id?: true
    title?: true
    companyName?: true
    companyLogo?: true
    jobPostingUrl?: true
    jobDescription?: true
    markdownText?: true
    status?: true
    endsAt?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type JobPostingMaxAggregateInputType = {
    id?: true
    title?: true
    companyName?: true
    companyLogo?: true
    jobPostingUrl?: true
    jobDescription?: true
    markdownText?: true
    status?: true
    endsAt?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type JobPostingCountAggregateInputType = {
    id?: true
    title?: true
    companyName?: true
    companyLogo?: true
    jobPostingUrl?: true
    jobDescription?: true
    markdownText?: true
    status?: true
    endsAt?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type JobPostingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPosting to aggregate.
     */
    where?: JobPostingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostings to fetch.
     */
    orderBy?: JobPostingOrderByWithRelationInput | JobPostingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPostingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPostings
    **/
    _count?: true | JobPostingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostingMaxAggregateInputType
  }

  export type GetJobPostingAggregateType<T extends JobPostingAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPosting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPosting[P]>
      : GetScalarType<T[P], AggregateJobPosting[P]>
  }




  export type JobPostingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingWhereInput
    orderBy?: JobPostingOrderByWithAggregationInput | JobPostingOrderByWithAggregationInput[]
    by: JobPostingScalarFieldEnum[] | JobPostingScalarFieldEnum
    having?: JobPostingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostingCountAggregateInputType | true
    _min?: JobPostingMinAggregateInputType
    _max?: JobPostingMaxAggregateInputType
  }

  export type JobPostingGroupByOutputType = {
    id: string
    title: string
    companyName: string
    companyLogo: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status: string
    endsAt: string | null
    createdAt: string
    updatedAt: string
    companyId: string | null
    _count: JobPostingCountAggregateOutputType | null
    _min: JobPostingMinAggregateOutputType | null
    _max: JobPostingMaxAggregateOutputType | null
  }

  type GetJobPostingGroupByPayload<T extends JobPostingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPostingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostingGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostingGroupByOutputType[P]>
        }
      >
    >


  export type JobPostingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    companyName?: boolean
    companyLogo?: boolean
    jobPostingUrl?: boolean
    jobDescription?: boolean
    markdownText?: boolean
    status?: boolean
    endsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    language?: boolean | JobPosting$languageArgs<ExtArgs>
    jobRequirements?: boolean | JobPosting$jobRequirementsArgs<ExtArgs>
    merits?: boolean | JobPosting$meritsArgs<ExtArgs>
    applicantQualities?: boolean | JobPosting$applicantQualitiesArgs<ExtArgs>
    location?: boolean | JobPosting$locationArgs<ExtArgs>
    workArrengment?: boolean | JobPosting$workArrengmentArgs<ExtArgs>
    employmentType?: boolean | JobPosting$employmentTypeArgs<ExtArgs>
    salary?: boolean | JobPosting$salaryArgs<ExtArgs>
    createdJobPosting?: boolean | JobPosting$createdJobPostingArgs<ExtArgs>
    company?: boolean | JobPosting$companyArgs<ExtArgs>
    userJobApplications?: boolean | JobPosting$userJobApplicationsArgs<ExtArgs>
    userProcesses?: boolean | JobPosting$userProcessesArgs<ExtArgs>
    _count?: boolean | JobPostingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPosting"]>

  export type JobPostingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    companyName?: boolean
    companyLogo?: boolean
    jobPostingUrl?: boolean
    jobDescription?: boolean
    markdownText?: boolean
    status?: boolean
    endsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | JobPosting$companyArgs<ExtArgs>
  }, ExtArgs["result"]["jobPosting"]>

  export type JobPostingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    companyName?: boolean
    companyLogo?: boolean
    jobPostingUrl?: boolean
    jobDescription?: boolean
    markdownText?: boolean
    status?: boolean
    endsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | JobPosting$companyArgs<ExtArgs>
  }, ExtArgs["result"]["jobPosting"]>

  export type JobPostingSelectScalar = {
    id?: boolean
    title?: boolean
    companyName?: boolean
    companyLogo?: boolean
    jobPostingUrl?: boolean
    jobDescription?: boolean
    markdownText?: boolean
    status?: boolean
    endsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type JobPostingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "companyName" | "companyLogo" | "jobPostingUrl" | "jobDescription" | "markdownText" | "status" | "endsAt" | "createdAt" | "updatedAt" | "companyId", ExtArgs["result"]["jobPosting"]>
  export type JobPostingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    language?: boolean | JobPosting$languageArgs<ExtArgs>
    jobRequirements?: boolean | JobPosting$jobRequirementsArgs<ExtArgs>
    merits?: boolean | JobPosting$meritsArgs<ExtArgs>
    applicantQualities?: boolean | JobPosting$applicantQualitiesArgs<ExtArgs>
    location?: boolean | JobPosting$locationArgs<ExtArgs>
    workArrengment?: boolean | JobPosting$workArrengmentArgs<ExtArgs>
    employmentType?: boolean | JobPosting$employmentTypeArgs<ExtArgs>
    salary?: boolean | JobPosting$salaryArgs<ExtArgs>
    createdJobPosting?: boolean | JobPosting$createdJobPostingArgs<ExtArgs>
    company?: boolean | JobPosting$companyArgs<ExtArgs>
    userJobApplications?: boolean | JobPosting$userJobApplicationsArgs<ExtArgs>
    userProcesses?: boolean | JobPosting$userProcessesArgs<ExtArgs>
    _count?: boolean | JobPostingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobPostingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | JobPosting$companyArgs<ExtArgs>
  }
  export type JobPostingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | JobPosting$companyArgs<ExtArgs>
  }

  export type $JobPostingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPosting"
    objects: {
      language: Prisma.$JobPostingLanguagePayload<ExtArgs>[]
      jobRequirements: Prisma.$JobPostingRequirementPayload<ExtArgs>[]
      merits: Prisma.$JobPostingMeritPayload<ExtArgs>[]
      applicantQualities: Prisma.$JobPostingApplicantQualityPayload<ExtArgs>[]
      location: Prisma.$JobPostingLocationPayload<ExtArgs> | null
      workArrengment: Prisma.$JobPostingWorkArrengmentPayload<ExtArgs> | null
      employmentType: Prisma.$JobPostingEmploymentTypePayload<ExtArgs> | null
      salary: Prisma.$JobPostingSalaryPayload<ExtArgs> | null
      createdJobPosting: Prisma.$CreatedJobPostingPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs> | null
      userJobApplications: Prisma.$JobApplicantsPayload<ExtArgs>[]
      userProcesses: Prisma.$UserProcessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      companyName: string
      companyLogo: string | null
      jobPostingUrl: string
      jobDescription: string
      markdownText: string
      status: string
      endsAt: string | null
      createdAt: string
      updatedAt: string
      companyId: string | null
    }, ExtArgs["result"]["jobPosting"]>
    composites: {}
  }

  type JobPostingGetPayload<S extends boolean | null | undefined | JobPostingDefaultArgs> = $Result.GetResult<Prisma.$JobPostingPayload, S>

  type JobPostingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobPostingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobPostingCountAggregateInputType | true
    }

  export interface JobPostingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPosting'], meta: { name: 'JobPosting' } }
    /**
     * Find zero or one JobPosting that matches the filter.
     * @param {JobPostingFindUniqueArgs} args - Arguments to find a JobPosting
     * @example
     * // Get one JobPosting
     * const jobPosting = await prisma.jobPosting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobPostingFindUniqueArgs>(args: SelectSubset<T, JobPostingFindUniqueArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobPosting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobPostingFindUniqueOrThrowArgs} args - Arguments to find a JobPosting
     * @example
     * // Get one JobPosting
     * const jobPosting = await prisma.jobPosting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobPostingFindUniqueOrThrowArgs>(args: SelectSubset<T, JobPostingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPosting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingFindFirstArgs} args - Arguments to find a JobPosting
     * @example
     * // Get one JobPosting
     * const jobPosting = await prisma.jobPosting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobPostingFindFirstArgs>(args?: SelectSubset<T, JobPostingFindFirstArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPosting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingFindFirstOrThrowArgs} args - Arguments to find a JobPosting
     * @example
     * // Get one JobPosting
     * const jobPosting = await prisma.jobPosting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobPostingFindFirstOrThrowArgs>(args?: SelectSubset<T, JobPostingFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobPostings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPostings
     * const jobPostings = await prisma.jobPosting.findMany()
     * 
     * // Get first 10 JobPostings
     * const jobPostings = await prisma.jobPosting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPostingWithIdOnly = await prisma.jobPosting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobPostingFindManyArgs>(args?: SelectSubset<T, JobPostingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobPosting.
     * @param {JobPostingCreateArgs} args - Arguments to create a JobPosting.
     * @example
     * // Create one JobPosting
     * const JobPosting = await prisma.jobPosting.create({
     *   data: {
     *     // ... data to create a JobPosting
     *   }
     * })
     * 
     */
    create<T extends JobPostingCreateArgs>(args: SelectSubset<T, JobPostingCreateArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobPostings.
     * @param {JobPostingCreateManyArgs} args - Arguments to create many JobPostings.
     * @example
     * // Create many JobPostings
     * const jobPosting = await prisma.jobPosting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobPostingCreateManyArgs>(args?: SelectSubset<T, JobPostingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobPostings and returns the data saved in the database.
     * @param {JobPostingCreateManyAndReturnArgs} args - Arguments to create many JobPostings.
     * @example
     * // Create many JobPostings
     * const jobPosting = await prisma.jobPosting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobPostings and only return the `id`
     * const jobPostingWithIdOnly = await prisma.jobPosting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobPostingCreateManyAndReturnArgs>(args?: SelectSubset<T, JobPostingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobPosting.
     * @param {JobPostingDeleteArgs} args - Arguments to delete one JobPosting.
     * @example
     * // Delete one JobPosting
     * const JobPosting = await prisma.jobPosting.delete({
     *   where: {
     *     // ... filter to delete one JobPosting
     *   }
     * })
     * 
     */
    delete<T extends JobPostingDeleteArgs>(args: SelectSubset<T, JobPostingDeleteArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobPosting.
     * @param {JobPostingUpdateArgs} args - Arguments to update one JobPosting.
     * @example
     * // Update one JobPosting
     * const jobPosting = await prisma.jobPosting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobPostingUpdateArgs>(args: SelectSubset<T, JobPostingUpdateArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobPostings.
     * @param {JobPostingDeleteManyArgs} args - Arguments to filter JobPostings to delete.
     * @example
     * // Delete a few JobPostings
     * const { count } = await prisma.jobPosting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobPostingDeleteManyArgs>(args?: SelectSubset<T, JobPostingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPostings
     * const jobPosting = await prisma.jobPosting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobPostingUpdateManyArgs>(args: SelectSubset<T, JobPostingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostings and returns the data updated in the database.
     * @param {JobPostingUpdateManyAndReturnArgs} args - Arguments to update many JobPostings.
     * @example
     * // Update many JobPostings
     * const jobPosting = await prisma.jobPosting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobPostings and only return the `id`
     * const jobPostingWithIdOnly = await prisma.jobPosting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobPostingUpdateManyAndReturnArgs>(args: SelectSubset<T, JobPostingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobPosting.
     * @param {JobPostingUpsertArgs} args - Arguments to update or create a JobPosting.
     * @example
     * // Update or create a JobPosting
     * const jobPosting = await prisma.jobPosting.upsert({
     *   create: {
     *     // ... data to create a JobPosting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPosting we want to update
     *   }
     * })
     */
    upsert<T extends JobPostingUpsertArgs>(args: SelectSubset<T, JobPostingUpsertArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobPostings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingCountArgs} args - Arguments to filter JobPostings to count.
     * @example
     * // Count the number of JobPostings
     * const count = await prisma.jobPosting.count({
     *   where: {
     *     // ... the filter for the JobPostings we want to count
     *   }
     * })
    **/
    count<T extends JobPostingCountArgs>(
      args?: Subset<T, JobPostingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPosting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostingAggregateArgs>(args: Subset<T, JobPostingAggregateArgs>): Prisma.PrismaPromise<GetJobPostingAggregateType<T>>

    /**
     * Group by JobPosting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostingGroupByArgs['orderBy'] }
        : { orderBy?: JobPostingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPosting model
   */
  readonly fields: JobPostingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPosting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPostingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    language<T extends JobPosting$languageArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$languageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobRequirements<T extends JobPosting$jobRequirementsArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$jobRequirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingRequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    merits<T extends JobPosting$meritsArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$meritsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingMeritPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applicantQualities<T extends JobPosting$applicantQualitiesArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$applicantQualitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingApplicantQualityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    location<T extends JobPosting$locationArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$locationArgs<ExtArgs>>): Prisma__JobPostingLocationClient<$Result.GetResult<Prisma.$JobPostingLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workArrengment<T extends JobPosting$workArrengmentArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$workArrengmentArgs<ExtArgs>>): Prisma__JobPostingWorkArrengmentClient<$Result.GetResult<Prisma.$JobPostingWorkArrengmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employmentType<T extends JobPosting$employmentTypeArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$employmentTypeArgs<ExtArgs>>): Prisma__JobPostingEmploymentTypeClient<$Result.GetResult<Prisma.$JobPostingEmploymentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    salary<T extends JobPosting$salaryArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$salaryArgs<ExtArgs>>): Prisma__JobPostingSalaryClient<$Result.GetResult<Prisma.$JobPostingSalaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdJobPosting<T extends JobPosting$createdJobPostingArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$createdJobPostingArgs<ExtArgs>>): Prisma__CreatedJobPostingClient<$Result.GetResult<Prisma.$CreatedJobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends JobPosting$companyArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userJobApplications<T extends JobPosting$userJobApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$userJobApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userProcesses<T extends JobPosting$userProcessesArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$userProcessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobPosting model
   */
  interface JobPostingFieldRefs {
    readonly id: FieldRef<"JobPosting", 'String'>
    readonly title: FieldRef<"JobPosting", 'String'>
    readonly companyName: FieldRef<"JobPosting", 'String'>
    readonly companyLogo: FieldRef<"JobPosting", 'String'>
    readonly jobPostingUrl: FieldRef<"JobPosting", 'String'>
    readonly jobDescription: FieldRef<"JobPosting", 'String'>
    readonly markdownText: FieldRef<"JobPosting", 'String'>
    readonly status: FieldRef<"JobPosting", 'String'>
    readonly endsAt: FieldRef<"JobPosting", 'String'>
    readonly createdAt: FieldRef<"JobPosting", 'String'>
    readonly updatedAt: FieldRef<"JobPosting", 'String'>
    readonly companyId: FieldRef<"JobPosting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobPosting findUnique
   */
  export type JobPostingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * Filter, which JobPosting to fetch.
     */
    where: JobPostingWhereUniqueInput
  }

  /**
   * JobPosting findUniqueOrThrow
   */
  export type JobPostingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * Filter, which JobPosting to fetch.
     */
    where: JobPostingWhereUniqueInput
  }

  /**
   * JobPosting findFirst
   */
  export type JobPostingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * Filter, which JobPosting to fetch.
     */
    where?: JobPostingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostings to fetch.
     */
    orderBy?: JobPostingOrderByWithRelationInput | JobPostingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostings.
     */
    cursor?: JobPostingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostings.
     */
    distinct?: JobPostingScalarFieldEnum | JobPostingScalarFieldEnum[]
  }

  /**
   * JobPosting findFirstOrThrow
   */
  export type JobPostingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * Filter, which JobPosting to fetch.
     */
    where?: JobPostingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostings to fetch.
     */
    orderBy?: JobPostingOrderByWithRelationInput | JobPostingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostings.
     */
    cursor?: JobPostingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostings.
     */
    distinct?: JobPostingScalarFieldEnum | JobPostingScalarFieldEnum[]
  }

  /**
   * JobPosting findMany
   */
  export type JobPostingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * Filter, which JobPostings to fetch.
     */
    where?: JobPostingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostings to fetch.
     */
    orderBy?: JobPostingOrderByWithRelationInput | JobPostingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPostings.
     */
    cursor?: JobPostingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostings.
     */
    skip?: number
    distinct?: JobPostingScalarFieldEnum | JobPostingScalarFieldEnum[]
  }

  /**
   * JobPosting create
   */
  export type JobPostingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPosting.
     */
    data: XOR<JobPostingCreateInput, JobPostingUncheckedCreateInput>
  }

  /**
   * JobPosting createMany
   */
  export type JobPostingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPostings.
     */
    data: JobPostingCreateManyInput | JobPostingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPosting createManyAndReturn
   */
  export type JobPostingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * The data used to create many JobPostings.
     */
    data: JobPostingCreateManyInput | JobPostingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPosting update
   */
  export type JobPostingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPosting.
     */
    data: XOR<JobPostingUpdateInput, JobPostingUncheckedUpdateInput>
    /**
     * Choose, which JobPosting to update.
     */
    where: JobPostingWhereUniqueInput
  }

  /**
   * JobPosting updateMany
   */
  export type JobPostingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPostings.
     */
    data: XOR<JobPostingUpdateManyMutationInput, JobPostingUncheckedUpdateManyInput>
    /**
     * Filter which JobPostings to update
     */
    where?: JobPostingWhereInput
    /**
     * Limit how many JobPostings to update.
     */
    limit?: number
  }

  /**
   * JobPosting updateManyAndReturn
   */
  export type JobPostingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * The data used to update JobPostings.
     */
    data: XOR<JobPostingUpdateManyMutationInput, JobPostingUncheckedUpdateManyInput>
    /**
     * Filter which JobPostings to update
     */
    where?: JobPostingWhereInput
    /**
     * Limit how many JobPostings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPosting upsert
   */
  export type JobPostingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPosting to update in case it exists.
     */
    where: JobPostingWhereUniqueInput
    /**
     * In case the JobPosting found by the `where` argument doesn't exist, create a new JobPosting with this data.
     */
    create: XOR<JobPostingCreateInput, JobPostingUncheckedCreateInput>
    /**
     * In case the JobPosting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPostingUpdateInput, JobPostingUncheckedUpdateInput>
  }

  /**
   * JobPosting delete
   */
  export type JobPostingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * Filter which JobPosting to delete.
     */
    where: JobPostingWhereUniqueInput
  }

  /**
   * JobPosting deleteMany
   */
  export type JobPostingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostings to delete
     */
    where?: JobPostingWhereInput
    /**
     * Limit how many JobPostings to delete.
     */
    limit?: number
  }

  /**
   * JobPosting.language
   */
  export type JobPosting$languageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLanguage
     */
    select?: JobPostingLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLanguage
     */
    omit?: JobPostingLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLanguageInclude<ExtArgs> | null
    where?: JobPostingLanguageWhereInput
    orderBy?: JobPostingLanguageOrderByWithRelationInput | JobPostingLanguageOrderByWithRelationInput[]
    cursor?: JobPostingLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobPostingLanguageScalarFieldEnum | JobPostingLanguageScalarFieldEnum[]
  }

  /**
   * JobPosting.jobRequirements
   */
  export type JobPosting$jobRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingRequirement
     */
    select?: JobPostingRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingRequirement
     */
    omit?: JobPostingRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingRequirementInclude<ExtArgs> | null
    where?: JobPostingRequirementWhereInput
    orderBy?: JobPostingRequirementOrderByWithRelationInput | JobPostingRequirementOrderByWithRelationInput[]
    cursor?: JobPostingRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobPostingRequirementScalarFieldEnum | JobPostingRequirementScalarFieldEnum[]
  }

  /**
   * JobPosting.merits
   */
  export type JobPosting$meritsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingMerit
     */
    select?: JobPostingMeritSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingMerit
     */
    omit?: JobPostingMeritOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingMeritInclude<ExtArgs> | null
    where?: JobPostingMeritWhereInput
    orderBy?: JobPostingMeritOrderByWithRelationInput | JobPostingMeritOrderByWithRelationInput[]
    cursor?: JobPostingMeritWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobPostingMeritScalarFieldEnum | JobPostingMeritScalarFieldEnum[]
  }

  /**
   * JobPosting.applicantQualities
   */
  export type JobPosting$applicantQualitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingApplicantQuality
     */
    select?: JobPostingApplicantQualitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingApplicantQuality
     */
    omit?: JobPostingApplicantQualityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingApplicantQualityInclude<ExtArgs> | null
    where?: JobPostingApplicantQualityWhereInput
    orderBy?: JobPostingApplicantQualityOrderByWithRelationInput | JobPostingApplicantQualityOrderByWithRelationInput[]
    cursor?: JobPostingApplicantQualityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobPostingApplicantQualityScalarFieldEnum | JobPostingApplicantQualityScalarFieldEnum[]
  }

  /**
   * JobPosting.location
   */
  export type JobPosting$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLocation
     */
    select?: JobPostingLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLocation
     */
    omit?: JobPostingLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLocationInclude<ExtArgs> | null
    where?: JobPostingLocationWhereInput
  }

  /**
   * JobPosting.workArrengment
   */
  export type JobPosting$workArrengmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingWorkArrengment
     */
    select?: JobPostingWorkArrengmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingWorkArrengment
     */
    omit?: JobPostingWorkArrengmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingWorkArrengmentInclude<ExtArgs> | null
    where?: JobPostingWorkArrengmentWhereInput
  }

  /**
   * JobPosting.employmentType
   */
  export type JobPosting$employmentTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingEmploymentType
     */
    select?: JobPostingEmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingEmploymentType
     */
    omit?: JobPostingEmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingEmploymentTypeInclude<ExtArgs> | null
    where?: JobPostingEmploymentTypeWhereInput
  }

  /**
   * JobPosting.salary
   */
  export type JobPosting$salaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingSalary
     */
    select?: JobPostingSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingSalary
     */
    omit?: JobPostingSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingSalaryInclude<ExtArgs> | null
    where?: JobPostingSalaryWhereInput
  }

  /**
   * JobPosting.createdJobPosting
   */
  export type JobPosting$createdJobPostingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatedJobPosting
     */
    select?: CreatedJobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatedJobPosting
     */
    omit?: CreatedJobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatedJobPostingInclude<ExtArgs> | null
    where?: CreatedJobPostingWhereInput
  }

  /**
   * JobPosting.company
   */
  export type JobPosting$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * JobPosting.userJobApplications
   */
  export type JobPosting$userJobApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicants
     */
    select?: JobApplicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicants
     */
    omit?: JobApplicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicantsInclude<ExtArgs> | null
    where?: JobApplicantsWhereInput
    orderBy?: JobApplicantsOrderByWithRelationInput | JobApplicantsOrderByWithRelationInput[]
    cursor?: JobApplicantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobApplicantsScalarFieldEnum | JobApplicantsScalarFieldEnum[]
  }

  /**
   * JobPosting.userProcesses
   */
  export type JobPosting$userProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessInclude<ExtArgs> | null
    where?: UserProcessWhereInput
    orderBy?: UserProcessOrderByWithRelationInput | UserProcessOrderByWithRelationInput[]
    cursor?: UserProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProcessScalarFieldEnum | UserProcessScalarFieldEnum[]
  }

  /**
   * JobPosting without action
   */
  export type JobPostingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
  }


  /**
   * Model JobPostingLanguage
   */

  export type AggregateJobPostingLanguage = {
    _count: JobPostingLanguageCountAggregateOutputType | null
    _min: JobPostingLanguageMinAggregateOutputType | null
    _max: JobPostingLanguageMaxAggregateOutputType | null
  }

  export type JobPostingLanguageMinAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    language: string | null
    level: string | null
  }

  export type JobPostingLanguageMaxAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    language: string | null
    level: string | null
  }

  export type JobPostingLanguageCountAggregateOutputType = {
    id: number
    jobPostingId: number
    language: number
    level: number
    _all: number
  }


  export type JobPostingLanguageMinAggregateInputType = {
    id?: true
    jobPostingId?: true
    language?: true
    level?: true
  }

  export type JobPostingLanguageMaxAggregateInputType = {
    id?: true
    jobPostingId?: true
    language?: true
    level?: true
  }

  export type JobPostingLanguageCountAggregateInputType = {
    id?: true
    jobPostingId?: true
    language?: true
    level?: true
    _all?: true
  }

  export type JobPostingLanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingLanguage to aggregate.
     */
    where?: JobPostingLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingLanguages to fetch.
     */
    orderBy?: JobPostingLanguageOrderByWithRelationInput | JobPostingLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPostingLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPostingLanguages
    **/
    _count?: true | JobPostingLanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostingLanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostingLanguageMaxAggregateInputType
  }

  export type GetJobPostingLanguageAggregateType<T extends JobPostingLanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPostingLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPostingLanguage[P]>
      : GetScalarType<T[P], AggregateJobPostingLanguage[P]>
  }




  export type JobPostingLanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingLanguageWhereInput
    orderBy?: JobPostingLanguageOrderByWithAggregationInput | JobPostingLanguageOrderByWithAggregationInput[]
    by: JobPostingLanguageScalarFieldEnum[] | JobPostingLanguageScalarFieldEnum
    having?: JobPostingLanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostingLanguageCountAggregateInputType | true
    _min?: JobPostingLanguageMinAggregateInputType
    _max?: JobPostingLanguageMaxAggregateInputType
  }

  export type JobPostingLanguageGroupByOutputType = {
    id: string
    jobPostingId: string
    language: string
    level: string | null
    _count: JobPostingLanguageCountAggregateOutputType | null
    _min: JobPostingLanguageMinAggregateOutputType | null
    _max: JobPostingLanguageMaxAggregateOutputType | null
  }

  type GetJobPostingLanguageGroupByPayload<T extends JobPostingLanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPostingLanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostingLanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostingLanguageGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostingLanguageGroupByOutputType[P]>
        }
      >
    >


  export type JobPostingLanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    language?: boolean
    level?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingLanguage"]>

  export type JobPostingLanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    language?: boolean
    level?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingLanguage"]>

  export type JobPostingLanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    language?: boolean
    level?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingLanguage"]>

  export type JobPostingLanguageSelectScalar = {
    id?: boolean
    jobPostingId?: boolean
    language?: boolean
    level?: boolean
  }

  export type JobPostingLanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobPostingId" | "language" | "level", ExtArgs["result"]["jobPostingLanguage"]>
  export type JobPostingLanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingLanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingLanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }

  export type $JobPostingLanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPostingLanguage"
    objects: {
      jobPosting: Prisma.$JobPostingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobPostingId: string
      language: string
      level: string | null
    }, ExtArgs["result"]["jobPostingLanguage"]>
    composites: {}
  }

  type JobPostingLanguageGetPayload<S extends boolean | null | undefined | JobPostingLanguageDefaultArgs> = $Result.GetResult<Prisma.$JobPostingLanguagePayload, S>

  type JobPostingLanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobPostingLanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobPostingLanguageCountAggregateInputType | true
    }

  export interface JobPostingLanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPostingLanguage'], meta: { name: 'JobPostingLanguage' } }
    /**
     * Find zero or one JobPostingLanguage that matches the filter.
     * @param {JobPostingLanguageFindUniqueArgs} args - Arguments to find a JobPostingLanguage
     * @example
     * // Get one JobPostingLanguage
     * const jobPostingLanguage = await prisma.jobPostingLanguage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobPostingLanguageFindUniqueArgs>(args: SelectSubset<T, JobPostingLanguageFindUniqueArgs<ExtArgs>>): Prisma__JobPostingLanguageClient<$Result.GetResult<Prisma.$JobPostingLanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobPostingLanguage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobPostingLanguageFindUniqueOrThrowArgs} args - Arguments to find a JobPostingLanguage
     * @example
     * // Get one JobPostingLanguage
     * const jobPostingLanguage = await prisma.jobPostingLanguage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobPostingLanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, JobPostingLanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobPostingLanguageClient<$Result.GetResult<Prisma.$JobPostingLanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingLanguage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingLanguageFindFirstArgs} args - Arguments to find a JobPostingLanguage
     * @example
     * // Get one JobPostingLanguage
     * const jobPostingLanguage = await prisma.jobPostingLanguage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobPostingLanguageFindFirstArgs>(args?: SelectSubset<T, JobPostingLanguageFindFirstArgs<ExtArgs>>): Prisma__JobPostingLanguageClient<$Result.GetResult<Prisma.$JobPostingLanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingLanguage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingLanguageFindFirstOrThrowArgs} args - Arguments to find a JobPostingLanguage
     * @example
     * // Get one JobPostingLanguage
     * const jobPostingLanguage = await prisma.jobPostingLanguage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobPostingLanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, JobPostingLanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobPostingLanguageClient<$Result.GetResult<Prisma.$JobPostingLanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobPostingLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingLanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPostingLanguages
     * const jobPostingLanguages = await prisma.jobPostingLanguage.findMany()
     * 
     * // Get first 10 JobPostingLanguages
     * const jobPostingLanguages = await prisma.jobPostingLanguage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPostingLanguageWithIdOnly = await prisma.jobPostingLanguage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobPostingLanguageFindManyArgs>(args?: SelectSubset<T, JobPostingLanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobPostingLanguage.
     * @param {JobPostingLanguageCreateArgs} args - Arguments to create a JobPostingLanguage.
     * @example
     * // Create one JobPostingLanguage
     * const JobPostingLanguage = await prisma.jobPostingLanguage.create({
     *   data: {
     *     // ... data to create a JobPostingLanguage
     *   }
     * })
     * 
     */
    create<T extends JobPostingLanguageCreateArgs>(args: SelectSubset<T, JobPostingLanguageCreateArgs<ExtArgs>>): Prisma__JobPostingLanguageClient<$Result.GetResult<Prisma.$JobPostingLanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobPostingLanguages.
     * @param {JobPostingLanguageCreateManyArgs} args - Arguments to create many JobPostingLanguages.
     * @example
     * // Create many JobPostingLanguages
     * const jobPostingLanguage = await prisma.jobPostingLanguage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobPostingLanguageCreateManyArgs>(args?: SelectSubset<T, JobPostingLanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobPostingLanguages and returns the data saved in the database.
     * @param {JobPostingLanguageCreateManyAndReturnArgs} args - Arguments to create many JobPostingLanguages.
     * @example
     * // Create many JobPostingLanguages
     * const jobPostingLanguage = await prisma.jobPostingLanguage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobPostingLanguages and only return the `id`
     * const jobPostingLanguageWithIdOnly = await prisma.jobPostingLanguage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobPostingLanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, JobPostingLanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingLanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobPostingLanguage.
     * @param {JobPostingLanguageDeleteArgs} args - Arguments to delete one JobPostingLanguage.
     * @example
     * // Delete one JobPostingLanguage
     * const JobPostingLanguage = await prisma.jobPostingLanguage.delete({
     *   where: {
     *     // ... filter to delete one JobPostingLanguage
     *   }
     * })
     * 
     */
    delete<T extends JobPostingLanguageDeleteArgs>(args: SelectSubset<T, JobPostingLanguageDeleteArgs<ExtArgs>>): Prisma__JobPostingLanguageClient<$Result.GetResult<Prisma.$JobPostingLanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobPostingLanguage.
     * @param {JobPostingLanguageUpdateArgs} args - Arguments to update one JobPostingLanguage.
     * @example
     * // Update one JobPostingLanguage
     * const jobPostingLanguage = await prisma.jobPostingLanguage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobPostingLanguageUpdateArgs>(args: SelectSubset<T, JobPostingLanguageUpdateArgs<ExtArgs>>): Prisma__JobPostingLanguageClient<$Result.GetResult<Prisma.$JobPostingLanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobPostingLanguages.
     * @param {JobPostingLanguageDeleteManyArgs} args - Arguments to filter JobPostingLanguages to delete.
     * @example
     * // Delete a few JobPostingLanguages
     * const { count } = await prisma.jobPostingLanguage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobPostingLanguageDeleteManyArgs>(args?: SelectSubset<T, JobPostingLanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingLanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPostingLanguages
     * const jobPostingLanguage = await prisma.jobPostingLanguage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobPostingLanguageUpdateManyArgs>(args: SelectSubset<T, JobPostingLanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingLanguages and returns the data updated in the database.
     * @param {JobPostingLanguageUpdateManyAndReturnArgs} args - Arguments to update many JobPostingLanguages.
     * @example
     * // Update many JobPostingLanguages
     * const jobPostingLanguage = await prisma.jobPostingLanguage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobPostingLanguages and only return the `id`
     * const jobPostingLanguageWithIdOnly = await prisma.jobPostingLanguage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobPostingLanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, JobPostingLanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingLanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobPostingLanguage.
     * @param {JobPostingLanguageUpsertArgs} args - Arguments to update or create a JobPostingLanguage.
     * @example
     * // Update or create a JobPostingLanguage
     * const jobPostingLanguage = await prisma.jobPostingLanguage.upsert({
     *   create: {
     *     // ... data to create a JobPostingLanguage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPostingLanguage we want to update
     *   }
     * })
     */
    upsert<T extends JobPostingLanguageUpsertArgs>(args: SelectSubset<T, JobPostingLanguageUpsertArgs<ExtArgs>>): Prisma__JobPostingLanguageClient<$Result.GetResult<Prisma.$JobPostingLanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobPostingLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingLanguageCountArgs} args - Arguments to filter JobPostingLanguages to count.
     * @example
     * // Count the number of JobPostingLanguages
     * const count = await prisma.jobPostingLanguage.count({
     *   where: {
     *     // ... the filter for the JobPostingLanguages we want to count
     *   }
     * })
    **/
    count<T extends JobPostingLanguageCountArgs>(
      args?: Subset<T, JobPostingLanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostingLanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPostingLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingLanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostingLanguageAggregateArgs>(args: Subset<T, JobPostingLanguageAggregateArgs>): Prisma.PrismaPromise<GetJobPostingLanguageAggregateType<T>>

    /**
     * Group by JobPostingLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingLanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostingLanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostingLanguageGroupByArgs['orderBy'] }
        : { orderBy?: JobPostingLanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostingLanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostingLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPostingLanguage model
   */
  readonly fields: JobPostingLanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPostingLanguage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPostingLanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobPosting<T extends JobPostingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostingDefaultArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobPostingLanguage model
   */
  interface JobPostingLanguageFieldRefs {
    readonly id: FieldRef<"JobPostingLanguage", 'String'>
    readonly jobPostingId: FieldRef<"JobPostingLanguage", 'String'>
    readonly language: FieldRef<"JobPostingLanguage", 'String'>
    readonly level: FieldRef<"JobPostingLanguage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobPostingLanguage findUnique
   */
  export type JobPostingLanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLanguage
     */
    select?: JobPostingLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLanguage
     */
    omit?: JobPostingLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLanguageInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingLanguage to fetch.
     */
    where: JobPostingLanguageWhereUniqueInput
  }

  /**
   * JobPostingLanguage findUniqueOrThrow
   */
  export type JobPostingLanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLanguage
     */
    select?: JobPostingLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLanguage
     */
    omit?: JobPostingLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLanguageInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingLanguage to fetch.
     */
    where: JobPostingLanguageWhereUniqueInput
  }

  /**
   * JobPostingLanguage findFirst
   */
  export type JobPostingLanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLanguage
     */
    select?: JobPostingLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLanguage
     */
    omit?: JobPostingLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLanguageInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingLanguage to fetch.
     */
    where?: JobPostingLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingLanguages to fetch.
     */
    orderBy?: JobPostingLanguageOrderByWithRelationInput | JobPostingLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingLanguages.
     */
    cursor?: JobPostingLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingLanguages.
     */
    distinct?: JobPostingLanguageScalarFieldEnum | JobPostingLanguageScalarFieldEnum[]
  }

  /**
   * JobPostingLanguage findFirstOrThrow
   */
  export type JobPostingLanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLanguage
     */
    select?: JobPostingLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLanguage
     */
    omit?: JobPostingLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLanguageInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingLanguage to fetch.
     */
    where?: JobPostingLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingLanguages to fetch.
     */
    orderBy?: JobPostingLanguageOrderByWithRelationInput | JobPostingLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingLanguages.
     */
    cursor?: JobPostingLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingLanguages.
     */
    distinct?: JobPostingLanguageScalarFieldEnum | JobPostingLanguageScalarFieldEnum[]
  }

  /**
   * JobPostingLanguage findMany
   */
  export type JobPostingLanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLanguage
     */
    select?: JobPostingLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLanguage
     */
    omit?: JobPostingLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLanguageInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingLanguages to fetch.
     */
    where?: JobPostingLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingLanguages to fetch.
     */
    orderBy?: JobPostingLanguageOrderByWithRelationInput | JobPostingLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPostingLanguages.
     */
    cursor?: JobPostingLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingLanguages.
     */
    skip?: number
    distinct?: JobPostingLanguageScalarFieldEnum | JobPostingLanguageScalarFieldEnum[]
  }

  /**
   * JobPostingLanguage create
   */
  export type JobPostingLanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLanguage
     */
    select?: JobPostingLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLanguage
     */
    omit?: JobPostingLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPostingLanguage.
     */
    data: XOR<JobPostingLanguageCreateInput, JobPostingLanguageUncheckedCreateInput>
  }

  /**
   * JobPostingLanguage createMany
   */
  export type JobPostingLanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPostingLanguages.
     */
    data: JobPostingLanguageCreateManyInput | JobPostingLanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPostingLanguage createManyAndReturn
   */
  export type JobPostingLanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLanguage
     */
    select?: JobPostingLanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLanguage
     */
    omit?: JobPostingLanguageOmit<ExtArgs> | null
    /**
     * The data used to create many JobPostingLanguages.
     */
    data: JobPostingLanguageCreateManyInput | JobPostingLanguageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLanguageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingLanguage update
   */
  export type JobPostingLanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLanguage
     */
    select?: JobPostingLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLanguage
     */
    omit?: JobPostingLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPostingLanguage.
     */
    data: XOR<JobPostingLanguageUpdateInput, JobPostingLanguageUncheckedUpdateInput>
    /**
     * Choose, which JobPostingLanguage to update.
     */
    where: JobPostingLanguageWhereUniqueInput
  }

  /**
   * JobPostingLanguage updateMany
   */
  export type JobPostingLanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPostingLanguages.
     */
    data: XOR<JobPostingLanguageUpdateManyMutationInput, JobPostingLanguageUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingLanguages to update
     */
    where?: JobPostingLanguageWhereInput
    /**
     * Limit how many JobPostingLanguages to update.
     */
    limit?: number
  }

  /**
   * JobPostingLanguage updateManyAndReturn
   */
  export type JobPostingLanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLanguage
     */
    select?: JobPostingLanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLanguage
     */
    omit?: JobPostingLanguageOmit<ExtArgs> | null
    /**
     * The data used to update JobPostingLanguages.
     */
    data: XOR<JobPostingLanguageUpdateManyMutationInput, JobPostingLanguageUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingLanguages to update
     */
    where?: JobPostingLanguageWhereInput
    /**
     * Limit how many JobPostingLanguages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLanguageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingLanguage upsert
   */
  export type JobPostingLanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLanguage
     */
    select?: JobPostingLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLanguage
     */
    omit?: JobPostingLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPostingLanguage to update in case it exists.
     */
    where: JobPostingLanguageWhereUniqueInput
    /**
     * In case the JobPostingLanguage found by the `where` argument doesn't exist, create a new JobPostingLanguage with this data.
     */
    create: XOR<JobPostingLanguageCreateInput, JobPostingLanguageUncheckedCreateInput>
    /**
     * In case the JobPostingLanguage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPostingLanguageUpdateInput, JobPostingLanguageUncheckedUpdateInput>
  }

  /**
   * JobPostingLanguage delete
   */
  export type JobPostingLanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLanguage
     */
    select?: JobPostingLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLanguage
     */
    omit?: JobPostingLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLanguageInclude<ExtArgs> | null
    /**
     * Filter which JobPostingLanguage to delete.
     */
    where: JobPostingLanguageWhereUniqueInput
  }

  /**
   * JobPostingLanguage deleteMany
   */
  export type JobPostingLanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingLanguages to delete
     */
    where?: JobPostingLanguageWhereInput
    /**
     * Limit how many JobPostingLanguages to delete.
     */
    limit?: number
  }

  /**
   * JobPostingLanguage without action
   */
  export type JobPostingLanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLanguage
     */
    select?: JobPostingLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLanguage
     */
    omit?: JobPostingLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLanguageInclude<ExtArgs> | null
  }


  /**
   * Model JobPostingRequirement
   */

  export type AggregateJobPostingRequirement = {
    _count: JobPostingRequirementCountAggregateOutputType | null
    _min: JobPostingRequirementMinAggregateOutputType | null
    _max: JobPostingRequirementMaxAggregateOutputType | null
  }

  export type JobPostingRequirementMinAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    requirement: string | null
  }

  export type JobPostingRequirementMaxAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    requirement: string | null
  }

  export type JobPostingRequirementCountAggregateOutputType = {
    id: number
    jobPostingId: number
    requirement: number
    _all: number
  }


  export type JobPostingRequirementMinAggregateInputType = {
    id?: true
    jobPostingId?: true
    requirement?: true
  }

  export type JobPostingRequirementMaxAggregateInputType = {
    id?: true
    jobPostingId?: true
    requirement?: true
  }

  export type JobPostingRequirementCountAggregateInputType = {
    id?: true
    jobPostingId?: true
    requirement?: true
    _all?: true
  }

  export type JobPostingRequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingRequirement to aggregate.
     */
    where?: JobPostingRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingRequirements to fetch.
     */
    orderBy?: JobPostingRequirementOrderByWithRelationInput | JobPostingRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPostingRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPostingRequirements
    **/
    _count?: true | JobPostingRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostingRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostingRequirementMaxAggregateInputType
  }

  export type GetJobPostingRequirementAggregateType<T extends JobPostingRequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPostingRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPostingRequirement[P]>
      : GetScalarType<T[P], AggregateJobPostingRequirement[P]>
  }




  export type JobPostingRequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingRequirementWhereInput
    orderBy?: JobPostingRequirementOrderByWithAggregationInput | JobPostingRequirementOrderByWithAggregationInput[]
    by: JobPostingRequirementScalarFieldEnum[] | JobPostingRequirementScalarFieldEnum
    having?: JobPostingRequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostingRequirementCountAggregateInputType | true
    _min?: JobPostingRequirementMinAggregateInputType
    _max?: JobPostingRequirementMaxAggregateInputType
  }

  export type JobPostingRequirementGroupByOutputType = {
    id: string
    jobPostingId: string
    requirement: string
    _count: JobPostingRequirementCountAggregateOutputType | null
    _min: JobPostingRequirementMinAggregateOutputType | null
    _max: JobPostingRequirementMaxAggregateOutputType | null
  }

  type GetJobPostingRequirementGroupByPayload<T extends JobPostingRequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPostingRequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostingRequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostingRequirementGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostingRequirementGroupByOutputType[P]>
        }
      >
    >


  export type JobPostingRequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    requirement?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingRequirement"]>

  export type JobPostingRequirementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    requirement?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingRequirement"]>

  export type JobPostingRequirementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    requirement?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingRequirement"]>

  export type JobPostingRequirementSelectScalar = {
    id?: boolean
    jobPostingId?: boolean
    requirement?: boolean
  }

  export type JobPostingRequirementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobPostingId" | "requirement", ExtArgs["result"]["jobPostingRequirement"]>
  export type JobPostingRequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingRequirementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingRequirementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }

  export type $JobPostingRequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPostingRequirement"
    objects: {
      jobPosting: Prisma.$JobPostingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobPostingId: string
      requirement: string
    }, ExtArgs["result"]["jobPostingRequirement"]>
    composites: {}
  }

  type JobPostingRequirementGetPayload<S extends boolean | null | undefined | JobPostingRequirementDefaultArgs> = $Result.GetResult<Prisma.$JobPostingRequirementPayload, S>

  type JobPostingRequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobPostingRequirementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobPostingRequirementCountAggregateInputType | true
    }

  export interface JobPostingRequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPostingRequirement'], meta: { name: 'JobPostingRequirement' } }
    /**
     * Find zero or one JobPostingRequirement that matches the filter.
     * @param {JobPostingRequirementFindUniqueArgs} args - Arguments to find a JobPostingRequirement
     * @example
     * // Get one JobPostingRequirement
     * const jobPostingRequirement = await prisma.jobPostingRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobPostingRequirementFindUniqueArgs>(args: SelectSubset<T, JobPostingRequirementFindUniqueArgs<ExtArgs>>): Prisma__JobPostingRequirementClient<$Result.GetResult<Prisma.$JobPostingRequirementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobPostingRequirement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobPostingRequirementFindUniqueOrThrowArgs} args - Arguments to find a JobPostingRequirement
     * @example
     * // Get one JobPostingRequirement
     * const jobPostingRequirement = await prisma.jobPostingRequirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobPostingRequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, JobPostingRequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobPostingRequirementClient<$Result.GetResult<Prisma.$JobPostingRequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingRequirementFindFirstArgs} args - Arguments to find a JobPostingRequirement
     * @example
     * // Get one JobPostingRequirement
     * const jobPostingRequirement = await prisma.jobPostingRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobPostingRequirementFindFirstArgs>(args?: SelectSubset<T, JobPostingRequirementFindFirstArgs<ExtArgs>>): Prisma__JobPostingRequirementClient<$Result.GetResult<Prisma.$JobPostingRequirementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingRequirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingRequirementFindFirstOrThrowArgs} args - Arguments to find a JobPostingRequirement
     * @example
     * // Get one JobPostingRequirement
     * const jobPostingRequirement = await prisma.jobPostingRequirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobPostingRequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, JobPostingRequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobPostingRequirementClient<$Result.GetResult<Prisma.$JobPostingRequirementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobPostingRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingRequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPostingRequirements
     * const jobPostingRequirements = await prisma.jobPostingRequirement.findMany()
     * 
     * // Get first 10 JobPostingRequirements
     * const jobPostingRequirements = await prisma.jobPostingRequirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPostingRequirementWithIdOnly = await prisma.jobPostingRequirement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobPostingRequirementFindManyArgs>(args?: SelectSubset<T, JobPostingRequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingRequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobPostingRequirement.
     * @param {JobPostingRequirementCreateArgs} args - Arguments to create a JobPostingRequirement.
     * @example
     * // Create one JobPostingRequirement
     * const JobPostingRequirement = await prisma.jobPostingRequirement.create({
     *   data: {
     *     // ... data to create a JobPostingRequirement
     *   }
     * })
     * 
     */
    create<T extends JobPostingRequirementCreateArgs>(args: SelectSubset<T, JobPostingRequirementCreateArgs<ExtArgs>>): Prisma__JobPostingRequirementClient<$Result.GetResult<Prisma.$JobPostingRequirementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobPostingRequirements.
     * @param {JobPostingRequirementCreateManyArgs} args - Arguments to create many JobPostingRequirements.
     * @example
     * // Create many JobPostingRequirements
     * const jobPostingRequirement = await prisma.jobPostingRequirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobPostingRequirementCreateManyArgs>(args?: SelectSubset<T, JobPostingRequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobPostingRequirements and returns the data saved in the database.
     * @param {JobPostingRequirementCreateManyAndReturnArgs} args - Arguments to create many JobPostingRequirements.
     * @example
     * // Create many JobPostingRequirements
     * const jobPostingRequirement = await prisma.jobPostingRequirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobPostingRequirements and only return the `id`
     * const jobPostingRequirementWithIdOnly = await prisma.jobPostingRequirement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobPostingRequirementCreateManyAndReturnArgs>(args?: SelectSubset<T, JobPostingRequirementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingRequirementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobPostingRequirement.
     * @param {JobPostingRequirementDeleteArgs} args - Arguments to delete one JobPostingRequirement.
     * @example
     * // Delete one JobPostingRequirement
     * const JobPostingRequirement = await prisma.jobPostingRequirement.delete({
     *   where: {
     *     // ... filter to delete one JobPostingRequirement
     *   }
     * })
     * 
     */
    delete<T extends JobPostingRequirementDeleteArgs>(args: SelectSubset<T, JobPostingRequirementDeleteArgs<ExtArgs>>): Prisma__JobPostingRequirementClient<$Result.GetResult<Prisma.$JobPostingRequirementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobPostingRequirement.
     * @param {JobPostingRequirementUpdateArgs} args - Arguments to update one JobPostingRequirement.
     * @example
     * // Update one JobPostingRequirement
     * const jobPostingRequirement = await prisma.jobPostingRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobPostingRequirementUpdateArgs>(args: SelectSubset<T, JobPostingRequirementUpdateArgs<ExtArgs>>): Prisma__JobPostingRequirementClient<$Result.GetResult<Prisma.$JobPostingRequirementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobPostingRequirements.
     * @param {JobPostingRequirementDeleteManyArgs} args - Arguments to filter JobPostingRequirements to delete.
     * @example
     * // Delete a few JobPostingRequirements
     * const { count } = await prisma.jobPostingRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobPostingRequirementDeleteManyArgs>(args?: SelectSubset<T, JobPostingRequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPostingRequirements
     * const jobPostingRequirement = await prisma.jobPostingRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobPostingRequirementUpdateManyArgs>(args: SelectSubset<T, JobPostingRequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingRequirements and returns the data updated in the database.
     * @param {JobPostingRequirementUpdateManyAndReturnArgs} args - Arguments to update many JobPostingRequirements.
     * @example
     * // Update many JobPostingRequirements
     * const jobPostingRequirement = await prisma.jobPostingRequirement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobPostingRequirements and only return the `id`
     * const jobPostingRequirementWithIdOnly = await prisma.jobPostingRequirement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobPostingRequirementUpdateManyAndReturnArgs>(args: SelectSubset<T, JobPostingRequirementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingRequirementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobPostingRequirement.
     * @param {JobPostingRequirementUpsertArgs} args - Arguments to update or create a JobPostingRequirement.
     * @example
     * // Update or create a JobPostingRequirement
     * const jobPostingRequirement = await prisma.jobPostingRequirement.upsert({
     *   create: {
     *     // ... data to create a JobPostingRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPostingRequirement we want to update
     *   }
     * })
     */
    upsert<T extends JobPostingRequirementUpsertArgs>(args: SelectSubset<T, JobPostingRequirementUpsertArgs<ExtArgs>>): Prisma__JobPostingRequirementClient<$Result.GetResult<Prisma.$JobPostingRequirementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobPostingRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingRequirementCountArgs} args - Arguments to filter JobPostingRequirements to count.
     * @example
     * // Count the number of JobPostingRequirements
     * const count = await prisma.jobPostingRequirement.count({
     *   where: {
     *     // ... the filter for the JobPostingRequirements we want to count
     *   }
     * })
    **/
    count<T extends JobPostingRequirementCountArgs>(
      args?: Subset<T, JobPostingRequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostingRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPostingRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostingRequirementAggregateArgs>(args: Subset<T, JobPostingRequirementAggregateArgs>): Prisma.PrismaPromise<GetJobPostingRequirementAggregateType<T>>

    /**
     * Group by JobPostingRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingRequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostingRequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostingRequirementGroupByArgs['orderBy'] }
        : { orderBy?: JobPostingRequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostingRequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostingRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPostingRequirement model
   */
  readonly fields: JobPostingRequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPostingRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPostingRequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobPosting<T extends JobPostingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostingDefaultArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobPostingRequirement model
   */
  interface JobPostingRequirementFieldRefs {
    readonly id: FieldRef<"JobPostingRequirement", 'String'>
    readonly jobPostingId: FieldRef<"JobPostingRequirement", 'String'>
    readonly requirement: FieldRef<"JobPostingRequirement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobPostingRequirement findUnique
   */
  export type JobPostingRequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingRequirement
     */
    select?: JobPostingRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingRequirement
     */
    omit?: JobPostingRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingRequirementInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingRequirement to fetch.
     */
    where: JobPostingRequirementWhereUniqueInput
  }

  /**
   * JobPostingRequirement findUniqueOrThrow
   */
  export type JobPostingRequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingRequirement
     */
    select?: JobPostingRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingRequirement
     */
    omit?: JobPostingRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingRequirementInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingRequirement to fetch.
     */
    where: JobPostingRequirementWhereUniqueInput
  }

  /**
   * JobPostingRequirement findFirst
   */
  export type JobPostingRequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingRequirement
     */
    select?: JobPostingRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingRequirement
     */
    omit?: JobPostingRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingRequirementInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingRequirement to fetch.
     */
    where?: JobPostingRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingRequirements to fetch.
     */
    orderBy?: JobPostingRequirementOrderByWithRelationInput | JobPostingRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingRequirements.
     */
    cursor?: JobPostingRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingRequirements.
     */
    distinct?: JobPostingRequirementScalarFieldEnum | JobPostingRequirementScalarFieldEnum[]
  }

  /**
   * JobPostingRequirement findFirstOrThrow
   */
  export type JobPostingRequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingRequirement
     */
    select?: JobPostingRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingRequirement
     */
    omit?: JobPostingRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingRequirementInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingRequirement to fetch.
     */
    where?: JobPostingRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingRequirements to fetch.
     */
    orderBy?: JobPostingRequirementOrderByWithRelationInput | JobPostingRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingRequirements.
     */
    cursor?: JobPostingRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingRequirements.
     */
    distinct?: JobPostingRequirementScalarFieldEnum | JobPostingRequirementScalarFieldEnum[]
  }

  /**
   * JobPostingRequirement findMany
   */
  export type JobPostingRequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingRequirement
     */
    select?: JobPostingRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingRequirement
     */
    omit?: JobPostingRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingRequirementInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingRequirements to fetch.
     */
    where?: JobPostingRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingRequirements to fetch.
     */
    orderBy?: JobPostingRequirementOrderByWithRelationInput | JobPostingRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPostingRequirements.
     */
    cursor?: JobPostingRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingRequirements.
     */
    skip?: number
    distinct?: JobPostingRequirementScalarFieldEnum | JobPostingRequirementScalarFieldEnum[]
  }

  /**
   * JobPostingRequirement create
   */
  export type JobPostingRequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingRequirement
     */
    select?: JobPostingRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingRequirement
     */
    omit?: JobPostingRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingRequirementInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPostingRequirement.
     */
    data: XOR<JobPostingRequirementCreateInput, JobPostingRequirementUncheckedCreateInput>
  }

  /**
   * JobPostingRequirement createMany
   */
  export type JobPostingRequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPostingRequirements.
     */
    data: JobPostingRequirementCreateManyInput | JobPostingRequirementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPostingRequirement createManyAndReturn
   */
  export type JobPostingRequirementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingRequirement
     */
    select?: JobPostingRequirementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingRequirement
     */
    omit?: JobPostingRequirementOmit<ExtArgs> | null
    /**
     * The data used to create many JobPostingRequirements.
     */
    data: JobPostingRequirementCreateManyInput | JobPostingRequirementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingRequirementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingRequirement update
   */
  export type JobPostingRequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingRequirement
     */
    select?: JobPostingRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingRequirement
     */
    omit?: JobPostingRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingRequirementInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPostingRequirement.
     */
    data: XOR<JobPostingRequirementUpdateInput, JobPostingRequirementUncheckedUpdateInput>
    /**
     * Choose, which JobPostingRequirement to update.
     */
    where: JobPostingRequirementWhereUniqueInput
  }

  /**
   * JobPostingRequirement updateMany
   */
  export type JobPostingRequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPostingRequirements.
     */
    data: XOR<JobPostingRequirementUpdateManyMutationInput, JobPostingRequirementUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingRequirements to update
     */
    where?: JobPostingRequirementWhereInput
    /**
     * Limit how many JobPostingRequirements to update.
     */
    limit?: number
  }

  /**
   * JobPostingRequirement updateManyAndReturn
   */
  export type JobPostingRequirementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingRequirement
     */
    select?: JobPostingRequirementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingRequirement
     */
    omit?: JobPostingRequirementOmit<ExtArgs> | null
    /**
     * The data used to update JobPostingRequirements.
     */
    data: XOR<JobPostingRequirementUpdateManyMutationInput, JobPostingRequirementUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingRequirements to update
     */
    where?: JobPostingRequirementWhereInput
    /**
     * Limit how many JobPostingRequirements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingRequirementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingRequirement upsert
   */
  export type JobPostingRequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingRequirement
     */
    select?: JobPostingRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingRequirement
     */
    omit?: JobPostingRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingRequirementInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPostingRequirement to update in case it exists.
     */
    where: JobPostingRequirementWhereUniqueInput
    /**
     * In case the JobPostingRequirement found by the `where` argument doesn't exist, create a new JobPostingRequirement with this data.
     */
    create: XOR<JobPostingRequirementCreateInput, JobPostingRequirementUncheckedCreateInput>
    /**
     * In case the JobPostingRequirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPostingRequirementUpdateInput, JobPostingRequirementUncheckedUpdateInput>
  }

  /**
   * JobPostingRequirement delete
   */
  export type JobPostingRequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingRequirement
     */
    select?: JobPostingRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingRequirement
     */
    omit?: JobPostingRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingRequirementInclude<ExtArgs> | null
    /**
     * Filter which JobPostingRequirement to delete.
     */
    where: JobPostingRequirementWhereUniqueInput
  }

  /**
   * JobPostingRequirement deleteMany
   */
  export type JobPostingRequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingRequirements to delete
     */
    where?: JobPostingRequirementWhereInput
    /**
     * Limit how many JobPostingRequirements to delete.
     */
    limit?: number
  }

  /**
   * JobPostingRequirement without action
   */
  export type JobPostingRequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingRequirement
     */
    select?: JobPostingRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingRequirement
     */
    omit?: JobPostingRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingRequirementInclude<ExtArgs> | null
  }


  /**
   * Model JobPostingMerit
   */

  export type AggregateJobPostingMerit = {
    _count: JobPostingMeritCountAggregateOutputType | null
    _min: JobPostingMeritMinAggregateOutputType | null
    _max: JobPostingMeritMaxAggregateOutputType | null
  }

  export type JobPostingMeritMinAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    merit: string | null
  }

  export type JobPostingMeritMaxAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    merit: string | null
  }

  export type JobPostingMeritCountAggregateOutputType = {
    id: number
    jobPostingId: number
    merit: number
    _all: number
  }


  export type JobPostingMeritMinAggregateInputType = {
    id?: true
    jobPostingId?: true
    merit?: true
  }

  export type JobPostingMeritMaxAggregateInputType = {
    id?: true
    jobPostingId?: true
    merit?: true
  }

  export type JobPostingMeritCountAggregateInputType = {
    id?: true
    jobPostingId?: true
    merit?: true
    _all?: true
  }

  export type JobPostingMeritAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingMerit to aggregate.
     */
    where?: JobPostingMeritWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingMerits to fetch.
     */
    orderBy?: JobPostingMeritOrderByWithRelationInput | JobPostingMeritOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPostingMeritWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingMerits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingMerits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPostingMerits
    **/
    _count?: true | JobPostingMeritCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostingMeritMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostingMeritMaxAggregateInputType
  }

  export type GetJobPostingMeritAggregateType<T extends JobPostingMeritAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPostingMerit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPostingMerit[P]>
      : GetScalarType<T[P], AggregateJobPostingMerit[P]>
  }




  export type JobPostingMeritGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingMeritWhereInput
    orderBy?: JobPostingMeritOrderByWithAggregationInput | JobPostingMeritOrderByWithAggregationInput[]
    by: JobPostingMeritScalarFieldEnum[] | JobPostingMeritScalarFieldEnum
    having?: JobPostingMeritScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostingMeritCountAggregateInputType | true
    _min?: JobPostingMeritMinAggregateInputType
    _max?: JobPostingMeritMaxAggregateInputType
  }

  export type JobPostingMeritGroupByOutputType = {
    id: string
    jobPostingId: string
    merit: string
    _count: JobPostingMeritCountAggregateOutputType | null
    _min: JobPostingMeritMinAggregateOutputType | null
    _max: JobPostingMeritMaxAggregateOutputType | null
  }

  type GetJobPostingMeritGroupByPayload<T extends JobPostingMeritGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPostingMeritGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostingMeritGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostingMeritGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostingMeritGroupByOutputType[P]>
        }
      >
    >


  export type JobPostingMeritSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    merit?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingMerit"]>

  export type JobPostingMeritSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    merit?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingMerit"]>

  export type JobPostingMeritSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    merit?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingMerit"]>

  export type JobPostingMeritSelectScalar = {
    id?: boolean
    jobPostingId?: boolean
    merit?: boolean
  }

  export type JobPostingMeritOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobPostingId" | "merit", ExtArgs["result"]["jobPostingMerit"]>
  export type JobPostingMeritInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingMeritIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingMeritIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }

  export type $JobPostingMeritPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPostingMerit"
    objects: {
      jobPosting: Prisma.$JobPostingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobPostingId: string
      merit: string
    }, ExtArgs["result"]["jobPostingMerit"]>
    composites: {}
  }

  type JobPostingMeritGetPayload<S extends boolean | null | undefined | JobPostingMeritDefaultArgs> = $Result.GetResult<Prisma.$JobPostingMeritPayload, S>

  type JobPostingMeritCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobPostingMeritFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobPostingMeritCountAggregateInputType | true
    }

  export interface JobPostingMeritDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPostingMerit'], meta: { name: 'JobPostingMerit' } }
    /**
     * Find zero or one JobPostingMerit that matches the filter.
     * @param {JobPostingMeritFindUniqueArgs} args - Arguments to find a JobPostingMerit
     * @example
     * // Get one JobPostingMerit
     * const jobPostingMerit = await prisma.jobPostingMerit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobPostingMeritFindUniqueArgs>(args: SelectSubset<T, JobPostingMeritFindUniqueArgs<ExtArgs>>): Prisma__JobPostingMeritClient<$Result.GetResult<Prisma.$JobPostingMeritPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobPostingMerit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobPostingMeritFindUniqueOrThrowArgs} args - Arguments to find a JobPostingMerit
     * @example
     * // Get one JobPostingMerit
     * const jobPostingMerit = await prisma.jobPostingMerit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobPostingMeritFindUniqueOrThrowArgs>(args: SelectSubset<T, JobPostingMeritFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobPostingMeritClient<$Result.GetResult<Prisma.$JobPostingMeritPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingMerit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingMeritFindFirstArgs} args - Arguments to find a JobPostingMerit
     * @example
     * // Get one JobPostingMerit
     * const jobPostingMerit = await prisma.jobPostingMerit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobPostingMeritFindFirstArgs>(args?: SelectSubset<T, JobPostingMeritFindFirstArgs<ExtArgs>>): Prisma__JobPostingMeritClient<$Result.GetResult<Prisma.$JobPostingMeritPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingMerit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingMeritFindFirstOrThrowArgs} args - Arguments to find a JobPostingMerit
     * @example
     * // Get one JobPostingMerit
     * const jobPostingMerit = await prisma.jobPostingMerit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobPostingMeritFindFirstOrThrowArgs>(args?: SelectSubset<T, JobPostingMeritFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobPostingMeritClient<$Result.GetResult<Prisma.$JobPostingMeritPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobPostingMerits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingMeritFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPostingMerits
     * const jobPostingMerits = await prisma.jobPostingMerit.findMany()
     * 
     * // Get first 10 JobPostingMerits
     * const jobPostingMerits = await prisma.jobPostingMerit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPostingMeritWithIdOnly = await prisma.jobPostingMerit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobPostingMeritFindManyArgs>(args?: SelectSubset<T, JobPostingMeritFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingMeritPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobPostingMerit.
     * @param {JobPostingMeritCreateArgs} args - Arguments to create a JobPostingMerit.
     * @example
     * // Create one JobPostingMerit
     * const JobPostingMerit = await prisma.jobPostingMerit.create({
     *   data: {
     *     // ... data to create a JobPostingMerit
     *   }
     * })
     * 
     */
    create<T extends JobPostingMeritCreateArgs>(args: SelectSubset<T, JobPostingMeritCreateArgs<ExtArgs>>): Prisma__JobPostingMeritClient<$Result.GetResult<Prisma.$JobPostingMeritPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobPostingMerits.
     * @param {JobPostingMeritCreateManyArgs} args - Arguments to create many JobPostingMerits.
     * @example
     * // Create many JobPostingMerits
     * const jobPostingMerit = await prisma.jobPostingMerit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobPostingMeritCreateManyArgs>(args?: SelectSubset<T, JobPostingMeritCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobPostingMerits and returns the data saved in the database.
     * @param {JobPostingMeritCreateManyAndReturnArgs} args - Arguments to create many JobPostingMerits.
     * @example
     * // Create many JobPostingMerits
     * const jobPostingMerit = await prisma.jobPostingMerit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobPostingMerits and only return the `id`
     * const jobPostingMeritWithIdOnly = await prisma.jobPostingMerit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobPostingMeritCreateManyAndReturnArgs>(args?: SelectSubset<T, JobPostingMeritCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingMeritPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobPostingMerit.
     * @param {JobPostingMeritDeleteArgs} args - Arguments to delete one JobPostingMerit.
     * @example
     * // Delete one JobPostingMerit
     * const JobPostingMerit = await prisma.jobPostingMerit.delete({
     *   where: {
     *     // ... filter to delete one JobPostingMerit
     *   }
     * })
     * 
     */
    delete<T extends JobPostingMeritDeleteArgs>(args: SelectSubset<T, JobPostingMeritDeleteArgs<ExtArgs>>): Prisma__JobPostingMeritClient<$Result.GetResult<Prisma.$JobPostingMeritPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobPostingMerit.
     * @param {JobPostingMeritUpdateArgs} args - Arguments to update one JobPostingMerit.
     * @example
     * // Update one JobPostingMerit
     * const jobPostingMerit = await prisma.jobPostingMerit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobPostingMeritUpdateArgs>(args: SelectSubset<T, JobPostingMeritUpdateArgs<ExtArgs>>): Prisma__JobPostingMeritClient<$Result.GetResult<Prisma.$JobPostingMeritPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobPostingMerits.
     * @param {JobPostingMeritDeleteManyArgs} args - Arguments to filter JobPostingMerits to delete.
     * @example
     * // Delete a few JobPostingMerits
     * const { count } = await prisma.jobPostingMerit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobPostingMeritDeleteManyArgs>(args?: SelectSubset<T, JobPostingMeritDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingMerits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingMeritUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPostingMerits
     * const jobPostingMerit = await prisma.jobPostingMerit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobPostingMeritUpdateManyArgs>(args: SelectSubset<T, JobPostingMeritUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingMerits and returns the data updated in the database.
     * @param {JobPostingMeritUpdateManyAndReturnArgs} args - Arguments to update many JobPostingMerits.
     * @example
     * // Update many JobPostingMerits
     * const jobPostingMerit = await prisma.jobPostingMerit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobPostingMerits and only return the `id`
     * const jobPostingMeritWithIdOnly = await prisma.jobPostingMerit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobPostingMeritUpdateManyAndReturnArgs>(args: SelectSubset<T, JobPostingMeritUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingMeritPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobPostingMerit.
     * @param {JobPostingMeritUpsertArgs} args - Arguments to update or create a JobPostingMerit.
     * @example
     * // Update or create a JobPostingMerit
     * const jobPostingMerit = await prisma.jobPostingMerit.upsert({
     *   create: {
     *     // ... data to create a JobPostingMerit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPostingMerit we want to update
     *   }
     * })
     */
    upsert<T extends JobPostingMeritUpsertArgs>(args: SelectSubset<T, JobPostingMeritUpsertArgs<ExtArgs>>): Prisma__JobPostingMeritClient<$Result.GetResult<Prisma.$JobPostingMeritPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobPostingMerits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingMeritCountArgs} args - Arguments to filter JobPostingMerits to count.
     * @example
     * // Count the number of JobPostingMerits
     * const count = await prisma.jobPostingMerit.count({
     *   where: {
     *     // ... the filter for the JobPostingMerits we want to count
     *   }
     * })
    **/
    count<T extends JobPostingMeritCountArgs>(
      args?: Subset<T, JobPostingMeritCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostingMeritCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPostingMerit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingMeritAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostingMeritAggregateArgs>(args: Subset<T, JobPostingMeritAggregateArgs>): Prisma.PrismaPromise<GetJobPostingMeritAggregateType<T>>

    /**
     * Group by JobPostingMerit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingMeritGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostingMeritGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostingMeritGroupByArgs['orderBy'] }
        : { orderBy?: JobPostingMeritGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostingMeritGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostingMeritGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPostingMerit model
   */
  readonly fields: JobPostingMeritFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPostingMerit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPostingMeritClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobPosting<T extends JobPostingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostingDefaultArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobPostingMerit model
   */
  interface JobPostingMeritFieldRefs {
    readonly id: FieldRef<"JobPostingMerit", 'String'>
    readonly jobPostingId: FieldRef<"JobPostingMerit", 'String'>
    readonly merit: FieldRef<"JobPostingMerit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobPostingMerit findUnique
   */
  export type JobPostingMeritFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingMerit
     */
    select?: JobPostingMeritSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingMerit
     */
    omit?: JobPostingMeritOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingMeritInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingMerit to fetch.
     */
    where: JobPostingMeritWhereUniqueInput
  }

  /**
   * JobPostingMerit findUniqueOrThrow
   */
  export type JobPostingMeritFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingMerit
     */
    select?: JobPostingMeritSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingMerit
     */
    omit?: JobPostingMeritOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingMeritInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingMerit to fetch.
     */
    where: JobPostingMeritWhereUniqueInput
  }

  /**
   * JobPostingMerit findFirst
   */
  export type JobPostingMeritFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingMerit
     */
    select?: JobPostingMeritSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingMerit
     */
    omit?: JobPostingMeritOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingMeritInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingMerit to fetch.
     */
    where?: JobPostingMeritWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingMerits to fetch.
     */
    orderBy?: JobPostingMeritOrderByWithRelationInput | JobPostingMeritOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingMerits.
     */
    cursor?: JobPostingMeritWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingMerits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingMerits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingMerits.
     */
    distinct?: JobPostingMeritScalarFieldEnum | JobPostingMeritScalarFieldEnum[]
  }

  /**
   * JobPostingMerit findFirstOrThrow
   */
  export type JobPostingMeritFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingMerit
     */
    select?: JobPostingMeritSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingMerit
     */
    omit?: JobPostingMeritOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingMeritInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingMerit to fetch.
     */
    where?: JobPostingMeritWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingMerits to fetch.
     */
    orderBy?: JobPostingMeritOrderByWithRelationInput | JobPostingMeritOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingMerits.
     */
    cursor?: JobPostingMeritWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingMerits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingMerits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingMerits.
     */
    distinct?: JobPostingMeritScalarFieldEnum | JobPostingMeritScalarFieldEnum[]
  }

  /**
   * JobPostingMerit findMany
   */
  export type JobPostingMeritFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingMerit
     */
    select?: JobPostingMeritSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingMerit
     */
    omit?: JobPostingMeritOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingMeritInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingMerits to fetch.
     */
    where?: JobPostingMeritWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingMerits to fetch.
     */
    orderBy?: JobPostingMeritOrderByWithRelationInput | JobPostingMeritOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPostingMerits.
     */
    cursor?: JobPostingMeritWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingMerits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingMerits.
     */
    skip?: number
    distinct?: JobPostingMeritScalarFieldEnum | JobPostingMeritScalarFieldEnum[]
  }

  /**
   * JobPostingMerit create
   */
  export type JobPostingMeritCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingMerit
     */
    select?: JobPostingMeritSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingMerit
     */
    omit?: JobPostingMeritOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingMeritInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPostingMerit.
     */
    data: XOR<JobPostingMeritCreateInput, JobPostingMeritUncheckedCreateInput>
  }

  /**
   * JobPostingMerit createMany
   */
  export type JobPostingMeritCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPostingMerits.
     */
    data: JobPostingMeritCreateManyInput | JobPostingMeritCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPostingMerit createManyAndReturn
   */
  export type JobPostingMeritCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingMerit
     */
    select?: JobPostingMeritSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingMerit
     */
    omit?: JobPostingMeritOmit<ExtArgs> | null
    /**
     * The data used to create many JobPostingMerits.
     */
    data: JobPostingMeritCreateManyInput | JobPostingMeritCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingMeritIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingMerit update
   */
  export type JobPostingMeritUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingMerit
     */
    select?: JobPostingMeritSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingMerit
     */
    omit?: JobPostingMeritOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingMeritInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPostingMerit.
     */
    data: XOR<JobPostingMeritUpdateInput, JobPostingMeritUncheckedUpdateInput>
    /**
     * Choose, which JobPostingMerit to update.
     */
    where: JobPostingMeritWhereUniqueInput
  }

  /**
   * JobPostingMerit updateMany
   */
  export type JobPostingMeritUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPostingMerits.
     */
    data: XOR<JobPostingMeritUpdateManyMutationInput, JobPostingMeritUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingMerits to update
     */
    where?: JobPostingMeritWhereInput
    /**
     * Limit how many JobPostingMerits to update.
     */
    limit?: number
  }

  /**
   * JobPostingMerit updateManyAndReturn
   */
  export type JobPostingMeritUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingMerit
     */
    select?: JobPostingMeritSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingMerit
     */
    omit?: JobPostingMeritOmit<ExtArgs> | null
    /**
     * The data used to update JobPostingMerits.
     */
    data: XOR<JobPostingMeritUpdateManyMutationInput, JobPostingMeritUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingMerits to update
     */
    where?: JobPostingMeritWhereInput
    /**
     * Limit how many JobPostingMerits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingMeritIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingMerit upsert
   */
  export type JobPostingMeritUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingMerit
     */
    select?: JobPostingMeritSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingMerit
     */
    omit?: JobPostingMeritOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingMeritInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPostingMerit to update in case it exists.
     */
    where: JobPostingMeritWhereUniqueInput
    /**
     * In case the JobPostingMerit found by the `where` argument doesn't exist, create a new JobPostingMerit with this data.
     */
    create: XOR<JobPostingMeritCreateInput, JobPostingMeritUncheckedCreateInput>
    /**
     * In case the JobPostingMerit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPostingMeritUpdateInput, JobPostingMeritUncheckedUpdateInput>
  }

  /**
   * JobPostingMerit delete
   */
  export type JobPostingMeritDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingMerit
     */
    select?: JobPostingMeritSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingMerit
     */
    omit?: JobPostingMeritOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingMeritInclude<ExtArgs> | null
    /**
     * Filter which JobPostingMerit to delete.
     */
    where: JobPostingMeritWhereUniqueInput
  }

  /**
   * JobPostingMerit deleteMany
   */
  export type JobPostingMeritDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingMerits to delete
     */
    where?: JobPostingMeritWhereInput
    /**
     * Limit how many JobPostingMerits to delete.
     */
    limit?: number
  }

  /**
   * JobPostingMerit without action
   */
  export type JobPostingMeritDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingMerit
     */
    select?: JobPostingMeritSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingMerit
     */
    omit?: JobPostingMeritOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingMeritInclude<ExtArgs> | null
  }


  /**
   * Model JobPostingApplicantQuality
   */

  export type AggregateJobPostingApplicantQuality = {
    _count: JobPostingApplicantQualityCountAggregateOutputType | null
    _min: JobPostingApplicantQualityMinAggregateOutputType | null
    _max: JobPostingApplicantQualityMaxAggregateOutputType | null
  }

  export type JobPostingApplicantQualityMinAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    quality: string | null
  }

  export type JobPostingApplicantQualityMaxAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    quality: string | null
  }

  export type JobPostingApplicantQualityCountAggregateOutputType = {
    id: number
    jobPostingId: number
    quality: number
    _all: number
  }


  export type JobPostingApplicantQualityMinAggregateInputType = {
    id?: true
    jobPostingId?: true
    quality?: true
  }

  export type JobPostingApplicantQualityMaxAggregateInputType = {
    id?: true
    jobPostingId?: true
    quality?: true
  }

  export type JobPostingApplicantQualityCountAggregateInputType = {
    id?: true
    jobPostingId?: true
    quality?: true
    _all?: true
  }

  export type JobPostingApplicantQualityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingApplicantQuality to aggregate.
     */
    where?: JobPostingApplicantQualityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingApplicantQualities to fetch.
     */
    orderBy?: JobPostingApplicantQualityOrderByWithRelationInput | JobPostingApplicantQualityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPostingApplicantQualityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingApplicantQualities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingApplicantQualities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPostingApplicantQualities
    **/
    _count?: true | JobPostingApplicantQualityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostingApplicantQualityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostingApplicantQualityMaxAggregateInputType
  }

  export type GetJobPostingApplicantQualityAggregateType<T extends JobPostingApplicantQualityAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPostingApplicantQuality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPostingApplicantQuality[P]>
      : GetScalarType<T[P], AggregateJobPostingApplicantQuality[P]>
  }




  export type JobPostingApplicantQualityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingApplicantQualityWhereInput
    orderBy?: JobPostingApplicantQualityOrderByWithAggregationInput | JobPostingApplicantQualityOrderByWithAggregationInput[]
    by: JobPostingApplicantQualityScalarFieldEnum[] | JobPostingApplicantQualityScalarFieldEnum
    having?: JobPostingApplicantQualityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostingApplicantQualityCountAggregateInputType | true
    _min?: JobPostingApplicantQualityMinAggregateInputType
    _max?: JobPostingApplicantQualityMaxAggregateInputType
  }

  export type JobPostingApplicantQualityGroupByOutputType = {
    id: string
    jobPostingId: string
    quality: string
    _count: JobPostingApplicantQualityCountAggregateOutputType | null
    _min: JobPostingApplicantQualityMinAggregateOutputType | null
    _max: JobPostingApplicantQualityMaxAggregateOutputType | null
  }

  type GetJobPostingApplicantQualityGroupByPayload<T extends JobPostingApplicantQualityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPostingApplicantQualityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostingApplicantQualityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostingApplicantQualityGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostingApplicantQualityGroupByOutputType[P]>
        }
      >
    >


  export type JobPostingApplicantQualitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    quality?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingApplicantQuality"]>

  export type JobPostingApplicantQualitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    quality?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingApplicantQuality"]>

  export type JobPostingApplicantQualitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    quality?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingApplicantQuality"]>

  export type JobPostingApplicantQualitySelectScalar = {
    id?: boolean
    jobPostingId?: boolean
    quality?: boolean
  }

  export type JobPostingApplicantQualityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobPostingId" | "quality", ExtArgs["result"]["jobPostingApplicantQuality"]>
  export type JobPostingApplicantQualityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingApplicantQualityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingApplicantQualityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }

  export type $JobPostingApplicantQualityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPostingApplicantQuality"
    objects: {
      jobPosting: Prisma.$JobPostingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobPostingId: string
      quality: string
    }, ExtArgs["result"]["jobPostingApplicantQuality"]>
    composites: {}
  }

  type JobPostingApplicantQualityGetPayload<S extends boolean | null | undefined | JobPostingApplicantQualityDefaultArgs> = $Result.GetResult<Prisma.$JobPostingApplicantQualityPayload, S>

  type JobPostingApplicantQualityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobPostingApplicantQualityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobPostingApplicantQualityCountAggregateInputType | true
    }

  export interface JobPostingApplicantQualityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPostingApplicantQuality'], meta: { name: 'JobPostingApplicantQuality' } }
    /**
     * Find zero or one JobPostingApplicantQuality that matches the filter.
     * @param {JobPostingApplicantQualityFindUniqueArgs} args - Arguments to find a JobPostingApplicantQuality
     * @example
     * // Get one JobPostingApplicantQuality
     * const jobPostingApplicantQuality = await prisma.jobPostingApplicantQuality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobPostingApplicantQualityFindUniqueArgs>(args: SelectSubset<T, JobPostingApplicantQualityFindUniqueArgs<ExtArgs>>): Prisma__JobPostingApplicantQualityClient<$Result.GetResult<Prisma.$JobPostingApplicantQualityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobPostingApplicantQuality that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobPostingApplicantQualityFindUniqueOrThrowArgs} args - Arguments to find a JobPostingApplicantQuality
     * @example
     * // Get one JobPostingApplicantQuality
     * const jobPostingApplicantQuality = await prisma.jobPostingApplicantQuality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobPostingApplicantQualityFindUniqueOrThrowArgs>(args: SelectSubset<T, JobPostingApplicantQualityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobPostingApplicantQualityClient<$Result.GetResult<Prisma.$JobPostingApplicantQualityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingApplicantQuality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingApplicantQualityFindFirstArgs} args - Arguments to find a JobPostingApplicantQuality
     * @example
     * // Get one JobPostingApplicantQuality
     * const jobPostingApplicantQuality = await prisma.jobPostingApplicantQuality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobPostingApplicantQualityFindFirstArgs>(args?: SelectSubset<T, JobPostingApplicantQualityFindFirstArgs<ExtArgs>>): Prisma__JobPostingApplicantQualityClient<$Result.GetResult<Prisma.$JobPostingApplicantQualityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingApplicantQuality that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingApplicantQualityFindFirstOrThrowArgs} args - Arguments to find a JobPostingApplicantQuality
     * @example
     * // Get one JobPostingApplicantQuality
     * const jobPostingApplicantQuality = await prisma.jobPostingApplicantQuality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobPostingApplicantQualityFindFirstOrThrowArgs>(args?: SelectSubset<T, JobPostingApplicantQualityFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobPostingApplicantQualityClient<$Result.GetResult<Prisma.$JobPostingApplicantQualityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobPostingApplicantQualities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingApplicantQualityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPostingApplicantQualities
     * const jobPostingApplicantQualities = await prisma.jobPostingApplicantQuality.findMany()
     * 
     * // Get first 10 JobPostingApplicantQualities
     * const jobPostingApplicantQualities = await prisma.jobPostingApplicantQuality.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPostingApplicantQualityWithIdOnly = await prisma.jobPostingApplicantQuality.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobPostingApplicantQualityFindManyArgs>(args?: SelectSubset<T, JobPostingApplicantQualityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingApplicantQualityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobPostingApplicantQuality.
     * @param {JobPostingApplicantQualityCreateArgs} args - Arguments to create a JobPostingApplicantQuality.
     * @example
     * // Create one JobPostingApplicantQuality
     * const JobPostingApplicantQuality = await prisma.jobPostingApplicantQuality.create({
     *   data: {
     *     // ... data to create a JobPostingApplicantQuality
     *   }
     * })
     * 
     */
    create<T extends JobPostingApplicantQualityCreateArgs>(args: SelectSubset<T, JobPostingApplicantQualityCreateArgs<ExtArgs>>): Prisma__JobPostingApplicantQualityClient<$Result.GetResult<Prisma.$JobPostingApplicantQualityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobPostingApplicantQualities.
     * @param {JobPostingApplicantQualityCreateManyArgs} args - Arguments to create many JobPostingApplicantQualities.
     * @example
     * // Create many JobPostingApplicantQualities
     * const jobPostingApplicantQuality = await prisma.jobPostingApplicantQuality.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobPostingApplicantQualityCreateManyArgs>(args?: SelectSubset<T, JobPostingApplicantQualityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobPostingApplicantQualities and returns the data saved in the database.
     * @param {JobPostingApplicantQualityCreateManyAndReturnArgs} args - Arguments to create many JobPostingApplicantQualities.
     * @example
     * // Create many JobPostingApplicantQualities
     * const jobPostingApplicantQuality = await prisma.jobPostingApplicantQuality.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobPostingApplicantQualities and only return the `id`
     * const jobPostingApplicantQualityWithIdOnly = await prisma.jobPostingApplicantQuality.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobPostingApplicantQualityCreateManyAndReturnArgs>(args?: SelectSubset<T, JobPostingApplicantQualityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingApplicantQualityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobPostingApplicantQuality.
     * @param {JobPostingApplicantQualityDeleteArgs} args - Arguments to delete one JobPostingApplicantQuality.
     * @example
     * // Delete one JobPostingApplicantQuality
     * const JobPostingApplicantQuality = await prisma.jobPostingApplicantQuality.delete({
     *   where: {
     *     // ... filter to delete one JobPostingApplicantQuality
     *   }
     * })
     * 
     */
    delete<T extends JobPostingApplicantQualityDeleteArgs>(args: SelectSubset<T, JobPostingApplicantQualityDeleteArgs<ExtArgs>>): Prisma__JobPostingApplicantQualityClient<$Result.GetResult<Prisma.$JobPostingApplicantQualityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobPostingApplicantQuality.
     * @param {JobPostingApplicantQualityUpdateArgs} args - Arguments to update one JobPostingApplicantQuality.
     * @example
     * // Update one JobPostingApplicantQuality
     * const jobPostingApplicantQuality = await prisma.jobPostingApplicantQuality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobPostingApplicantQualityUpdateArgs>(args: SelectSubset<T, JobPostingApplicantQualityUpdateArgs<ExtArgs>>): Prisma__JobPostingApplicantQualityClient<$Result.GetResult<Prisma.$JobPostingApplicantQualityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobPostingApplicantQualities.
     * @param {JobPostingApplicantQualityDeleteManyArgs} args - Arguments to filter JobPostingApplicantQualities to delete.
     * @example
     * // Delete a few JobPostingApplicantQualities
     * const { count } = await prisma.jobPostingApplicantQuality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobPostingApplicantQualityDeleteManyArgs>(args?: SelectSubset<T, JobPostingApplicantQualityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingApplicantQualities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingApplicantQualityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPostingApplicantQualities
     * const jobPostingApplicantQuality = await prisma.jobPostingApplicantQuality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobPostingApplicantQualityUpdateManyArgs>(args: SelectSubset<T, JobPostingApplicantQualityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingApplicantQualities and returns the data updated in the database.
     * @param {JobPostingApplicantQualityUpdateManyAndReturnArgs} args - Arguments to update many JobPostingApplicantQualities.
     * @example
     * // Update many JobPostingApplicantQualities
     * const jobPostingApplicantQuality = await prisma.jobPostingApplicantQuality.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobPostingApplicantQualities and only return the `id`
     * const jobPostingApplicantQualityWithIdOnly = await prisma.jobPostingApplicantQuality.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobPostingApplicantQualityUpdateManyAndReturnArgs>(args: SelectSubset<T, JobPostingApplicantQualityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingApplicantQualityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobPostingApplicantQuality.
     * @param {JobPostingApplicantQualityUpsertArgs} args - Arguments to update or create a JobPostingApplicantQuality.
     * @example
     * // Update or create a JobPostingApplicantQuality
     * const jobPostingApplicantQuality = await prisma.jobPostingApplicantQuality.upsert({
     *   create: {
     *     // ... data to create a JobPostingApplicantQuality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPostingApplicantQuality we want to update
     *   }
     * })
     */
    upsert<T extends JobPostingApplicantQualityUpsertArgs>(args: SelectSubset<T, JobPostingApplicantQualityUpsertArgs<ExtArgs>>): Prisma__JobPostingApplicantQualityClient<$Result.GetResult<Prisma.$JobPostingApplicantQualityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobPostingApplicantQualities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingApplicantQualityCountArgs} args - Arguments to filter JobPostingApplicantQualities to count.
     * @example
     * // Count the number of JobPostingApplicantQualities
     * const count = await prisma.jobPostingApplicantQuality.count({
     *   where: {
     *     // ... the filter for the JobPostingApplicantQualities we want to count
     *   }
     * })
    **/
    count<T extends JobPostingApplicantQualityCountArgs>(
      args?: Subset<T, JobPostingApplicantQualityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostingApplicantQualityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPostingApplicantQuality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingApplicantQualityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostingApplicantQualityAggregateArgs>(args: Subset<T, JobPostingApplicantQualityAggregateArgs>): Prisma.PrismaPromise<GetJobPostingApplicantQualityAggregateType<T>>

    /**
     * Group by JobPostingApplicantQuality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingApplicantQualityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostingApplicantQualityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostingApplicantQualityGroupByArgs['orderBy'] }
        : { orderBy?: JobPostingApplicantQualityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostingApplicantQualityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostingApplicantQualityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPostingApplicantQuality model
   */
  readonly fields: JobPostingApplicantQualityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPostingApplicantQuality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPostingApplicantQualityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobPosting<T extends JobPostingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostingDefaultArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobPostingApplicantQuality model
   */
  interface JobPostingApplicantQualityFieldRefs {
    readonly id: FieldRef<"JobPostingApplicantQuality", 'String'>
    readonly jobPostingId: FieldRef<"JobPostingApplicantQuality", 'String'>
    readonly quality: FieldRef<"JobPostingApplicantQuality", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobPostingApplicantQuality findUnique
   */
  export type JobPostingApplicantQualityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingApplicantQuality
     */
    select?: JobPostingApplicantQualitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingApplicantQuality
     */
    omit?: JobPostingApplicantQualityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingApplicantQualityInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingApplicantQuality to fetch.
     */
    where: JobPostingApplicantQualityWhereUniqueInput
  }

  /**
   * JobPostingApplicantQuality findUniqueOrThrow
   */
  export type JobPostingApplicantQualityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingApplicantQuality
     */
    select?: JobPostingApplicantQualitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingApplicantQuality
     */
    omit?: JobPostingApplicantQualityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingApplicantQualityInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingApplicantQuality to fetch.
     */
    where: JobPostingApplicantQualityWhereUniqueInput
  }

  /**
   * JobPostingApplicantQuality findFirst
   */
  export type JobPostingApplicantQualityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingApplicantQuality
     */
    select?: JobPostingApplicantQualitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingApplicantQuality
     */
    omit?: JobPostingApplicantQualityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingApplicantQualityInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingApplicantQuality to fetch.
     */
    where?: JobPostingApplicantQualityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingApplicantQualities to fetch.
     */
    orderBy?: JobPostingApplicantQualityOrderByWithRelationInput | JobPostingApplicantQualityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingApplicantQualities.
     */
    cursor?: JobPostingApplicantQualityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingApplicantQualities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingApplicantQualities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingApplicantQualities.
     */
    distinct?: JobPostingApplicantQualityScalarFieldEnum | JobPostingApplicantQualityScalarFieldEnum[]
  }

  /**
   * JobPostingApplicantQuality findFirstOrThrow
   */
  export type JobPostingApplicantQualityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingApplicantQuality
     */
    select?: JobPostingApplicantQualitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingApplicantQuality
     */
    omit?: JobPostingApplicantQualityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingApplicantQualityInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingApplicantQuality to fetch.
     */
    where?: JobPostingApplicantQualityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingApplicantQualities to fetch.
     */
    orderBy?: JobPostingApplicantQualityOrderByWithRelationInput | JobPostingApplicantQualityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingApplicantQualities.
     */
    cursor?: JobPostingApplicantQualityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingApplicantQualities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingApplicantQualities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingApplicantQualities.
     */
    distinct?: JobPostingApplicantQualityScalarFieldEnum | JobPostingApplicantQualityScalarFieldEnum[]
  }

  /**
   * JobPostingApplicantQuality findMany
   */
  export type JobPostingApplicantQualityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingApplicantQuality
     */
    select?: JobPostingApplicantQualitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingApplicantQuality
     */
    omit?: JobPostingApplicantQualityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingApplicantQualityInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingApplicantQualities to fetch.
     */
    where?: JobPostingApplicantQualityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingApplicantQualities to fetch.
     */
    orderBy?: JobPostingApplicantQualityOrderByWithRelationInput | JobPostingApplicantQualityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPostingApplicantQualities.
     */
    cursor?: JobPostingApplicantQualityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingApplicantQualities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingApplicantQualities.
     */
    skip?: number
    distinct?: JobPostingApplicantQualityScalarFieldEnum | JobPostingApplicantQualityScalarFieldEnum[]
  }

  /**
   * JobPostingApplicantQuality create
   */
  export type JobPostingApplicantQualityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingApplicantQuality
     */
    select?: JobPostingApplicantQualitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingApplicantQuality
     */
    omit?: JobPostingApplicantQualityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingApplicantQualityInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPostingApplicantQuality.
     */
    data: XOR<JobPostingApplicantQualityCreateInput, JobPostingApplicantQualityUncheckedCreateInput>
  }

  /**
   * JobPostingApplicantQuality createMany
   */
  export type JobPostingApplicantQualityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPostingApplicantQualities.
     */
    data: JobPostingApplicantQualityCreateManyInput | JobPostingApplicantQualityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPostingApplicantQuality createManyAndReturn
   */
  export type JobPostingApplicantQualityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingApplicantQuality
     */
    select?: JobPostingApplicantQualitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingApplicantQuality
     */
    omit?: JobPostingApplicantQualityOmit<ExtArgs> | null
    /**
     * The data used to create many JobPostingApplicantQualities.
     */
    data: JobPostingApplicantQualityCreateManyInput | JobPostingApplicantQualityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingApplicantQualityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingApplicantQuality update
   */
  export type JobPostingApplicantQualityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingApplicantQuality
     */
    select?: JobPostingApplicantQualitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingApplicantQuality
     */
    omit?: JobPostingApplicantQualityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingApplicantQualityInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPostingApplicantQuality.
     */
    data: XOR<JobPostingApplicantQualityUpdateInput, JobPostingApplicantQualityUncheckedUpdateInput>
    /**
     * Choose, which JobPostingApplicantQuality to update.
     */
    where: JobPostingApplicantQualityWhereUniqueInput
  }

  /**
   * JobPostingApplicantQuality updateMany
   */
  export type JobPostingApplicantQualityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPostingApplicantQualities.
     */
    data: XOR<JobPostingApplicantQualityUpdateManyMutationInput, JobPostingApplicantQualityUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingApplicantQualities to update
     */
    where?: JobPostingApplicantQualityWhereInput
    /**
     * Limit how many JobPostingApplicantQualities to update.
     */
    limit?: number
  }

  /**
   * JobPostingApplicantQuality updateManyAndReturn
   */
  export type JobPostingApplicantQualityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingApplicantQuality
     */
    select?: JobPostingApplicantQualitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingApplicantQuality
     */
    omit?: JobPostingApplicantQualityOmit<ExtArgs> | null
    /**
     * The data used to update JobPostingApplicantQualities.
     */
    data: XOR<JobPostingApplicantQualityUpdateManyMutationInput, JobPostingApplicantQualityUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingApplicantQualities to update
     */
    where?: JobPostingApplicantQualityWhereInput
    /**
     * Limit how many JobPostingApplicantQualities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingApplicantQualityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingApplicantQuality upsert
   */
  export type JobPostingApplicantQualityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingApplicantQuality
     */
    select?: JobPostingApplicantQualitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingApplicantQuality
     */
    omit?: JobPostingApplicantQualityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingApplicantQualityInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPostingApplicantQuality to update in case it exists.
     */
    where: JobPostingApplicantQualityWhereUniqueInput
    /**
     * In case the JobPostingApplicantQuality found by the `where` argument doesn't exist, create a new JobPostingApplicantQuality with this data.
     */
    create: XOR<JobPostingApplicantQualityCreateInput, JobPostingApplicantQualityUncheckedCreateInput>
    /**
     * In case the JobPostingApplicantQuality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPostingApplicantQualityUpdateInput, JobPostingApplicantQualityUncheckedUpdateInput>
  }

  /**
   * JobPostingApplicantQuality delete
   */
  export type JobPostingApplicantQualityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingApplicantQuality
     */
    select?: JobPostingApplicantQualitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingApplicantQuality
     */
    omit?: JobPostingApplicantQualityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingApplicantQualityInclude<ExtArgs> | null
    /**
     * Filter which JobPostingApplicantQuality to delete.
     */
    where: JobPostingApplicantQualityWhereUniqueInput
  }

  /**
   * JobPostingApplicantQuality deleteMany
   */
  export type JobPostingApplicantQualityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingApplicantQualities to delete
     */
    where?: JobPostingApplicantQualityWhereInput
    /**
     * Limit how many JobPostingApplicantQualities to delete.
     */
    limit?: number
  }

  /**
   * JobPostingApplicantQuality without action
   */
  export type JobPostingApplicantQualityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingApplicantQuality
     */
    select?: JobPostingApplicantQualitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingApplicantQuality
     */
    omit?: JobPostingApplicantQualityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingApplicantQualityInclude<ExtArgs> | null
  }


  /**
   * Model JobPostingLocation
   */

  export type AggregateJobPostingLocation = {
    _count: JobPostingLocationCountAggregateOutputType | null
    _avg: JobPostingLocationAvgAggregateOutputType | null
    _sum: JobPostingLocationSumAggregateOutputType | null
    _min: JobPostingLocationMinAggregateOutputType | null
    _max: JobPostingLocationMaxAggregateOutputType | null
  }

  export type JobPostingLocationAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type JobPostingLocationSumAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type JobPostingLocationMinAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    city: string | null
    region: string | null
    country: string | null
    isRemote: boolean | null
    lat: number | null
    lng: number | null
  }

  export type JobPostingLocationMaxAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    city: string | null
    region: string | null
    country: string | null
    isRemote: boolean | null
    lat: number | null
    lng: number | null
  }

  export type JobPostingLocationCountAggregateOutputType = {
    id: number
    jobPostingId: number
    city: number
    region: number
    country: number
    isRemote: number
    lat: number
    lng: number
    _all: number
  }


  export type JobPostingLocationAvgAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type JobPostingLocationSumAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type JobPostingLocationMinAggregateInputType = {
    id?: true
    jobPostingId?: true
    city?: true
    region?: true
    country?: true
    isRemote?: true
    lat?: true
    lng?: true
  }

  export type JobPostingLocationMaxAggregateInputType = {
    id?: true
    jobPostingId?: true
    city?: true
    region?: true
    country?: true
    isRemote?: true
    lat?: true
    lng?: true
  }

  export type JobPostingLocationCountAggregateInputType = {
    id?: true
    jobPostingId?: true
    city?: true
    region?: true
    country?: true
    isRemote?: true
    lat?: true
    lng?: true
    _all?: true
  }

  export type JobPostingLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingLocation to aggregate.
     */
    where?: JobPostingLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingLocations to fetch.
     */
    orderBy?: JobPostingLocationOrderByWithRelationInput | JobPostingLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPostingLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPostingLocations
    **/
    _count?: true | JobPostingLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobPostingLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobPostingLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostingLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostingLocationMaxAggregateInputType
  }

  export type GetJobPostingLocationAggregateType<T extends JobPostingLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPostingLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPostingLocation[P]>
      : GetScalarType<T[P], AggregateJobPostingLocation[P]>
  }




  export type JobPostingLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingLocationWhereInput
    orderBy?: JobPostingLocationOrderByWithAggregationInput | JobPostingLocationOrderByWithAggregationInput[]
    by: JobPostingLocationScalarFieldEnum[] | JobPostingLocationScalarFieldEnum
    having?: JobPostingLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostingLocationCountAggregateInputType | true
    _avg?: JobPostingLocationAvgAggregateInputType
    _sum?: JobPostingLocationSumAggregateInputType
    _min?: JobPostingLocationMinAggregateInputType
    _max?: JobPostingLocationMaxAggregateInputType
  }

  export type JobPostingLocationGroupByOutputType = {
    id: string
    jobPostingId: string
    city: string | null
    region: string | null
    country: string
    isRemote: boolean
    lat: number | null
    lng: number | null
    _count: JobPostingLocationCountAggregateOutputType | null
    _avg: JobPostingLocationAvgAggregateOutputType | null
    _sum: JobPostingLocationSumAggregateOutputType | null
    _min: JobPostingLocationMinAggregateOutputType | null
    _max: JobPostingLocationMaxAggregateOutputType | null
  }

  type GetJobPostingLocationGroupByPayload<T extends JobPostingLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPostingLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostingLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostingLocationGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostingLocationGroupByOutputType[P]>
        }
      >
    >


  export type JobPostingLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    isRemote?: boolean
    lat?: boolean
    lng?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingLocation"]>

  export type JobPostingLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    isRemote?: boolean
    lat?: boolean
    lng?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingLocation"]>

  export type JobPostingLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    isRemote?: boolean
    lat?: boolean
    lng?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingLocation"]>

  export type JobPostingLocationSelectScalar = {
    id?: boolean
    jobPostingId?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    isRemote?: boolean
    lat?: boolean
    lng?: boolean
  }

  export type JobPostingLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobPostingId" | "city" | "region" | "country" | "isRemote" | "lat" | "lng", ExtArgs["result"]["jobPostingLocation"]>
  export type JobPostingLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }

  export type $JobPostingLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPostingLocation"
    objects: {
      jobPosting: Prisma.$JobPostingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobPostingId: string
      city: string | null
      region: string | null
      country: string
      isRemote: boolean
      lat: number | null
      lng: number | null
    }, ExtArgs["result"]["jobPostingLocation"]>
    composites: {}
  }

  type JobPostingLocationGetPayload<S extends boolean | null | undefined | JobPostingLocationDefaultArgs> = $Result.GetResult<Prisma.$JobPostingLocationPayload, S>

  type JobPostingLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobPostingLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobPostingLocationCountAggregateInputType | true
    }

  export interface JobPostingLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPostingLocation'], meta: { name: 'JobPostingLocation' } }
    /**
     * Find zero or one JobPostingLocation that matches the filter.
     * @param {JobPostingLocationFindUniqueArgs} args - Arguments to find a JobPostingLocation
     * @example
     * // Get one JobPostingLocation
     * const jobPostingLocation = await prisma.jobPostingLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobPostingLocationFindUniqueArgs>(args: SelectSubset<T, JobPostingLocationFindUniqueArgs<ExtArgs>>): Prisma__JobPostingLocationClient<$Result.GetResult<Prisma.$JobPostingLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobPostingLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobPostingLocationFindUniqueOrThrowArgs} args - Arguments to find a JobPostingLocation
     * @example
     * // Get one JobPostingLocation
     * const jobPostingLocation = await prisma.jobPostingLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobPostingLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, JobPostingLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobPostingLocationClient<$Result.GetResult<Prisma.$JobPostingLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingLocationFindFirstArgs} args - Arguments to find a JobPostingLocation
     * @example
     * // Get one JobPostingLocation
     * const jobPostingLocation = await prisma.jobPostingLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobPostingLocationFindFirstArgs>(args?: SelectSubset<T, JobPostingLocationFindFirstArgs<ExtArgs>>): Prisma__JobPostingLocationClient<$Result.GetResult<Prisma.$JobPostingLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingLocationFindFirstOrThrowArgs} args - Arguments to find a JobPostingLocation
     * @example
     * // Get one JobPostingLocation
     * const jobPostingLocation = await prisma.jobPostingLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobPostingLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, JobPostingLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobPostingLocationClient<$Result.GetResult<Prisma.$JobPostingLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobPostingLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPostingLocations
     * const jobPostingLocations = await prisma.jobPostingLocation.findMany()
     * 
     * // Get first 10 JobPostingLocations
     * const jobPostingLocations = await prisma.jobPostingLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPostingLocationWithIdOnly = await prisma.jobPostingLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobPostingLocationFindManyArgs>(args?: SelectSubset<T, JobPostingLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobPostingLocation.
     * @param {JobPostingLocationCreateArgs} args - Arguments to create a JobPostingLocation.
     * @example
     * // Create one JobPostingLocation
     * const JobPostingLocation = await prisma.jobPostingLocation.create({
     *   data: {
     *     // ... data to create a JobPostingLocation
     *   }
     * })
     * 
     */
    create<T extends JobPostingLocationCreateArgs>(args: SelectSubset<T, JobPostingLocationCreateArgs<ExtArgs>>): Prisma__JobPostingLocationClient<$Result.GetResult<Prisma.$JobPostingLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobPostingLocations.
     * @param {JobPostingLocationCreateManyArgs} args - Arguments to create many JobPostingLocations.
     * @example
     * // Create many JobPostingLocations
     * const jobPostingLocation = await prisma.jobPostingLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobPostingLocationCreateManyArgs>(args?: SelectSubset<T, JobPostingLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobPostingLocations and returns the data saved in the database.
     * @param {JobPostingLocationCreateManyAndReturnArgs} args - Arguments to create many JobPostingLocations.
     * @example
     * // Create many JobPostingLocations
     * const jobPostingLocation = await prisma.jobPostingLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobPostingLocations and only return the `id`
     * const jobPostingLocationWithIdOnly = await prisma.jobPostingLocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobPostingLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, JobPostingLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobPostingLocation.
     * @param {JobPostingLocationDeleteArgs} args - Arguments to delete one JobPostingLocation.
     * @example
     * // Delete one JobPostingLocation
     * const JobPostingLocation = await prisma.jobPostingLocation.delete({
     *   where: {
     *     // ... filter to delete one JobPostingLocation
     *   }
     * })
     * 
     */
    delete<T extends JobPostingLocationDeleteArgs>(args: SelectSubset<T, JobPostingLocationDeleteArgs<ExtArgs>>): Prisma__JobPostingLocationClient<$Result.GetResult<Prisma.$JobPostingLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobPostingLocation.
     * @param {JobPostingLocationUpdateArgs} args - Arguments to update one JobPostingLocation.
     * @example
     * // Update one JobPostingLocation
     * const jobPostingLocation = await prisma.jobPostingLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobPostingLocationUpdateArgs>(args: SelectSubset<T, JobPostingLocationUpdateArgs<ExtArgs>>): Prisma__JobPostingLocationClient<$Result.GetResult<Prisma.$JobPostingLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobPostingLocations.
     * @param {JobPostingLocationDeleteManyArgs} args - Arguments to filter JobPostingLocations to delete.
     * @example
     * // Delete a few JobPostingLocations
     * const { count } = await prisma.jobPostingLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobPostingLocationDeleteManyArgs>(args?: SelectSubset<T, JobPostingLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPostingLocations
     * const jobPostingLocation = await prisma.jobPostingLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobPostingLocationUpdateManyArgs>(args: SelectSubset<T, JobPostingLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingLocations and returns the data updated in the database.
     * @param {JobPostingLocationUpdateManyAndReturnArgs} args - Arguments to update many JobPostingLocations.
     * @example
     * // Update many JobPostingLocations
     * const jobPostingLocation = await prisma.jobPostingLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobPostingLocations and only return the `id`
     * const jobPostingLocationWithIdOnly = await prisma.jobPostingLocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobPostingLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, JobPostingLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobPostingLocation.
     * @param {JobPostingLocationUpsertArgs} args - Arguments to update or create a JobPostingLocation.
     * @example
     * // Update or create a JobPostingLocation
     * const jobPostingLocation = await prisma.jobPostingLocation.upsert({
     *   create: {
     *     // ... data to create a JobPostingLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPostingLocation we want to update
     *   }
     * })
     */
    upsert<T extends JobPostingLocationUpsertArgs>(args: SelectSubset<T, JobPostingLocationUpsertArgs<ExtArgs>>): Prisma__JobPostingLocationClient<$Result.GetResult<Prisma.$JobPostingLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobPostingLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingLocationCountArgs} args - Arguments to filter JobPostingLocations to count.
     * @example
     * // Count the number of JobPostingLocations
     * const count = await prisma.jobPostingLocation.count({
     *   where: {
     *     // ... the filter for the JobPostingLocations we want to count
     *   }
     * })
    **/
    count<T extends JobPostingLocationCountArgs>(
      args?: Subset<T, JobPostingLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostingLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPostingLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostingLocationAggregateArgs>(args: Subset<T, JobPostingLocationAggregateArgs>): Prisma.PrismaPromise<GetJobPostingLocationAggregateType<T>>

    /**
     * Group by JobPostingLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostingLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostingLocationGroupByArgs['orderBy'] }
        : { orderBy?: JobPostingLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostingLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostingLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPostingLocation model
   */
  readonly fields: JobPostingLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPostingLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPostingLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobPosting<T extends JobPostingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostingDefaultArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobPostingLocation model
   */
  interface JobPostingLocationFieldRefs {
    readonly id: FieldRef<"JobPostingLocation", 'String'>
    readonly jobPostingId: FieldRef<"JobPostingLocation", 'String'>
    readonly city: FieldRef<"JobPostingLocation", 'String'>
    readonly region: FieldRef<"JobPostingLocation", 'String'>
    readonly country: FieldRef<"JobPostingLocation", 'String'>
    readonly isRemote: FieldRef<"JobPostingLocation", 'Boolean'>
    readonly lat: FieldRef<"JobPostingLocation", 'Float'>
    readonly lng: FieldRef<"JobPostingLocation", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * JobPostingLocation findUnique
   */
  export type JobPostingLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLocation
     */
    select?: JobPostingLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLocation
     */
    omit?: JobPostingLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLocationInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingLocation to fetch.
     */
    where: JobPostingLocationWhereUniqueInput
  }

  /**
   * JobPostingLocation findUniqueOrThrow
   */
  export type JobPostingLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLocation
     */
    select?: JobPostingLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLocation
     */
    omit?: JobPostingLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLocationInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingLocation to fetch.
     */
    where: JobPostingLocationWhereUniqueInput
  }

  /**
   * JobPostingLocation findFirst
   */
  export type JobPostingLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLocation
     */
    select?: JobPostingLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLocation
     */
    omit?: JobPostingLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLocationInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingLocation to fetch.
     */
    where?: JobPostingLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingLocations to fetch.
     */
    orderBy?: JobPostingLocationOrderByWithRelationInput | JobPostingLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingLocations.
     */
    cursor?: JobPostingLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingLocations.
     */
    distinct?: JobPostingLocationScalarFieldEnum | JobPostingLocationScalarFieldEnum[]
  }

  /**
   * JobPostingLocation findFirstOrThrow
   */
  export type JobPostingLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLocation
     */
    select?: JobPostingLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLocation
     */
    omit?: JobPostingLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLocationInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingLocation to fetch.
     */
    where?: JobPostingLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingLocations to fetch.
     */
    orderBy?: JobPostingLocationOrderByWithRelationInput | JobPostingLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingLocations.
     */
    cursor?: JobPostingLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingLocations.
     */
    distinct?: JobPostingLocationScalarFieldEnum | JobPostingLocationScalarFieldEnum[]
  }

  /**
   * JobPostingLocation findMany
   */
  export type JobPostingLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLocation
     */
    select?: JobPostingLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLocation
     */
    omit?: JobPostingLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLocationInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingLocations to fetch.
     */
    where?: JobPostingLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingLocations to fetch.
     */
    orderBy?: JobPostingLocationOrderByWithRelationInput | JobPostingLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPostingLocations.
     */
    cursor?: JobPostingLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingLocations.
     */
    skip?: number
    distinct?: JobPostingLocationScalarFieldEnum | JobPostingLocationScalarFieldEnum[]
  }

  /**
   * JobPostingLocation create
   */
  export type JobPostingLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLocation
     */
    select?: JobPostingLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLocation
     */
    omit?: JobPostingLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPostingLocation.
     */
    data: XOR<JobPostingLocationCreateInput, JobPostingLocationUncheckedCreateInput>
  }

  /**
   * JobPostingLocation createMany
   */
  export type JobPostingLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPostingLocations.
     */
    data: JobPostingLocationCreateManyInput | JobPostingLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPostingLocation createManyAndReturn
   */
  export type JobPostingLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLocation
     */
    select?: JobPostingLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLocation
     */
    omit?: JobPostingLocationOmit<ExtArgs> | null
    /**
     * The data used to create many JobPostingLocations.
     */
    data: JobPostingLocationCreateManyInput | JobPostingLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingLocation update
   */
  export type JobPostingLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLocation
     */
    select?: JobPostingLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLocation
     */
    omit?: JobPostingLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPostingLocation.
     */
    data: XOR<JobPostingLocationUpdateInput, JobPostingLocationUncheckedUpdateInput>
    /**
     * Choose, which JobPostingLocation to update.
     */
    where: JobPostingLocationWhereUniqueInput
  }

  /**
   * JobPostingLocation updateMany
   */
  export type JobPostingLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPostingLocations.
     */
    data: XOR<JobPostingLocationUpdateManyMutationInput, JobPostingLocationUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingLocations to update
     */
    where?: JobPostingLocationWhereInput
    /**
     * Limit how many JobPostingLocations to update.
     */
    limit?: number
  }

  /**
   * JobPostingLocation updateManyAndReturn
   */
  export type JobPostingLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLocation
     */
    select?: JobPostingLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLocation
     */
    omit?: JobPostingLocationOmit<ExtArgs> | null
    /**
     * The data used to update JobPostingLocations.
     */
    data: XOR<JobPostingLocationUpdateManyMutationInput, JobPostingLocationUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingLocations to update
     */
    where?: JobPostingLocationWhereInput
    /**
     * Limit how many JobPostingLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingLocation upsert
   */
  export type JobPostingLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLocation
     */
    select?: JobPostingLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLocation
     */
    omit?: JobPostingLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPostingLocation to update in case it exists.
     */
    where: JobPostingLocationWhereUniqueInput
    /**
     * In case the JobPostingLocation found by the `where` argument doesn't exist, create a new JobPostingLocation with this data.
     */
    create: XOR<JobPostingLocationCreateInput, JobPostingLocationUncheckedCreateInput>
    /**
     * In case the JobPostingLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPostingLocationUpdateInput, JobPostingLocationUncheckedUpdateInput>
  }

  /**
   * JobPostingLocation delete
   */
  export type JobPostingLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLocation
     */
    select?: JobPostingLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLocation
     */
    omit?: JobPostingLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLocationInclude<ExtArgs> | null
    /**
     * Filter which JobPostingLocation to delete.
     */
    where: JobPostingLocationWhereUniqueInput
  }

  /**
   * JobPostingLocation deleteMany
   */
  export type JobPostingLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingLocations to delete
     */
    where?: JobPostingLocationWhereInput
    /**
     * Limit how many JobPostingLocations to delete.
     */
    limit?: number
  }

  /**
   * JobPostingLocation without action
   */
  export type JobPostingLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingLocation
     */
    select?: JobPostingLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingLocation
     */
    omit?: JobPostingLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingLocationInclude<ExtArgs> | null
  }


  /**
   * Model JobPostingWorkArrengment
   */

  export type AggregateJobPostingWorkArrengment = {
    _count: JobPostingWorkArrengmentCountAggregateOutputType | null
    _min: JobPostingWorkArrengmentMinAggregateOutputType | null
    _max: JobPostingWorkArrengmentMaxAggregateOutputType | null
  }

  export type JobPostingWorkArrengmentMinAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    mode: string | null
  }

  export type JobPostingWorkArrengmentMaxAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    mode: string | null
  }

  export type JobPostingWorkArrengmentCountAggregateOutputType = {
    id: number
    jobPostingId: number
    mode: number
    _all: number
  }


  export type JobPostingWorkArrengmentMinAggregateInputType = {
    id?: true
    jobPostingId?: true
    mode?: true
  }

  export type JobPostingWorkArrengmentMaxAggregateInputType = {
    id?: true
    jobPostingId?: true
    mode?: true
  }

  export type JobPostingWorkArrengmentCountAggregateInputType = {
    id?: true
    jobPostingId?: true
    mode?: true
    _all?: true
  }

  export type JobPostingWorkArrengmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingWorkArrengment to aggregate.
     */
    where?: JobPostingWorkArrengmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingWorkArrengments to fetch.
     */
    orderBy?: JobPostingWorkArrengmentOrderByWithRelationInput | JobPostingWorkArrengmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPostingWorkArrengmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingWorkArrengments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingWorkArrengments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPostingWorkArrengments
    **/
    _count?: true | JobPostingWorkArrengmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostingWorkArrengmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostingWorkArrengmentMaxAggregateInputType
  }

  export type GetJobPostingWorkArrengmentAggregateType<T extends JobPostingWorkArrengmentAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPostingWorkArrengment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPostingWorkArrengment[P]>
      : GetScalarType<T[P], AggregateJobPostingWorkArrengment[P]>
  }




  export type JobPostingWorkArrengmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingWorkArrengmentWhereInput
    orderBy?: JobPostingWorkArrengmentOrderByWithAggregationInput | JobPostingWorkArrengmentOrderByWithAggregationInput[]
    by: JobPostingWorkArrengmentScalarFieldEnum[] | JobPostingWorkArrengmentScalarFieldEnum
    having?: JobPostingWorkArrengmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostingWorkArrengmentCountAggregateInputType | true
    _min?: JobPostingWorkArrengmentMinAggregateInputType
    _max?: JobPostingWorkArrengmentMaxAggregateInputType
  }

  export type JobPostingWorkArrengmentGroupByOutputType = {
    id: string
    jobPostingId: string
    mode: string
    _count: JobPostingWorkArrengmentCountAggregateOutputType | null
    _min: JobPostingWorkArrengmentMinAggregateOutputType | null
    _max: JobPostingWorkArrengmentMaxAggregateOutputType | null
  }

  type GetJobPostingWorkArrengmentGroupByPayload<T extends JobPostingWorkArrengmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPostingWorkArrengmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostingWorkArrengmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostingWorkArrengmentGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostingWorkArrengmentGroupByOutputType[P]>
        }
      >
    >


  export type JobPostingWorkArrengmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    mode?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingWorkArrengment"]>

  export type JobPostingWorkArrengmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    mode?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingWorkArrengment"]>

  export type JobPostingWorkArrengmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    mode?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingWorkArrengment"]>

  export type JobPostingWorkArrengmentSelectScalar = {
    id?: boolean
    jobPostingId?: boolean
    mode?: boolean
  }

  export type JobPostingWorkArrengmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobPostingId" | "mode", ExtArgs["result"]["jobPostingWorkArrengment"]>
  export type JobPostingWorkArrengmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingWorkArrengmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingWorkArrengmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }

  export type $JobPostingWorkArrengmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPostingWorkArrengment"
    objects: {
      jobPosting: Prisma.$JobPostingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobPostingId: string
      mode: string
    }, ExtArgs["result"]["jobPostingWorkArrengment"]>
    composites: {}
  }

  type JobPostingWorkArrengmentGetPayload<S extends boolean | null | undefined | JobPostingWorkArrengmentDefaultArgs> = $Result.GetResult<Prisma.$JobPostingWorkArrengmentPayload, S>

  type JobPostingWorkArrengmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobPostingWorkArrengmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobPostingWorkArrengmentCountAggregateInputType | true
    }

  export interface JobPostingWorkArrengmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPostingWorkArrengment'], meta: { name: 'JobPostingWorkArrengment' } }
    /**
     * Find zero or one JobPostingWorkArrengment that matches the filter.
     * @param {JobPostingWorkArrengmentFindUniqueArgs} args - Arguments to find a JobPostingWorkArrengment
     * @example
     * // Get one JobPostingWorkArrengment
     * const jobPostingWorkArrengment = await prisma.jobPostingWorkArrengment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobPostingWorkArrengmentFindUniqueArgs>(args: SelectSubset<T, JobPostingWorkArrengmentFindUniqueArgs<ExtArgs>>): Prisma__JobPostingWorkArrengmentClient<$Result.GetResult<Prisma.$JobPostingWorkArrengmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobPostingWorkArrengment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobPostingWorkArrengmentFindUniqueOrThrowArgs} args - Arguments to find a JobPostingWorkArrengment
     * @example
     * // Get one JobPostingWorkArrengment
     * const jobPostingWorkArrengment = await prisma.jobPostingWorkArrengment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobPostingWorkArrengmentFindUniqueOrThrowArgs>(args: SelectSubset<T, JobPostingWorkArrengmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobPostingWorkArrengmentClient<$Result.GetResult<Prisma.$JobPostingWorkArrengmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingWorkArrengment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingWorkArrengmentFindFirstArgs} args - Arguments to find a JobPostingWorkArrengment
     * @example
     * // Get one JobPostingWorkArrengment
     * const jobPostingWorkArrengment = await prisma.jobPostingWorkArrengment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobPostingWorkArrengmentFindFirstArgs>(args?: SelectSubset<T, JobPostingWorkArrengmentFindFirstArgs<ExtArgs>>): Prisma__JobPostingWorkArrengmentClient<$Result.GetResult<Prisma.$JobPostingWorkArrengmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingWorkArrengment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingWorkArrengmentFindFirstOrThrowArgs} args - Arguments to find a JobPostingWorkArrengment
     * @example
     * // Get one JobPostingWorkArrengment
     * const jobPostingWorkArrengment = await prisma.jobPostingWorkArrengment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobPostingWorkArrengmentFindFirstOrThrowArgs>(args?: SelectSubset<T, JobPostingWorkArrengmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobPostingWorkArrengmentClient<$Result.GetResult<Prisma.$JobPostingWorkArrengmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobPostingWorkArrengments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingWorkArrengmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPostingWorkArrengments
     * const jobPostingWorkArrengments = await prisma.jobPostingWorkArrengment.findMany()
     * 
     * // Get first 10 JobPostingWorkArrengments
     * const jobPostingWorkArrengments = await prisma.jobPostingWorkArrengment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPostingWorkArrengmentWithIdOnly = await prisma.jobPostingWorkArrengment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobPostingWorkArrengmentFindManyArgs>(args?: SelectSubset<T, JobPostingWorkArrengmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingWorkArrengmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobPostingWorkArrengment.
     * @param {JobPostingWorkArrengmentCreateArgs} args - Arguments to create a JobPostingWorkArrengment.
     * @example
     * // Create one JobPostingWorkArrengment
     * const JobPostingWorkArrengment = await prisma.jobPostingWorkArrengment.create({
     *   data: {
     *     // ... data to create a JobPostingWorkArrengment
     *   }
     * })
     * 
     */
    create<T extends JobPostingWorkArrengmentCreateArgs>(args: SelectSubset<T, JobPostingWorkArrengmentCreateArgs<ExtArgs>>): Prisma__JobPostingWorkArrengmentClient<$Result.GetResult<Prisma.$JobPostingWorkArrengmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobPostingWorkArrengments.
     * @param {JobPostingWorkArrengmentCreateManyArgs} args - Arguments to create many JobPostingWorkArrengments.
     * @example
     * // Create many JobPostingWorkArrengments
     * const jobPostingWorkArrengment = await prisma.jobPostingWorkArrengment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobPostingWorkArrengmentCreateManyArgs>(args?: SelectSubset<T, JobPostingWorkArrengmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobPostingWorkArrengments and returns the data saved in the database.
     * @param {JobPostingWorkArrengmentCreateManyAndReturnArgs} args - Arguments to create many JobPostingWorkArrengments.
     * @example
     * // Create many JobPostingWorkArrengments
     * const jobPostingWorkArrengment = await prisma.jobPostingWorkArrengment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobPostingWorkArrengments and only return the `id`
     * const jobPostingWorkArrengmentWithIdOnly = await prisma.jobPostingWorkArrengment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobPostingWorkArrengmentCreateManyAndReturnArgs>(args?: SelectSubset<T, JobPostingWorkArrengmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingWorkArrengmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobPostingWorkArrengment.
     * @param {JobPostingWorkArrengmentDeleteArgs} args - Arguments to delete one JobPostingWorkArrengment.
     * @example
     * // Delete one JobPostingWorkArrengment
     * const JobPostingWorkArrengment = await prisma.jobPostingWorkArrengment.delete({
     *   where: {
     *     // ... filter to delete one JobPostingWorkArrengment
     *   }
     * })
     * 
     */
    delete<T extends JobPostingWorkArrengmentDeleteArgs>(args: SelectSubset<T, JobPostingWorkArrengmentDeleteArgs<ExtArgs>>): Prisma__JobPostingWorkArrengmentClient<$Result.GetResult<Prisma.$JobPostingWorkArrengmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobPostingWorkArrengment.
     * @param {JobPostingWorkArrengmentUpdateArgs} args - Arguments to update one JobPostingWorkArrengment.
     * @example
     * // Update one JobPostingWorkArrengment
     * const jobPostingWorkArrengment = await prisma.jobPostingWorkArrengment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobPostingWorkArrengmentUpdateArgs>(args: SelectSubset<T, JobPostingWorkArrengmentUpdateArgs<ExtArgs>>): Prisma__JobPostingWorkArrengmentClient<$Result.GetResult<Prisma.$JobPostingWorkArrengmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobPostingWorkArrengments.
     * @param {JobPostingWorkArrengmentDeleteManyArgs} args - Arguments to filter JobPostingWorkArrengments to delete.
     * @example
     * // Delete a few JobPostingWorkArrengments
     * const { count } = await prisma.jobPostingWorkArrengment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobPostingWorkArrengmentDeleteManyArgs>(args?: SelectSubset<T, JobPostingWorkArrengmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingWorkArrengments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingWorkArrengmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPostingWorkArrengments
     * const jobPostingWorkArrengment = await prisma.jobPostingWorkArrengment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobPostingWorkArrengmentUpdateManyArgs>(args: SelectSubset<T, JobPostingWorkArrengmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingWorkArrengments and returns the data updated in the database.
     * @param {JobPostingWorkArrengmentUpdateManyAndReturnArgs} args - Arguments to update many JobPostingWorkArrengments.
     * @example
     * // Update many JobPostingWorkArrengments
     * const jobPostingWorkArrengment = await prisma.jobPostingWorkArrengment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobPostingWorkArrengments and only return the `id`
     * const jobPostingWorkArrengmentWithIdOnly = await prisma.jobPostingWorkArrengment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobPostingWorkArrengmentUpdateManyAndReturnArgs>(args: SelectSubset<T, JobPostingWorkArrengmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingWorkArrengmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobPostingWorkArrengment.
     * @param {JobPostingWorkArrengmentUpsertArgs} args - Arguments to update or create a JobPostingWorkArrengment.
     * @example
     * // Update or create a JobPostingWorkArrengment
     * const jobPostingWorkArrengment = await prisma.jobPostingWorkArrengment.upsert({
     *   create: {
     *     // ... data to create a JobPostingWorkArrengment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPostingWorkArrengment we want to update
     *   }
     * })
     */
    upsert<T extends JobPostingWorkArrengmentUpsertArgs>(args: SelectSubset<T, JobPostingWorkArrengmentUpsertArgs<ExtArgs>>): Prisma__JobPostingWorkArrengmentClient<$Result.GetResult<Prisma.$JobPostingWorkArrengmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobPostingWorkArrengments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingWorkArrengmentCountArgs} args - Arguments to filter JobPostingWorkArrengments to count.
     * @example
     * // Count the number of JobPostingWorkArrengments
     * const count = await prisma.jobPostingWorkArrengment.count({
     *   where: {
     *     // ... the filter for the JobPostingWorkArrengments we want to count
     *   }
     * })
    **/
    count<T extends JobPostingWorkArrengmentCountArgs>(
      args?: Subset<T, JobPostingWorkArrengmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostingWorkArrengmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPostingWorkArrengment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingWorkArrengmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostingWorkArrengmentAggregateArgs>(args: Subset<T, JobPostingWorkArrengmentAggregateArgs>): Prisma.PrismaPromise<GetJobPostingWorkArrengmentAggregateType<T>>

    /**
     * Group by JobPostingWorkArrengment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingWorkArrengmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostingWorkArrengmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostingWorkArrengmentGroupByArgs['orderBy'] }
        : { orderBy?: JobPostingWorkArrengmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostingWorkArrengmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostingWorkArrengmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPostingWorkArrengment model
   */
  readonly fields: JobPostingWorkArrengmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPostingWorkArrengment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPostingWorkArrengmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobPosting<T extends JobPostingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostingDefaultArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobPostingWorkArrengment model
   */
  interface JobPostingWorkArrengmentFieldRefs {
    readonly id: FieldRef<"JobPostingWorkArrengment", 'String'>
    readonly jobPostingId: FieldRef<"JobPostingWorkArrengment", 'String'>
    readonly mode: FieldRef<"JobPostingWorkArrengment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobPostingWorkArrengment findUnique
   */
  export type JobPostingWorkArrengmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingWorkArrengment
     */
    select?: JobPostingWorkArrengmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingWorkArrengment
     */
    omit?: JobPostingWorkArrengmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingWorkArrengmentInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingWorkArrengment to fetch.
     */
    where: JobPostingWorkArrengmentWhereUniqueInput
  }

  /**
   * JobPostingWorkArrengment findUniqueOrThrow
   */
  export type JobPostingWorkArrengmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingWorkArrengment
     */
    select?: JobPostingWorkArrengmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingWorkArrengment
     */
    omit?: JobPostingWorkArrengmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingWorkArrengmentInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingWorkArrengment to fetch.
     */
    where: JobPostingWorkArrengmentWhereUniqueInput
  }

  /**
   * JobPostingWorkArrengment findFirst
   */
  export type JobPostingWorkArrengmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingWorkArrengment
     */
    select?: JobPostingWorkArrengmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingWorkArrengment
     */
    omit?: JobPostingWorkArrengmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingWorkArrengmentInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingWorkArrengment to fetch.
     */
    where?: JobPostingWorkArrengmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingWorkArrengments to fetch.
     */
    orderBy?: JobPostingWorkArrengmentOrderByWithRelationInput | JobPostingWorkArrengmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingWorkArrengments.
     */
    cursor?: JobPostingWorkArrengmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingWorkArrengments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingWorkArrengments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingWorkArrengments.
     */
    distinct?: JobPostingWorkArrengmentScalarFieldEnum | JobPostingWorkArrengmentScalarFieldEnum[]
  }

  /**
   * JobPostingWorkArrengment findFirstOrThrow
   */
  export type JobPostingWorkArrengmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingWorkArrengment
     */
    select?: JobPostingWorkArrengmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingWorkArrengment
     */
    omit?: JobPostingWorkArrengmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingWorkArrengmentInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingWorkArrengment to fetch.
     */
    where?: JobPostingWorkArrengmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingWorkArrengments to fetch.
     */
    orderBy?: JobPostingWorkArrengmentOrderByWithRelationInput | JobPostingWorkArrengmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingWorkArrengments.
     */
    cursor?: JobPostingWorkArrengmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingWorkArrengments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingWorkArrengments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingWorkArrengments.
     */
    distinct?: JobPostingWorkArrengmentScalarFieldEnum | JobPostingWorkArrengmentScalarFieldEnum[]
  }

  /**
   * JobPostingWorkArrengment findMany
   */
  export type JobPostingWorkArrengmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingWorkArrengment
     */
    select?: JobPostingWorkArrengmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingWorkArrengment
     */
    omit?: JobPostingWorkArrengmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingWorkArrengmentInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingWorkArrengments to fetch.
     */
    where?: JobPostingWorkArrengmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingWorkArrengments to fetch.
     */
    orderBy?: JobPostingWorkArrengmentOrderByWithRelationInput | JobPostingWorkArrengmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPostingWorkArrengments.
     */
    cursor?: JobPostingWorkArrengmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingWorkArrengments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingWorkArrengments.
     */
    skip?: number
    distinct?: JobPostingWorkArrengmentScalarFieldEnum | JobPostingWorkArrengmentScalarFieldEnum[]
  }

  /**
   * JobPostingWorkArrengment create
   */
  export type JobPostingWorkArrengmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingWorkArrengment
     */
    select?: JobPostingWorkArrengmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingWorkArrengment
     */
    omit?: JobPostingWorkArrengmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingWorkArrengmentInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPostingWorkArrengment.
     */
    data: XOR<JobPostingWorkArrengmentCreateInput, JobPostingWorkArrengmentUncheckedCreateInput>
  }

  /**
   * JobPostingWorkArrengment createMany
   */
  export type JobPostingWorkArrengmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPostingWorkArrengments.
     */
    data: JobPostingWorkArrengmentCreateManyInput | JobPostingWorkArrengmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPostingWorkArrengment createManyAndReturn
   */
  export type JobPostingWorkArrengmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingWorkArrengment
     */
    select?: JobPostingWorkArrengmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingWorkArrengment
     */
    omit?: JobPostingWorkArrengmentOmit<ExtArgs> | null
    /**
     * The data used to create many JobPostingWorkArrengments.
     */
    data: JobPostingWorkArrengmentCreateManyInput | JobPostingWorkArrengmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingWorkArrengmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingWorkArrengment update
   */
  export type JobPostingWorkArrengmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingWorkArrengment
     */
    select?: JobPostingWorkArrengmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingWorkArrengment
     */
    omit?: JobPostingWorkArrengmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingWorkArrengmentInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPostingWorkArrengment.
     */
    data: XOR<JobPostingWorkArrengmentUpdateInput, JobPostingWorkArrengmentUncheckedUpdateInput>
    /**
     * Choose, which JobPostingWorkArrengment to update.
     */
    where: JobPostingWorkArrengmentWhereUniqueInput
  }

  /**
   * JobPostingWorkArrengment updateMany
   */
  export type JobPostingWorkArrengmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPostingWorkArrengments.
     */
    data: XOR<JobPostingWorkArrengmentUpdateManyMutationInput, JobPostingWorkArrengmentUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingWorkArrengments to update
     */
    where?: JobPostingWorkArrengmentWhereInput
    /**
     * Limit how many JobPostingWorkArrengments to update.
     */
    limit?: number
  }

  /**
   * JobPostingWorkArrengment updateManyAndReturn
   */
  export type JobPostingWorkArrengmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingWorkArrengment
     */
    select?: JobPostingWorkArrengmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingWorkArrengment
     */
    omit?: JobPostingWorkArrengmentOmit<ExtArgs> | null
    /**
     * The data used to update JobPostingWorkArrengments.
     */
    data: XOR<JobPostingWorkArrengmentUpdateManyMutationInput, JobPostingWorkArrengmentUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingWorkArrengments to update
     */
    where?: JobPostingWorkArrengmentWhereInput
    /**
     * Limit how many JobPostingWorkArrengments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingWorkArrengmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingWorkArrengment upsert
   */
  export type JobPostingWorkArrengmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingWorkArrengment
     */
    select?: JobPostingWorkArrengmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingWorkArrengment
     */
    omit?: JobPostingWorkArrengmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingWorkArrengmentInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPostingWorkArrengment to update in case it exists.
     */
    where: JobPostingWorkArrengmentWhereUniqueInput
    /**
     * In case the JobPostingWorkArrengment found by the `where` argument doesn't exist, create a new JobPostingWorkArrengment with this data.
     */
    create: XOR<JobPostingWorkArrengmentCreateInput, JobPostingWorkArrengmentUncheckedCreateInput>
    /**
     * In case the JobPostingWorkArrengment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPostingWorkArrengmentUpdateInput, JobPostingWorkArrengmentUncheckedUpdateInput>
  }

  /**
   * JobPostingWorkArrengment delete
   */
  export type JobPostingWorkArrengmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingWorkArrengment
     */
    select?: JobPostingWorkArrengmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingWorkArrengment
     */
    omit?: JobPostingWorkArrengmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingWorkArrengmentInclude<ExtArgs> | null
    /**
     * Filter which JobPostingWorkArrengment to delete.
     */
    where: JobPostingWorkArrengmentWhereUniqueInput
  }

  /**
   * JobPostingWorkArrengment deleteMany
   */
  export type JobPostingWorkArrengmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingWorkArrengments to delete
     */
    where?: JobPostingWorkArrengmentWhereInput
    /**
     * Limit how many JobPostingWorkArrengments to delete.
     */
    limit?: number
  }

  /**
   * JobPostingWorkArrengment without action
   */
  export type JobPostingWorkArrengmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingWorkArrengment
     */
    select?: JobPostingWorkArrengmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingWorkArrengment
     */
    omit?: JobPostingWorkArrengmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingWorkArrengmentInclude<ExtArgs> | null
  }


  /**
   * Model JobPostingEmploymentType
   */

  export type AggregateJobPostingEmploymentType = {
    _count: JobPostingEmploymentTypeCountAggregateOutputType | null
    _min: JobPostingEmploymentTypeMinAggregateOutputType | null
    _max: JobPostingEmploymentTypeMaxAggregateOutputType | null
  }

  export type JobPostingEmploymentTypeMinAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    type: string | null
  }

  export type JobPostingEmploymentTypeMaxAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    type: string | null
  }

  export type JobPostingEmploymentTypeCountAggregateOutputType = {
    id: number
    jobPostingId: number
    type: number
    _all: number
  }


  export type JobPostingEmploymentTypeMinAggregateInputType = {
    id?: true
    jobPostingId?: true
    type?: true
  }

  export type JobPostingEmploymentTypeMaxAggregateInputType = {
    id?: true
    jobPostingId?: true
    type?: true
  }

  export type JobPostingEmploymentTypeCountAggregateInputType = {
    id?: true
    jobPostingId?: true
    type?: true
    _all?: true
  }

  export type JobPostingEmploymentTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingEmploymentType to aggregate.
     */
    where?: JobPostingEmploymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingEmploymentTypes to fetch.
     */
    orderBy?: JobPostingEmploymentTypeOrderByWithRelationInput | JobPostingEmploymentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPostingEmploymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingEmploymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingEmploymentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPostingEmploymentTypes
    **/
    _count?: true | JobPostingEmploymentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostingEmploymentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostingEmploymentTypeMaxAggregateInputType
  }

  export type GetJobPostingEmploymentTypeAggregateType<T extends JobPostingEmploymentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPostingEmploymentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPostingEmploymentType[P]>
      : GetScalarType<T[P], AggregateJobPostingEmploymentType[P]>
  }




  export type JobPostingEmploymentTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingEmploymentTypeWhereInput
    orderBy?: JobPostingEmploymentTypeOrderByWithAggregationInput | JobPostingEmploymentTypeOrderByWithAggregationInput[]
    by: JobPostingEmploymentTypeScalarFieldEnum[] | JobPostingEmploymentTypeScalarFieldEnum
    having?: JobPostingEmploymentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostingEmploymentTypeCountAggregateInputType | true
    _min?: JobPostingEmploymentTypeMinAggregateInputType
    _max?: JobPostingEmploymentTypeMaxAggregateInputType
  }

  export type JobPostingEmploymentTypeGroupByOutputType = {
    id: string
    jobPostingId: string
    type: string
    _count: JobPostingEmploymentTypeCountAggregateOutputType | null
    _min: JobPostingEmploymentTypeMinAggregateOutputType | null
    _max: JobPostingEmploymentTypeMaxAggregateOutputType | null
  }

  type GetJobPostingEmploymentTypeGroupByPayload<T extends JobPostingEmploymentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPostingEmploymentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostingEmploymentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostingEmploymentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostingEmploymentTypeGroupByOutputType[P]>
        }
      >
    >


  export type JobPostingEmploymentTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    type?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingEmploymentType"]>

  export type JobPostingEmploymentTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    type?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingEmploymentType"]>

  export type JobPostingEmploymentTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    type?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingEmploymentType"]>

  export type JobPostingEmploymentTypeSelectScalar = {
    id?: boolean
    jobPostingId?: boolean
    type?: boolean
  }

  export type JobPostingEmploymentTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobPostingId" | "type", ExtArgs["result"]["jobPostingEmploymentType"]>
  export type JobPostingEmploymentTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingEmploymentTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingEmploymentTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }

  export type $JobPostingEmploymentTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPostingEmploymentType"
    objects: {
      jobPosting: Prisma.$JobPostingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobPostingId: string
      type: string
    }, ExtArgs["result"]["jobPostingEmploymentType"]>
    composites: {}
  }

  type JobPostingEmploymentTypeGetPayload<S extends boolean | null | undefined | JobPostingEmploymentTypeDefaultArgs> = $Result.GetResult<Prisma.$JobPostingEmploymentTypePayload, S>

  type JobPostingEmploymentTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobPostingEmploymentTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobPostingEmploymentTypeCountAggregateInputType | true
    }

  export interface JobPostingEmploymentTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPostingEmploymentType'], meta: { name: 'JobPostingEmploymentType' } }
    /**
     * Find zero or one JobPostingEmploymentType that matches the filter.
     * @param {JobPostingEmploymentTypeFindUniqueArgs} args - Arguments to find a JobPostingEmploymentType
     * @example
     * // Get one JobPostingEmploymentType
     * const jobPostingEmploymentType = await prisma.jobPostingEmploymentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobPostingEmploymentTypeFindUniqueArgs>(args: SelectSubset<T, JobPostingEmploymentTypeFindUniqueArgs<ExtArgs>>): Prisma__JobPostingEmploymentTypeClient<$Result.GetResult<Prisma.$JobPostingEmploymentTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobPostingEmploymentType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobPostingEmploymentTypeFindUniqueOrThrowArgs} args - Arguments to find a JobPostingEmploymentType
     * @example
     * // Get one JobPostingEmploymentType
     * const jobPostingEmploymentType = await prisma.jobPostingEmploymentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobPostingEmploymentTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, JobPostingEmploymentTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobPostingEmploymentTypeClient<$Result.GetResult<Prisma.$JobPostingEmploymentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingEmploymentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingEmploymentTypeFindFirstArgs} args - Arguments to find a JobPostingEmploymentType
     * @example
     * // Get one JobPostingEmploymentType
     * const jobPostingEmploymentType = await prisma.jobPostingEmploymentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobPostingEmploymentTypeFindFirstArgs>(args?: SelectSubset<T, JobPostingEmploymentTypeFindFirstArgs<ExtArgs>>): Prisma__JobPostingEmploymentTypeClient<$Result.GetResult<Prisma.$JobPostingEmploymentTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingEmploymentType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingEmploymentTypeFindFirstOrThrowArgs} args - Arguments to find a JobPostingEmploymentType
     * @example
     * // Get one JobPostingEmploymentType
     * const jobPostingEmploymentType = await prisma.jobPostingEmploymentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobPostingEmploymentTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, JobPostingEmploymentTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobPostingEmploymentTypeClient<$Result.GetResult<Prisma.$JobPostingEmploymentTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobPostingEmploymentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingEmploymentTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPostingEmploymentTypes
     * const jobPostingEmploymentTypes = await prisma.jobPostingEmploymentType.findMany()
     * 
     * // Get first 10 JobPostingEmploymentTypes
     * const jobPostingEmploymentTypes = await prisma.jobPostingEmploymentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPostingEmploymentTypeWithIdOnly = await prisma.jobPostingEmploymentType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobPostingEmploymentTypeFindManyArgs>(args?: SelectSubset<T, JobPostingEmploymentTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingEmploymentTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobPostingEmploymentType.
     * @param {JobPostingEmploymentTypeCreateArgs} args - Arguments to create a JobPostingEmploymentType.
     * @example
     * // Create one JobPostingEmploymentType
     * const JobPostingEmploymentType = await prisma.jobPostingEmploymentType.create({
     *   data: {
     *     // ... data to create a JobPostingEmploymentType
     *   }
     * })
     * 
     */
    create<T extends JobPostingEmploymentTypeCreateArgs>(args: SelectSubset<T, JobPostingEmploymentTypeCreateArgs<ExtArgs>>): Prisma__JobPostingEmploymentTypeClient<$Result.GetResult<Prisma.$JobPostingEmploymentTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobPostingEmploymentTypes.
     * @param {JobPostingEmploymentTypeCreateManyArgs} args - Arguments to create many JobPostingEmploymentTypes.
     * @example
     * // Create many JobPostingEmploymentTypes
     * const jobPostingEmploymentType = await prisma.jobPostingEmploymentType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobPostingEmploymentTypeCreateManyArgs>(args?: SelectSubset<T, JobPostingEmploymentTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobPostingEmploymentTypes and returns the data saved in the database.
     * @param {JobPostingEmploymentTypeCreateManyAndReturnArgs} args - Arguments to create many JobPostingEmploymentTypes.
     * @example
     * // Create many JobPostingEmploymentTypes
     * const jobPostingEmploymentType = await prisma.jobPostingEmploymentType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobPostingEmploymentTypes and only return the `id`
     * const jobPostingEmploymentTypeWithIdOnly = await prisma.jobPostingEmploymentType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobPostingEmploymentTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, JobPostingEmploymentTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingEmploymentTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobPostingEmploymentType.
     * @param {JobPostingEmploymentTypeDeleteArgs} args - Arguments to delete one JobPostingEmploymentType.
     * @example
     * // Delete one JobPostingEmploymentType
     * const JobPostingEmploymentType = await prisma.jobPostingEmploymentType.delete({
     *   where: {
     *     // ... filter to delete one JobPostingEmploymentType
     *   }
     * })
     * 
     */
    delete<T extends JobPostingEmploymentTypeDeleteArgs>(args: SelectSubset<T, JobPostingEmploymentTypeDeleteArgs<ExtArgs>>): Prisma__JobPostingEmploymentTypeClient<$Result.GetResult<Prisma.$JobPostingEmploymentTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobPostingEmploymentType.
     * @param {JobPostingEmploymentTypeUpdateArgs} args - Arguments to update one JobPostingEmploymentType.
     * @example
     * // Update one JobPostingEmploymentType
     * const jobPostingEmploymentType = await prisma.jobPostingEmploymentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobPostingEmploymentTypeUpdateArgs>(args: SelectSubset<T, JobPostingEmploymentTypeUpdateArgs<ExtArgs>>): Prisma__JobPostingEmploymentTypeClient<$Result.GetResult<Prisma.$JobPostingEmploymentTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobPostingEmploymentTypes.
     * @param {JobPostingEmploymentTypeDeleteManyArgs} args - Arguments to filter JobPostingEmploymentTypes to delete.
     * @example
     * // Delete a few JobPostingEmploymentTypes
     * const { count } = await prisma.jobPostingEmploymentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobPostingEmploymentTypeDeleteManyArgs>(args?: SelectSubset<T, JobPostingEmploymentTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingEmploymentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingEmploymentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPostingEmploymentTypes
     * const jobPostingEmploymentType = await prisma.jobPostingEmploymentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobPostingEmploymentTypeUpdateManyArgs>(args: SelectSubset<T, JobPostingEmploymentTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingEmploymentTypes and returns the data updated in the database.
     * @param {JobPostingEmploymentTypeUpdateManyAndReturnArgs} args - Arguments to update many JobPostingEmploymentTypes.
     * @example
     * // Update many JobPostingEmploymentTypes
     * const jobPostingEmploymentType = await prisma.jobPostingEmploymentType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobPostingEmploymentTypes and only return the `id`
     * const jobPostingEmploymentTypeWithIdOnly = await prisma.jobPostingEmploymentType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobPostingEmploymentTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, JobPostingEmploymentTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingEmploymentTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobPostingEmploymentType.
     * @param {JobPostingEmploymentTypeUpsertArgs} args - Arguments to update or create a JobPostingEmploymentType.
     * @example
     * // Update or create a JobPostingEmploymentType
     * const jobPostingEmploymentType = await prisma.jobPostingEmploymentType.upsert({
     *   create: {
     *     // ... data to create a JobPostingEmploymentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPostingEmploymentType we want to update
     *   }
     * })
     */
    upsert<T extends JobPostingEmploymentTypeUpsertArgs>(args: SelectSubset<T, JobPostingEmploymentTypeUpsertArgs<ExtArgs>>): Prisma__JobPostingEmploymentTypeClient<$Result.GetResult<Prisma.$JobPostingEmploymentTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobPostingEmploymentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingEmploymentTypeCountArgs} args - Arguments to filter JobPostingEmploymentTypes to count.
     * @example
     * // Count the number of JobPostingEmploymentTypes
     * const count = await prisma.jobPostingEmploymentType.count({
     *   where: {
     *     // ... the filter for the JobPostingEmploymentTypes we want to count
     *   }
     * })
    **/
    count<T extends JobPostingEmploymentTypeCountArgs>(
      args?: Subset<T, JobPostingEmploymentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostingEmploymentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPostingEmploymentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingEmploymentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostingEmploymentTypeAggregateArgs>(args: Subset<T, JobPostingEmploymentTypeAggregateArgs>): Prisma.PrismaPromise<GetJobPostingEmploymentTypeAggregateType<T>>

    /**
     * Group by JobPostingEmploymentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingEmploymentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostingEmploymentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostingEmploymentTypeGroupByArgs['orderBy'] }
        : { orderBy?: JobPostingEmploymentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostingEmploymentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostingEmploymentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPostingEmploymentType model
   */
  readonly fields: JobPostingEmploymentTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPostingEmploymentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPostingEmploymentTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobPosting<T extends JobPostingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostingDefaultArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobPostingEmploymentType model
   */
  interface JobPostingEmploymentTypeFieldRefs {
    readonly id: FieldRef<"JobPostingEmploymentType", 'String'>
    readonly jobPostingId: FieldRef<"JobPostingEmploymentType", 'String'>
    readonly type: FieldRef<"JobPostingEmploymentType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobPostingEmploymentType findUnique
   */
  export type JobPostingEmploymentTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingEmploymentType
     */
    select?: JobPostingEmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingEmploymentType
     */
    omit?: JobPostingEmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingEmploymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingEmploymentType to fetch.
     */
    where: JobPostingEmploymentTypeWhereUniqueInput
  }

  /**
   * JobPostingEmploymentType findUniqueOrThrow
   */
  export type JobPostingEmploymentTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingEmploymentType
     */
    select?: JobPostingEmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingEmploymentType
     */
    omit?: JobPostingEmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingEmploymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingEmploymentType to fetch.
     */
    where: JobPostingEmploymentTypeWhereUniqueInput
  }

  /**
   * JobPostingEmploymentType findFirst
   */
  export type JobPostingEmploymentTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingEmploymentType
     */
    select?: JobPostingEmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingEmploymentType
     */
    omit?: JobPostingEmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingEmploymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingEmploymentType to fetch.
     */
    where?: JobPostingEmploymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingEmploymentTypes to fetch.
     */
    orderBy?: JobPostingEmploymentTypeOrderByWithRelationInput | JobPostingEmploymentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingEmploymentTypes.
     */
    cursor?: JobPostingEmploymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingEmploymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingEmploymentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingEmploymentTypes.
     */
    distinct?: JobPostingEmploymentTypeScalarFieldEnum | JobPostingEmploymentTypeScalarFieldEnum[]
  }

  /**
   * JobPostingEmploymentType findFirstOrThrow
   */
  export type JobPostingEmploymentTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingEmploymentType
     */
    select?: JobPostingEmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingEmploymentType
     */
    omit?: JobPostingEmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingEmploymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingEmploymentType to fetch.
     */
    where?: JobPostingEmploymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingEmploymentTypes to fetch.
     */
    orderBy?: JobPostingEmploymentTypeOrderByWithRelationInput | JobPostingEmploymentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingEmploymentTypes.
     */
    cursor?: JobPostingEmploymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingEmploymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingEmploymentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingEmploymentTypes.
     */
    distinct?: JobPostingEmploymentTypeScalarFieldEnum | JobPostingEmploymentTypeScalarFieldEnum[]
  }

  /**
   * JobPostingEmploymentType findMany
   */
  export type JobPostingEmploymentTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingEmploymentType
     */
    select?: JobPostingEmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingEmploymentType
     */
    omit?: JobPostingEmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingEmploymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingEmploymentTypes to fetch.
     */
    where?: JobPostingEmploymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingEmploymentTypes to fetch.
     */
    orderBy?: JobPostingEmploymentTypeOrderByWithRelationInput | JobPostingEmploymentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPostingEmploymentTypes.
     */
    cursor?: JobPostingEmploymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingEmploymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingEmploymentTypes.
     */
    skip?: number
    distinct?: JobPostingEmploymentTypeScalarFieldEnum | JobPostingEmploymentTypeScalarFieldEnum[]
  }

  /**
   * JobPostingEmploymentType create
   */
  export type JobPostingEmploymentTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingEmploymentType
     */
    select?: JobPostingEmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingEmploymentType
     */
    omit?: JobPostingEmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingEmploymentTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPostingEmploymentType.
     */
    data: XOR<JobPostingEmploymentTypeCreateInput, JobPostingEmploymentTypeUncheckedCreateInput>
  }

  /**
   * JobPostingEmploymentType createMany
   */
  export type JobPostingEmploymentTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPostingEmploymentTypes.
     */
    data: JobPostingEmploymentTypeCreateManyInput | JobPostingEmploymentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPostingEmploymentType createManyAndReturn
   */
  export type JobPostingEmploymentTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingEmploymentType
     */
    select?: JobPostingEmploymentTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingEmploymentType
     */
    omit?: JobPostingEmploymentTypeOmit<ExtArgs> | null
    /**
     * The data used to create many JobPostingEmploymentTypes.
     */
    data: JobPostingEmploymentTypeCreateManyInput | JobPostingEmploymentTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingEmploymentTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingEmploymentType update
   */
  export type JobPostingEmploymentTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingEmploymentType
     */
    select?: JobPostingEmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingEmploymentType
     */
    omit?: JobPostingEmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingEmploymentTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPostingEmploymentType.
     */
    data: XOR<JobPostingEmploymentTypeUpdateInput, JobPostingEmploymentTypeUncheckedUpdateInput>
    /**
     * Choose, which JobPostingEmploymentType to update.
     */
    where: JobPostingEmploymentTypeWhereUniqueInput
  }

  /**
   * JobPostingEmploymentType updateMany
   */
  export type JobPostingEmploymentTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPostingEmploymentTypes.
     */
    data: XOR<JobPostingEmploymentTypeUpdateManyMutationInput, JobPostingEmploymentTypeUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingEmploymentTypes to update
     */
    where?: JobPostingEmploymentTypeWhereInput
    /**
     * Limit how many JobPostingEmploymentTypes to update.
     */
    limit?: number
  }

  /**
   * JobPostingEmploymentType updateManyAndReturn
   */
  export type JobPostingEmploymentTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingEmploymentType
     */
    select?: JobPostingEmploymentTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingEmploymentType
     */
    omit?: JobPostingEmploymentTypeOmit<ExtArgs> | null
    /**
     * The data used to update JobPostingEmploymentTypes.
     */
    data: XOR<JobPostingEmploymentTypeUpdateManyMutationInput, JobPostingEmploymentTypeUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingEmploymentTypes to update
     */
    where?: JobPostingEmploymentTypeWhereInput
    /**
     * Limit how many JobPostingEmploymentTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingEmploymentTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingEmploymentType upsert
   */
  export type JobPostingEmploymentTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingEmploymentType
     */
    select?: JobPostingEmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingEmploymentType
     */
    omit?: JobPostingEmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingEmploymentTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPostingEmploymentType to update in case it exists.
     */
    where: JobPostingEmploymentTypeWhereUniqueInput
    /**
     * In case the JobPostingEmploymentType found by the `where` argument doesn't exist, create a new JobPostingEmploymentType with this data.
     */
    create: XOR<JobPostingEmploymentTypeCreateInput, JobPostingEmploymentTypeUncheckedCreateInput>
    /**
     * In case the JobPostingEmploymentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPostingEmploymentTypeUpdateInput, JobPostingEmploymentTypeUncheckedUpdateInput>
  }

  /**
   * JobPostingEmploymentType delete
   */
  export type JobPostingEmploymentTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingEmploymentType
     */
    select?: JobPostingEmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingEmploymentType
     */
    omit?: JobPostingEmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingEmploymentTypeInclude<ExtArgs> | null
    /**
     * Filter which JobPostingEmploymentType to delete.
     */
    where: JobPostingEmploymentTypeWhereUniqueInput
  }

  /**
   * JobPostingEmploymentType deleteMany
   */
  export type JobPostingEmploymentTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingEmploymentTypes to delete
     */
    where?: JobPostingEmploymentTypeWhereInput
    /**
     * Limit how many JobPostingEmploymentTypes to delete.
     */
    limit?: number
  }

  /**
   * JobPostingEmploymentType without action
   */
  export type JobPostingEmploymentTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingEmploymentType
     */
    select?: JobPostingEmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingEmploymentType
     */
    omit?: JobPostingEmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingEmploymentTypeInclude<ExtArgs> | null
  }


  /**
   * Model JobPostingSalary
   */

  export type AggregateJobPostingSalary = {
    _count: JobPostingSalaryCountAggregateOutputType | null
    _min: JobPostingSalaryMinAggregateOutputType | null
    _max: JobPostingSalaryMaxAggregateOutputType | null
  }

  export type JobPostingSalaryMinAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    type: string | null
    amount: string | null
    currency: string | null
    period: string | null
    notes: string | null
  }

  export type JobPostingSalaryMaxAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    type: string | null
    amount: string | null
    currency: string | null
    period: string | null
    notes: string | null
  }

  export type JobPostingSalaryCountAggregateOutputType = {
    id: number
    jobPostingId: number
    type: number
    amount: number
    currency: number
    period: number
    benefits: number
    notes: number
    _all: number
  }


  export type JobPostingSalaryMinAggregateInputType = {
    id?: true
    jobPostingId?: true
    type?: true
    amount?: true
    currency?: true
    period?: true
    notes?: true
  }

  export type JobPostingSalaryMaxAggregateInputType = {
    id?: true
    jobPostingId?: true
    type?: true
    amount?: true
    currency?: true
    period?: true
    notes?: true
  }

  export type JobPostingSalaryCountAggregateInputType = {
    id?: true
    jobPostingId?: true
    type?: true
    amount?: true
    currency?: true
    period?: true
    benefits?: true
    notes?: true
    _all?: true
  }

  export type JobPostingSalaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingSalary to aggregate.
     */
    where?: JobPostingSalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingSalaries to fetch.
     */
    orderBy?: JobPostingSalaryOrderByWithRelationInput | JobPostingSalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPostingSalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingSalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingSalaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPostingSalaries
    **/
    _count?: true | JobPostingSalaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostingSalaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostingSalaryMaxAggregateInputType
  }

  export type GetJobPostingSalaryAggregateType<T extends JobPostingSalaryAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPostingSalary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPostingSalary[P]>
      : GetScalarType<T[P], AggregateJobPostingSalary[P]>
  }




  export type JobPostingSalaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingSalaryWhereInput
    orderBy?: JobPostingSalaryOrderByWithAggregationInput | JobPostingSalaryOrderByWithAggregationInput[]
    by: JobPostingSalaryScalarFieldEnum[] | JobPostingSalaryScalarFieldEnum
    having?: JobPostingSalaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostingSalaryCountAggregateInputType | true
    _min?: JobPostingSalaryMinAggregateInputType
    _max?: JobPostingSalaryMaxAggregateInputType
  }

  export type JobPostingSalaryGroupByOutputType = {
    id: string
    jobPostingId: string
    type: string
    amount: string | null
    currency: string
    period: string
    benefits: string[]
    notes: string | null
    _count: JobPostingSalaryCountAggregateOutputType | null
    _min: JobPostingSalaryMinAggregateOutputType | null
    _max: JobPostingSalaryMaxAggregateOutputType | null
  }

  type GetJobPostingSalaryGroupByPayload<T extends JobPostingSalaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPostingSalaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostingSalaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostingSalaryGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostingSalaryGroupByOutputType[P]>
        }
      >
    >


  export type JobPostingSalarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    period?: boolean
    benefits?: boolean
    notes?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingSalary"]>

  export type JobPostingSalarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    period?: boolean
    benefits?: boolean
    notes?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingSalary"]>

  export type JobPostingSalarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    period?: boolean
    benefits?: boolean
    notes?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPostingSalary"]>

  export type JobPostingSalarySelectScalar = {
    id?: boolean
    jobPostingId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    period?: boolean
    benefits?: boolean
    notes?: boolean
  }

  export type JobPostingSalaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobPostingId" | "type" | "amount" | "currency" | "period" | "benefits" | "notes", ExtArgs["result"]["jobPostingSalary"]>
  export type JobPostingSalaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingSalaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobPostingSalaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }

  export type $JobPostingSalaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPostingSalary"
    objects: {
      jobPosting: Prisma.$JobPostingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobPostingId: string
      type: string
      amount: string | null
      currency: string
      period: string
      benefits: string[]
      notes: string | null
    }, ExtArgs["result"]["jobPostingSalary"]>
    composites: {}
  }

  type JobPostingSalaryGetPayload<S extends boolean | null | undefined | JobPostingSalaryDefaultArgs> = $Result.GetResult<Prisma.$JobPostingSalaryPayload, S>

  type JobPostingSalaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobPostingSalaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobPostingSalaryCountAggregateInputType | true
    }

  export interface JobPostingSalaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPostingSalary'], meta: { name: 'JobPostingSalary' } }
    /**
     * Find zero or one JobPostingSalary that matches the filter.
     * @param {JobPostingSalaryFindUniqueArgs} args - Arguments to find a JobPostingSalary
     * @example
     * // Get one JobPostingSalary
     * const jobPostingSalary = await prisma.jobPostingSalary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobPostingSalaryFindUniqueArgs>(args: SelectSubset<T, JobPostingSalaryFindUniqueArgs<ExtArgs>>): Prisma__JobPostingSalaryClient<$Result.GetResult<Prisma.$JobPostingSalaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobPostingSalary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobPostingSalaryFindUniqueOrThrowArgs} args - Arguments to find a JobPostingSalary
     * @example
     * // Get one JobPostingSalary
     * const jobPostingSalary = await prisma.jobPostingSalary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobPostingSalaryFindUniqueOrThrowArgs>(args: SelectSubset<T, JobPostingSalaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobPostingSalaryClient<$Result.GetResult<Prisma.$JobPostingSalaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingSalary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingSalaryFindFirstArgs} args - Arguments to find a JobPostingSalary
     * @example
     * // Get one JobPostingSalary
     * const jobPostingSalary = await prisma.jobPostingSalary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobPostingSalaryFindFirstArgs>(args?: SelectSubset<T, JobPostingSalaryFindFirstArgs<ExtArgs>>): Prisma__JobPostingSalaryClient<$Result.GetResult<Prisma.$JobPostingSalaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPostingSalary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingSalaryFindFirstOrThrowArgs} args - Arguments to find a JobPostingSalary
     * @example
     * // Get one JobPostingSalary
     * const jobPostingSalary = await prisma.jobPostingSalary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobPostingSalaryFindFirstOrThrowArgs>(args?: SelectSubset<T, JobPostingSalaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobPostingSalaryClient<$Result.GetResult<Prisma.$JobPostingSalaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobPostingSalaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingSalaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPostingSalaries
     * const jobPostingSalaries = await prisma.jobPostingSalary.findMany()
     * 
     * // Get first 10 JobPostingSalaries
     * const jobPostingSalaries = await prisma.jobPostingSalary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPostingSalaryWithIdOnly = await prisma.jobPostingSalary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobPostingSalaryFindManyArgs>(args?: SelectSubset<T, JobPostingSalaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingSalaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobPostingSalary.
     * @param {JobPostingSalaryCreateArgs} args - Arguments to create a JobPostingSalary.
     * @example
     * // Create one JobPostingSalary
     * const JobPostingSalary = await prisma.jobPostingSalary.create({
     *   data: {
     *     // ... data to create a JobPostingSalary
     *   }
     * })
     * 
     */
    create<T extends JobPostingSalaryCreateArgs>(args: SelectSubset<T, JobPostingSalaryCreateArgs<ExtArgs>>): Prisma__JobPostingSalaryClient<$Result.GetResult<Prisma.$JobPostingSalaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobPostingSalaries.
     * @param {JobPostingSalaryCreateManyArgs} args - Arguments to create many JobPostingSalaries.
     * @example
     * // Create many JobPostingSalaries
     * const jobPostingSalary = await prisma.jobPostingSalary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobPostingSalaryCreateManyArgs>(args?: SelectSubset<T, JobPostingSalaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobPostingSalaries and returns the data saved in the database.
     * @param {JobPostingSalaryCreateManyAndReturnArgs} args - Arguments to create many JobPostingSalaries.
     * @example
     * // Create many JobPostingSalaries
     * const jobPostingSalary = await prisma.jobPostingSalary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobPostingSalaries and only return the `id`
     * const jobPostingSalaryWithIdOnly = await prisma.jobPostingSalary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobPostingSalaryCreateManyAndReturnArgs>(args?: SelectSubset<T, JobPostingSalaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingSalaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobPostingSalary.
     * @param {JobPostingSalaryDeleteArgs} args - Arguments to delete one JobPostingSalary.
     * @example
     * // Delete one JobPostingSalary
     * const JobPostingSalary = await prisma.jobPostingSalary.delete({
     *   where: {
     *     // ... filter to delete one JobPostingSalary
     *   }
     * })
     * 
     */
    delete<T extends JobPostingSalaryDeleteArgs>(args: SelectSubset<T, JobPostingSalaryDeleteArgs<ExtArgs>>): Prisma__JobPostingSalaryClient<$Result.GetResult<Prisma.$JobPostingSalaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobPostingSalary.
     * @param {JobPostingSalaryUpdateArgs} args - Arguments to update one JobPostingSalary.
     * @example
     * // Update one JobPostingSalary
     * const jobPostingSalary = await prisma.jobPostingSalary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobPostingSalaryUpdateArgs>(args: SelectSubset<T, JobPostingSalaryUpdateArgs<ExtArgs>>): Prisma__JobPostingSalaryClient<$Result.GetResult<Prisma.$JobPostingSalaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobPostingSalaries.
     * @param {JobPostingSalaryDeleteManyArgs} args - Arguments to filter JobPostingSalaries to delete.
     * @example
     * // Delete a few JobPostingSalaries
     * const { count } = await prisma.jobPostingSalary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobPostingSalaryDeleteManyArgs>(args?: SelectSubset<T, JobPostingSalaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingSalaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingSalaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPostingSalaries
     * const jobPostingSalary = await prisma.jobPostingSalary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobPostingSalaryUpdateManyArgs>(args: SelectSubset<T, JobPostingSalaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostingSalaries and returns the data updated in the database.
     * @param {JobPostingSalaryUpdateManyAndReturnArgs} args - Arguments to update many JobPostingSalaries.
     * @example
     * // Update many JobPostingSalaries
     * const jobPostingSalary = await prisma.jobPostingSalary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobPostingSalaries and only return the `id`
     * const jobPostingSalaryWithIdOnly = await prisma.jobPostingSalary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobPostingSalaryUpdateManyAndReturnArgs>(args: SelectSubset<T, JobPostingSalaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingSalaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobPostingSalary.
     * @param {JobPostingSalaryUpsertArgs} args - Arguments to update or create a JobPostingSalary.
     * @example
     * // Update or create a JobPostingSalary
     * const jobPostingSalary = await prisma.jobPostingSalary.upsert({
     *   create: {
     *     // ... data to create a JobPostingSalary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPostingSalary we want to update
     *   }
     * })
     */
    upsert<T extends JobPostingSalaryUpsertArgs>(args: SelectSubset<T, JobPostingSalaryUpsertArgs<ExtArgs>>): Prisma__JobPostingSalaryClient<$Result.GetResult<Prisma.$JobPostingSalaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobPostingSalaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingSalaryCountArgs} args - Arguments to filter JobPostingSalaries to count.
     * @example
     * // Count the number of JobPostingSalaries
     * const count = await prisma.jobPostingSalary.count({
     *   where: {
     *     // ... the filter for the JobPostingSalaries we want to count
     *   }
     * })
    **/
    count<T extends JobPostingSalaryCountArgs>(
      args?: Subset<T, JobPostingSalaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostingSalaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPostingSalary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingSalaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostingSalaryAggregateArgs>(args: Subset<T, JobPostingSalaryAggregateArgs>): Prisma.PrismaPromise<GetJobPostingSalaryAggregateType<T>>

    /**
     * Group by JobPostingSalary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingSalaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostingSalaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostingSalaryGroupByArgs['orderBy'] }
        : { orderBy?: JobPostingSalaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostingSalaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostingSalaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPostingSalary model
   */
  readonly fields: JobPostingSalaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPostingSalary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPostingSalaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobPosting<T extends JobPostingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostingDefaultArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobPostingSalary model
   */
  interface JobPostingSalaryFieldRefs {
    readonly id: FieldRef<"JobPostingSalary", 'String'>
    readonly jobPostingId: FieldRef<"JobPostingSalary", 'String'>
    readonly type: FieldRef<"JobPostingSalary", 'String'>
    readonly amount: FieldRef<"JobPostingSalary", 'String'>
    readonly currency: FieldRef<"JobPostingSalary", 'String'>
    readonly period: FieldRef<"JobPostingSalary", 'String'>
    readonly benefits: FieldRef<"JobPostingSalary", 'String[]'>
    readonly notes: FieldRef<"JobPostingSalary", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobPostingSalary findUnique
   */
  export type JobPostingSalaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingSalary
     */
    select?: JobPostingSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingSalary
     */
    omit?: JobPostingSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingSalaryInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingSalary to fetch.
     */
    where: JobPostingSalaryWhereUniqueInput
  }

  /**
   * JobPostingSalary findUniqueOrThrow
   */
  export type JobPostingSalaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingSalary
     */
    select?: JobPostingSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingSalary
     */
    omit?: JobPostingSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingSalaryInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingSalary to fetch.
     */
    where: JobPostingSalaryWhereUniqueInput
  }

  /**
   * JobPostingSalary findFirst
   */
  export type JobPostingSalaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingSalary
     */
    select?: JobPostingSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingSalary
     */
    omit?: JobPostingSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingSalaryInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingSalary to fetch.
     */
    where?: JobPostingSalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingSalaries to fetch.
     */
    orderBy?: JobPostingSalaryOrderByWithRelationInput | JobPostingSalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingSalaries.
     */
    cursor?: JobPostingSalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingSalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingSalaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingSalaries.
     */
    distinct?: JobPostingSalaryScalarFieldEnum | JobPostingSalaryScalarFieldEnum[]
  }

  /**
   * JobPostingSalary findFirstOrThrow
   */
  export type JobPostingSalaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingSalary
     */
    select?: JobPostingSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingSalary
     */
    omit?: JobPostingSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingSalaryInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingSalary to fetch.
     */
    where?: JobPostingSalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingSalaries to fetch.
     */
    orderBy?: JobPostingSalaryOrderByWithRelationInput | JobPostingSalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostingSalaries.
     */
    cursor?: JobPostingSalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingSalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingSalaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostingSalaries.
     */
    distinct?: JobPostingSalaryScalarFieldEnum | JobPostingSalaryScalarFieldEnum[]
  }

  /**
   * JobPostingSalary findMany
   */
  export type JobPostingSalaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingSalary
     */
    select?: JobPostingSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingSalary
     */
    omit?: JobPostingSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingSalaryInclude<ExtArgs> | null
    /**
     * Filter, which JobPostingSalaries to fetch.
     */
    where?: JobPostingSalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostingSalaries to fetch.
     */
    orderBy?: JobPostingSalaryOrderByWithRelationInput | JobPostingSalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPostingSalaries.
     */
    cursor?: JobPostingSalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobPostingSalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostingSalaries.
     */
    skip?: number
    distinct?: JobPostingSalaryScalarFieldEnum | JobPostingSalaryScalarFieldEnum[]
  }

  /**
   * JobPostingSalary create
   */
  export type JobPostingSalaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingSalary
     */
    select?: JobPostingSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingSalary
     */
    omit?: JobPostingSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingSalaryInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPostingSalary.
     */
    data: XOR<JobPostingSalaryCreateInput, JobPostingSalaryUncheckedCreateInput>
  }

  /**
   * JobPostingSalary createMany
   */
  export type JobPostingSalaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPostingSalaries.
     */
    data: JobPostingSalaryCreateManyInput | JobPostingSalaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPostingSalary createManyAndReturn
   */
  export type JobPostingSalaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingSalary
     */
    select?: JobPostingSalarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingSalary
     */
    omit?: JobPostingSalaryOmit<ExtArgs> | null
    /**
     * The data used to create many JobPostingSalaries.
     */
    data: JobPostingSalaryCreateManyInput | JobPostingSalaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingSalaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingSalary update
   */
  export type JobPostingSalaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingSalary
     */
    select?: JobPostingSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingSalary
     */
    omit?: JobPostingSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingSalaryInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPostingSalary.
     */
    data: XOR<JobPostingSalaryUpdateInput, JobPostingSalaryUncheckedUpdateInput>
    /**
     * Choose, which JobPostingSalary to update.
     */
    where: JobPostingSalaryWhereUniqueInput
  }

  /**
   * JobPostingSalary updateMany
   */
  export type JobPostingSalaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPostingSalaries.
     */
    data: XOR<JobPostingSalaryUpdateManyMutationInput, JobPostingSalaryUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingSalaries to update
     */
    where?: JobPostingSalaryWhereInput
    /**
     * Limit how many JobPostingSalaries to update.
     */
    limit?: number
  }

  /**
   * JobPostingSalary updateManyAndReturn
   */
  export type JobPostingSalaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingSalary
     */
    select?: JobPostingSalarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingSalary
     */
    omit?: JobPostingSalaryOmit<ExtArgs> | null
    /**
     * The data used to update JobPostingSalaries.
     */
    data: XOR<JobPostingSalaryUpdateManyMutationInput, JobPostingSalaryUncheckedUpdateManyInput>
    /**
     * Filter which JobPostingSalaries to update
     */
    where?: JobPostingSalaryWhereInput
    /**
     * Limit how many JobPostingSalaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingSalaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPostingSalary upsert
   */
  export type JobPostingSalaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingSalary
     */
    select?: JobPostingSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingSalary
     */
    omit?: JobPostingSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingSalaryInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPostingSalary to update in case it exists.
     */
    where: JobPostingSalaryWhereUniqueInput
    /**
     * In case the JobPostingSalary found by the `where` argument doesn't exist, create a new JobPostingSalary with this data.
     */
    create: XOR<JobPostingSalaryCreateInput, JobPostingSalaryUncheckedCreateInput>
    /**
     * In case the JobPostingSalary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPostingSalaryUpdateInput, JobPostingSalaryUncheckedUpdateInput>
  }

  /**
   * JobPostingSalary delete
   */
  export type JobPostingSalaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingSalary
     */
    select?: JobPostingSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingSalary
     */
    omit?: JobPostingSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingSalaryInclude<ExtArgs> | null
    /**
     * Filter which JobPostingSalary to delete.
     */
    where: JobPostingSalaryWhereUniqueInput
  }

  /**
   * JobPostingSalary deleteMany
   */
  export type JobPostingSalaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostingSalaries to delete
     */
    where?: JobPostingSalaryWhereInput
    /**
     * Limit how many JobPostingSalaries to delete.
     */
    limit?: number
  }

  /**
   * JobPostingSalary without action
   */
  export type JobPostingSalaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingSalary
     */
    select?: JobPostingSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPostingSalary
     */
    omit?: JobPostingSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingSalaryInclude<ExtArgs> | null
  }


  /**
   * Model CreatedJobPosting
   */

  export type AggregateCreatedJobPosting = {
    _count: CreatedJobPostingCountAggregateOutputType | null
    _min: CreatedJobPostingMinAggregateOutputType | null
    _max: CreatedJobPostingMaxAggregateOutputType | null
  }

  export type CreatedJobPostingMinAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    createdByType: $Enums.CreatedByEnum | null
    createdById: string | null
    source: $Enums.JobSourceEnum | null
    importedAt: Date | null
  }

  export type CreatedJobPostingMaxAggregateOutputType = {
    id: string | null
    jobPostingId: string | null
    createdByType: $Enums.CreatedByEnum | null
    createdById: string | null
    source: $Enums.JobSourceEnum | null
    importedAt: Date | null
  }

  export type CreatedJobPostingCountAggregateOutputType = {
    id: number
    jobPostingId: number
    createdByType: number
    createdById: number
    source: number
    importedAt: number
    _all: number
  }


  export type CreatedJobPostingMinAggregateInputType = {
    id?: true
    jobPostingId?: true
    createdByType?: true
    createdById?: true
    source?: true
    importedAt?: true
  }

  export type CreatedJobPostingMaxAggregateInputType = {
    id?: true
    jobPostingId?: true
    createdByType?: true
    createdById?: true
    source?: true
    importedAt?: true
  }

  export type CreatedJobPostingCountAggregateInputType = {
    id?: true
    jobPostingId?: true
    createdByType?: true
    createdById?: true
    source?: true
    importedAt?: true
    _all?: true
  }

  export type CreatedJobPostingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatedJobPosting to aggregate.
     */
    where?: CreatedJobPostingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatedJobPostings to fetch.
     */
    orderBy?: CreatedJobPostingOrderByWithRelationInput | CreatedJobPostingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatedJobPostingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` CreatedJobPostings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatedJobPostings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatedJobPostings
    **/
    _count?: true | CreatedJobPostingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatedJobPostingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatedJobPostingMaxAggregateInputType
  }

  export type GetCreatedJobPostingAggregateType<T extends CreatedJobPostingAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatedJobPosting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatedJobPosting[P]>
      : GetScalarType<T[P], AggregateCreatedJobPosting[P]>
  }




  export type CreatedJobPostingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatedJobPostingWhereInput
    orderBy?: CreatedJobPostingOrderByWithAggregationInput | CreatedJobPostingOrderByWithAggregationInput[]
    by: CreatedJobPostingScalarFieldEnum[] | CreatedJobPostingScalarFieldEnum
    having?: CreatedJobPostingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatedJobPostingCountAggregateInputType | true
    _min?: CreatedJobPostingMinAggregateInputType
    _max?: CreatedJobPostingMaxAggregateInputType
  }

  export type CreatedJobPostingGroupByOutputType = {
    id: string
    jobPostingId: string
    createdByType: $Enums.CreatedByEnum
    createdById: string | null
    source: $Enums.JobSourceEnum | null
    importedAt: Date | null
    _count: CreatedJobPostingCountAggregateOutputType | null
    _min: CreatedJobPostingMinAggregateOutputType | null
    _max: CreatedJobPostingMaxAggregateOutputType | null
  }

  type GetCreatedJobPostingGroupByPayload<T extends CreatedJobPostingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatedJobPostingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatedJobPostingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatedJobPostingGroupByOutputType[P]>
            : GetScalarType<T[P], CreatedJobPostingGroupByOutputType[P]>
        }
      >
    >


  export type CreatedJobPostingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    createdByType?: boolean
    createdById?: boolean
    source?: boolean
    importedAt?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
    createdBy?: boolean | CreatedJobPosting$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["createdJobPosting"]>

  export type CreatedJobPostingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    createdByType?: boolean
    createdById?: boolean
    source?: boolean
    importedAt?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
    createdBy?: boolean | CreatedJobPosting$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["createdJobPosting"]>

  export type CreatedJobPostingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobPostingId?: boolean
    createdByType?: boolean
    createdById?: boolean
    source?: boolean
    importedAt?: boolean
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
    createdBy?: boolean | CreatedJobPosting$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["createdJobPosting"]>

  export type CreatedJobPostingSelectScalar = {
    id?: boolean
    jobPostingId?: boolean
    createdByType?: boolean
    createdById?: boolean
    source?: boolean
    importedAt?: boolean
  }

  export type CreatedJobPostingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobPostingId" | "createdByType" | "createdById" | "source" | "importedAt", ExtArgs["result"]["createdJobPosting"]>
  export type CreatedJobPostingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
    createdBy?: boolean | CreatedJobPosting$createdByArgs<ExtArgs>
  }
  export type CreatedJobPostingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
    createdBy?: boolean | CreatedJobPosting$createdByArgs<ExtArgs>
  }
  export type CreatedJobPostingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
    createdBy?: boolean | CreatedJobPosting$createdByArgs<ExtArgs>
  }

  export type $CreatedJobPostingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreatedJobPosting"
    objects: {
      jobPosting: Prisma.$JobPostingPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobPostingId: string
      createdByType: $Enums.CreatedByEnum
      createdById: string | null
      source: $Enums.JobSourceEnum | null
      importedAt: Date | null
    }, ExtArgs["result"]["createdJobPosting"]>
    composites: {}
  }

  type CreatedJobPostingGetPayload<S extends boolean | null | undefined | CreatedJobPostingDefaultArgs> = $Result.GetResult<Prisma.$CreatedJobPostingPayload, S>

  type CreatedJobPostingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreatedJobPostingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreatedJobPostingCountAggregateInputType | true
    }

  export interface CreatedJobPostingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreatedJobPosting'], meta: { name: 'CreatedJobPosting' } }
    /**
     * Find zero or one CreatedJobPosting that matches the filter.
     * @param {CreatedJobPostingFindUniqueArgs} args - Arguments to find a CreatedJobPosting
     * @example
     * // Get one CreatedJobPosting
     * const createdJobPosting = await prisma.createdJobPosting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatedJobPostingFindUniqueArgs>(args: SelectSubset<T, CreatedJobPostingFindUniqueArgs<ExtArgs>>): Prisma__CreatedJobPostingClient<$Result.GetResult<Prisma.$CreatedJobPostingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreatedJobPosting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreatedJobPostingFindUniqueOrThrowArgs} args - Arguments to find a CreatedJobPosting
     * @example
     * // Get one CreatedJobPosting
     * const createdJobPosting = await prisma.createdJobPosting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatedJobPostingFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatedJobPostingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatedJobPostingClient<$Result.GetResult<Prisma.$CreatedJobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreatedJobPosting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatedJobPostingFindFirstArgs} args - Arguments to find a CreatedJobPosting
     * @example
     * // Get one CreatedJobPosting
     * const createdJobPosting = await prisma.createdJobPosting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatedJobPostingFindFirstArgs>(args?: SelectSubset<T, CreatedJobPostingFindFirstArgs<ExtArgs>>): Prisma__CreatedJobPostingClient<$Result.GetResult<Prisma.$CreatedJobPostingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreatedJobPosting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatedJobPostingFindFirstOrThrowArgs} args - Arguments to find a CreatedJobPosting
     * @example
     * // Get one CreatedJobPosting
     * const createdJobPosting = await prisma.createdJobPosting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatedJobPostingFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatedJobPostingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatedJobPostingClient<$Result.GetResult<Prisma.$CreatedJobPostingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreatedJobPostings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatedJobPostingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatedJobPostings
     * const createdJobPostings = await prisma.createdJobPosting.findMany()
     * 
     * // Get first 10 CreatedJobPostings
     * const createdJobPostings = await prisma.createdJobPosting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const createdJobPostingWithIdOnly = await prisma.createdJobPosting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatedJobPostingFindManyArgs>(args?: SelectSubset<T, CreatedJobPostingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatedJobPostingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreatedJobPosting.
     * @param {CreatedJobPostingCreateArgs} args - Arguments to create a CreatedJobPosting.
     * @example
     * // Create one CreatedJobPosting
     * const CreatedJobPosting = await prisma.createdJobPosting.create({
     *   data: {
     *     // ... data to create a CreatedJobPosting
     *   }
     * })
     * 
     */
    create<T extends CreatedJobPostingCreateArgs>(args: SelectSubset<T, CreatedJobPostingCreateArgs<ExtArgs>>): Prisma__CreatedJobPostingClient<$Result.GetResult<Prisma.$CreatedJobPostingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreatedJobPostings.
     * @param {CreatedJobPostingCreateManyArgs} args - Arguments to create many CreatedJobPostings.
     * @example
     * // Create many CreatedJobPostings
     * const createdJobPosting = await prisma.createdJobPosting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatedJobPostingCreateManyArgs>(args?: SelectSubset<T, CreatedJobPostingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreatedJobPostings and returns the data saved in the database.
     * @param {CreatedJobPostingCreateManyAndReturnArgs} args - Arguments to create many CreatedJobPostings.
     * @example
     * // Create many CreatedJobPostings
     * const createdJobPosting = await prisma.createdJobPosting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreatedJobPostings and only return the `id`
     * const createdJobPostingWithIdOnly = await prisma.createdJobPosting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatedJobPostingCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatedJobPostingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatedJobPostingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreatedJobPosting.
     * @param {CreatedJobPostingDeleteArgs} args - Arguments to delete one CreatedJobPosting.
     * @example
     * // Delete one CreatedJobPosting
     * const CreatedJobPosting = await prisma.createdJobPosting.delete({
     *   where: {
     *     // ... filter to delete one CreatedJobPosting
     *   }
     * })
     * 
     */
    delete<T extends CreatedJobPostingDeleteArgs>(args: SelectSubset<T, CreatedJobPostingDeleteArgs<ExtArgs>>): Prisma__CreatedJobPostingClient<$Result.GetResult<Prisma.$CreatedJobPostingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreatedJobPosting.
     * @param {CreatedJobPostingUpdateArgs} args - Arguments to update one CreatedJobPosting.
     * @example
     * // Update one CreatedJobPosting
     * const createdJobPosting = await prisma.createdJobPosting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatedJobPostingUpdateArgs>(args: SelectSubset<T, CreatedJobPostingUpdateArgs<ExtArgs>>): Prisma__CreatedJobPostingClient<$Result.GetResult<Prisma.$CreatedJobPostingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreatedJobPostings.
     * @param {CreatedJobPostingDeleteManyArgs} args - Arguments to filter CreatedJobPostings to delete.
     * @example
     * // Delete a few CreatedJobPostings
     * const { count } = await prisma.createdJobPosting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatedJobPostingDeleteManyArgs>(args?: SelectSubset<T, CreatedJobPostingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatedJobPostings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatedJobPostingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatedJobPostings
     * const createdJobPosting = await prisma.createdJobPosting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatedJobPostingUpdateManyArgs>(args: SelectSubset<T, CreatedJobPostingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatedJobPostings and returns the data updated in the database.
     * @param {CreatedJobPostingUpdateManyAndReturnArgs} args - Arguments to update many CreatedJobPostings.
     * @example
     * // Update many CreatedJobPostings
     * const createdJobPosting = await prisma.createdJobPosting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreatedJobPostings and only return the `id`
     * const createdJobPostingWithIdOnly = await prisma.createdJobPosting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreatedJobPostingUpdateManyAndReturnArgs>(args: SelectSubset<T, CreatedJobPostingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatedJobPostingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreatedJobPosting.
     * @param {CreatedJobPostingUpsertArgs} args - Arguments to update or create a CreatedJobPosting.
     * @example
     * // Update or create a CreatedJobPosting
     * const createdJobPosting = await prisma.createdJobPosting.upsert({
     *   create: {
     *     // ... data to create a CreatedJobPosting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatedJobPosting we want to update
     *   }
     * })
     */
    upsert<T extends CreatedJobPostingUpsertArgs>(args: SelectSubset<T, CreatedJobPostingUpsertArgs<ExtArgs>>): Prisma__CreatedJobPostingClient<$Result.GetResult<Prisma.$CreatedJobPostingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreatedJobPostings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatedJobPostingCountArgs} args - Arguments to filter CreatedJobPostings to count.
     * @example
     * // Count the number of CreatedJobPostings
     * const count = await prisma.createdJobPosting.count({
     *   where: {
     *     // ... the filter for the CreatedJobPostings we want to count
     *   }
     * })
    **/
    count<T extends CreatedJobPostingCountArgs>(
      args?: Subset<T, CreatedJobPostingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatedJobPostingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatedJobPosting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatedJobPostingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatedJobPostingAggregateArgs>(args: Subset<T, CreatedJobPostingAggregateArgs>): Prisma.PrismaPromise<GetCreatedJobPostingAggregateType<T>>

    /**
     * Group by CreatedJobPosting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatedJobPostingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatedJobPostingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatedJobPostingGroupByArgs['orderBy'] }
        : { orderBy?: CreatedJobPostingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatedJobPostingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatedJobPostingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreatedJobPosting model
   */
  readonly fields: CreatedJobPostingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatedJobPosting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatedJobPostingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobPosting<T extends JobPostingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostingDefaultArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends CreatedJobPosting$createdByArgs<ExtArgs> = {}>(args?: Subset<T, CreatedJobPosting$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreatedJobPosting model
   */
  interface CreatedJobPostingFieldRefs {
    readonly id: FieldRef<"CreatedJobPosting", 'String'>
    readonly jobPostingId: FieldRef<"CreatedJobPosting", 'String'>
    readonly createdByType: FieldRef<"CreatedJobPosting", 'CreatedByEnum'>
    readonly createdById: FieldRef<"CreatedJobPosting", 'String'>
    readonly source: FieldRef<"CreatedJobPosting", 'JobSourceEnum'>
    readonly importedAt: FieldRef<"CreatedJobPosting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreatedJobPosting findUnique
   */
  export type CreatedJobPostingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatedJobPosting
     */
    select?: CreatedJobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatedJobPosting
     */
    omit?: CreatedJobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatedJobPostingInclude<ExtArgs> | null
    /**
     * Filter, which CreatedJobPosting to fetch.
     */
    where: CreatedJobPostingWhereUniqueInput
  }

  /**
   * CreatedJobPosting findUniqueOrThrow
   */
  export type CreatedJobPostingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatedJobPosting
     */
    select?: CreatedJobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatedJobPosting
     */
    omit?: CreatedJobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatedJobPostingInclude<ExtArgs> | null
    /**
     * Filter, which CreatedJobPosting to fetch.
     */
    where: CreatedJobPostingWhereUniqueInput
  }

  /**
   * CreatedJobPosting findFirst
   */
  export type CreatedJobPostingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatedJobPosting
     */
    select?: CreatedJobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatedJobPosting
     */
    omit?: CreatedJobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatedJobPostingInclude<ExtArgs> | null
    /**
     * Filter, which CreatedJobPosting to fetch.
     */
    where?: CreatedJobPostingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatedJobPostings to fetch.
     */
    orderBy?: CreatedJobPostingOrderByWithRelationInput | CreatedJobPostingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatedJobPostings.
     */
    cursor?: CreatedJobPostingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` CreatedJobPostings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatedJobPostings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatedJobPostings.
     */
    distinct?: CreatedJobPostingScalarFieldEnum | CreatedJobPostingScalarFieldEnum[]
  }

  /**
   * CreatedJobPosting findFirstOrThrow
   */
  export type CreatedJobPostingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatedJobPosting
     */
    select?: CreatedJobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatedJobPosting
     */
    omit?: CreatedJobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatedJobPostingInclude<ExtArgs> | null
    /**
     * Filter, which CreatedJobPosting to fetch.
     */
    where?: CreatedJobPostingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatedJobPostings to fetch.
     */
    orderBy?: CreatedJobPostingOrderByWithRelationInput | CreatedJobPostingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatedJobPostings.
     */
    cursor?: CreatedJobPostingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` CreatedJobPostings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatedJobPostings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatedJobPostings.
     */
    distinct?: CreatedJobPostingScalarFieldEnum | CreatedJobPostingScalarFieldEnum[]
  }

  /**
   * CreatedJobPosting findMany
   */
  export type CreatedJobPostingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatedJobPosting
     */
    select?: CreatedJobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatedJobPosting
     */
    omit?: CreatedJobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatedJobPostingInclude<ExtArgs> | null
    /**
     * Filter, which CreatedJobPostings to fetch.
     */
    where?: CreatedJobPostingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatedJobPostings to fetch.
     */
    orderBy?: CreatedJobPostingOrderByWithRelationInput | CreatedJobPostingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatedJobPostings.
     */
    cursor?: CreatedJobPostingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` CreatedJobPostings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatedJobPostings.
     */
    skip?: number
    distinct?: CreatedJobPostingScalarFieldEnum | CreatedJobPostingScalarFieldEnum[]
  }

  /**
   * CreatedJobPosting create
   */
  export type CreatedJobPostingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatedJobPosting
     */
    select?: CreatedJobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatedJobPosting
     */
    omit?: CreatedJobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatedJobPostingInclude<ExtArgs> | null
    /**
     * The data needed to create a CreatedJobPosting.
     */
    data: XOR<CreatedJobPostingCreateInput, CreatedJobPostingUncheckedCreateInput>
  }

  /**
   * CreatedJobPosting createMany
   */
  export type CreatedJobPostingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreatedJobPostings.
     */
    data: CreatedJobPostingCreateManyInput | CreatedJobPostingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreatedJobPosting createManyAndReturn
   */
  export type CreatedJobPostingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatedJobPosting
     */
    select?: CreatedJobPostingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatedJobPosting
     */
    omit?: CreatedJobPostingOmit<ExtArgs> | null
    /**
     * The data used to create many CreatedJobPostings.
     */
    data: CreatedJobPostingCreateManyInput | CreatedJobPostingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatedJobPostingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatedJobPosting update
   */
  export type CreatedJobPostingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatedJobPosting
     */
    select?: CreatedJobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatedJobPosting
     */
    omit?: CreatedJobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatedJobPostingInclude<ExtArgs> | null
    /**
     * The data needed to update a CreatedJobPosting.
     */
    data: XOR<CreatedJobPostingUpdateInput, CreatedJobPostingUncheckedUpdateInput>
    /**
     * Choose, which CreatedJobPosting to update.
     */
    where: CreatedJobPostingWhereUniqueInput
  }

  /**
   * CreatedJobPosting updateMany
   */
  export type CreatedJobPostingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreatedJobPostings.
     */
    data: XOR<CreatedJobPostingUpdateManyMutationInput, CreatedJobPostingUncheckedUpdateManyInput>
    /**
     * Filter which CreatedJobPostings to update
     */
    where?: CreatedJobPostingWhereInput
    /**
     * Limit how many CreatedJobPostings to update.
     */
    limit?: number
  }

  /**
   * CreatedJobPosting updateManyAndReturn
   */
  export type CreatedJobPostingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatedJobPosting
     */
    select?: CreatedJobPostingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatedJobPosting
     */
    omit?: CreatedJobPostingOmit<ExtArgs> | null
    /**
     * The data used to update CreatedJobPostings.
     */
    data: XOR<CreatedJobPostingUpdateManyMutationInput, CreatedJobPostingUncheckedUpdateManyInput>
    /**
     * Filter which CreatedJobPostings to update
     */
    where?: CreatedJobPostingWhereInput
    /**
     * Limit how many CreatedJobPostings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatedJobPostingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatedJobPosting upsert
   */
  export type CreatedJobPostingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatedJobPosting
     */
    select?: CreatedJobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatedJobPosting
     */
    omit?: CreatedJobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatedJobPostingInclude<ExtArgs> | null
    /**
     * The filter to search for the CreatedJobPosting to update in case it exists.
     */
    where: CreatedJobPostingWhereUniqueInput
    /**
     * In case the CreatedJobPosting found by the `where` argument doesn't exist, create a new CreatedJobPosting with this data.
     */
    create: XOR<CreatedJobPostingCreateInput, CreatedJobPostingUncheckedCreateInput>
    /**
     * In case the CreatedJobPosting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatedJobPostingUpdateInput, CreatedJobPostingUncheckedUpdateInput>
  }

  /**
   * CreatedJobPosting delete
   */
  export type CreatedJobPostingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatedJobPosting
     */
    select?: CreatedJobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatedJobPosting
     */
    omit?: CreatedJobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatedJobPostingInclude<ExtArgs> | null
    /**
     * Filter which CreatedJobPosting to delete.
     */
    where: CreatedJobPostingWhereUniqueInput
  }

  /**
   * CreatedJobPosting deleteMany
   */
  export type CreatedJobPostingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatedJobPostings to delete
     */
    where?: CreatedJobPostingWhereInput
    /**
     * Limit how many CreatedJobPostings to delete.
     */
    limit?: number
  }

  /**
   * CreatedJobPosting.createdBy
   */
  export type CreatedJobPosting$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CreatedJobPosting without action
   */
  export type CreatedJobPostingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatedJobPosting
     */
    select?: CreatedJobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatedJobPosting
     */
    omit?: CreatedJobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatedJobPostingInclude<ExtArgs> | null
  }


  /**
   * Model JobApplicants
   */

  export type AggregateJobApplicants = {
    _count: JobApplicantsCountAggregateOutputType | null
    _min: JobApplicantsMinAggregateOutputType | null
    _max: JobApplicantsMaxAggregateOutputType | null
  }

  export type JobApplicantsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    jobPostingId: string | null
    status: string | null
    appliedAt: string | null
    gotJob: boolean | null
  }

  export type JobApplicantsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    jobPostingId: string | null
    status: string | null
    appliedAt: string | null
    gotJob: boolean | null
  }

  export type JobApplicantsCountAggregateOutputType = {
    id: number
    userId: number
    jobPostingId: number
    status: number
    appliedAt: number
    gotJob: number
    _all: number
  }


  export type JobApplicantsMinAggregateInputType = {
    id?: true
    userId?: true
    jobPostingId?: true
    status?: true
    appliedAt?: true
    gotJob?: true
  }

  export type JobApplicantsMaxAggregateInputType = {
    id?: true
    userId?: true
    jobPostingId?: true
    status?: true
    appliedAt?: true
    gotJob?: true
  }

  export type JobApplicantsCountAggregateInputType = {
    id?: true
    userId?: true
    jobPostingId?: true
    status?: true
    appliedAt?: true
    gotJob?: true
    _all?: true
  }

  export type JobApplicantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobApplicants to aggregate.
     */
    where?: JobApplicantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplicants to fetch.
     */
    orderBy?: JobApplicantsOrderByWithRelationInput | JobApplicantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobApplicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobApplicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobApplicants
    **/
    _count?: true | JobApplicantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobApplicantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobApplicantsMaxAggregateInputType
  }

  export type GetJobApplicantsAggregateType<T extends JobApplicantsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobApplicants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobApplicants[P]>
      : GetScalarType<T[P], AggregateJobApplicants[P]>
  }




  export type JobApplicantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicantsWhereInput
    orderBy?: JobApplicantsOrderByWithAggregationInput | JobApplicantsOrderByWithAggregationInput[]
    by: JobApplicantsScalarFieldEnum[] | JobApplicantsScalarFieldEnum
    having?: JobApplicantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobApplicantsCountAggregateInputType | true
    _min?: JobApplicantsMinAggregateInputType
    _max?: JobApplicantsMaxAggregateInputType
  }

  export type JobApplicantsGroupByOutputType = {
    id: string
    userId: string
    jobPostingId: string
    status: string
    appliedAt: string
    gotJob: boolean
    _count: JobApplicantsCountAggregateOutputType | null
    _min: JobApplicantsMinAggregateOutputType | null
    _max: JobApplicantsMaxAggregateOutputType | null
  }

  type GetJobApplicantsGroupByPayload<T extends JobApplicantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobApplicantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobApplicantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobApplicantsGroupByOutputType[P]>
            : GetScalarType<T[P], JobApplicantsGroupByOutputType[P]>
        }
      >
    >


  export type JobApplicantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    jobPostingId?: boolean
    status?: boolean
    appliedAt?: boolean
    gotJob?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplicants"]>

  export type JobApplicantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    jobPostingId?: boolean
    status?: boolean
    appliedAt?: boolean
    gotJob?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplicants"]>

  export type JobApplicantsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    jobPostingId?: boolean
    status?: boolean
    appliedAt?: boolean
    gotJob?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplicants"]>

  export type JobApplicantsSelectScalar = {
    id?: boolean
    userId?: boolean
    jobPostingId?: boolean
    status?: boolean
    appliedAt?: boolean
    gotJob?: boolean
  }

  export type JobApplicantsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "jobPostingId" | "status" | "appliedAt" | "gotJob", ExtArgs["result"]["jobApplicants"]>
  export type JobApplicantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobApplicantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type JobApplicantsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobPosting?: boolean | JobPostingDefaultArgs<ExtArgs>
  }

  export type $JobApplicantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobApplicants"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      jobPosting: Prisma.$JobPostingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      jobPostingId: string
      status: string
      appliedAt: string
      gotJob: boolean
    }, ExtArgs["result"]["jobApplicants"]>
    composites: {}
  }

  type JobApplicantsGetPayload<S extends boolean | null | undefined | JobApplicantsDefaultArgs> = $Result.GetResult<Prisma.$JobApplicantsPayload, S>

  type JobApplicantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobApplicantsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobApplicantsCountAggregateInputType | true
    }

  export interface JobApplicantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobApplicants'], meta: { name: 'JobApplicants' } }
    /**
     * Find zero or one JobApplicants that matches the filter.
     * @param {JobApplicantsFindUniqueArgs} args - Arguments to find a JobApplicants
     * @example
     * // Get one JobApplicants
     * const jobApplicants = await prisma.jobApplicants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobApplicantsFindUniqueArgs>(args: SelectSubset<T, JobApplicantsFindUniqueArgs<ExtArgs>>): Prisma__JobApplicantsClient<$Result.GetResult<Prisma.$JobApplicantsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobApplicants that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobApplicantsFindUniqueOrThrowArgs} args - Arguments to find a JobApplicants
     * @example
     * // Get one JobApplicants
     * const jobApplicants = await prisma.jobApplicants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobApplicantsFindUniqueOrThrowArgs>(args: SelectSubset<T, JobApplicantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobApplicantsClient<$Result.GetResult<Prisma.$JobApplicantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobApplicants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicantsFindFirstArgs} args - Arguments to find a JobApplicants
     * @example
     * // Get one JobApplicants
     * const jobApplicants = await prisma.jobApplicants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobApplicantsFindFirstArgs>(args?: SelectSubset<T, JobApplicantsFindFirstArgs<ExtArgs>>): Prisma__JobApplicantsClient<$Result.GetResult<Prisma.$JobApplicantsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobApplicants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicantsFindFirstOrThrowArgs} args - Arguments to find a JobApplicants
     * @example
     * // Get one JobApplicants
     * const jobApplicants = await prisma.jobApplicants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobApplicantsFindFirstOrThrowArgs>(args?: SelectSubset<T, JobApplicantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobApplicantsClient<$Result.GetResult<Prisma.$JobApplicantsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobApplicants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobApplicants
     * const jobApplicants = await prisma.jobApplicants.findMany()
     * 
     * // Get first 10 JobApplicants
     * const jobApplicants = await prisma.jobApplicants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobApplicantsWithIdOnly = await prisma.jobApplicants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobApplicantsFindManyArgs>(args?: SelectSubset<T, JobApplicantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobApplicants.
     * @param {JobApplicantsCreateArgs} args - Arguments to create a JobApplicants.
     * @example
     * // Create one JobApplicants
     * const JobApplicants = await prisma.jobApplicants.create({
     *   data: {
     *     // ... data to create a JobApplicants
     *   }
     * })
     * 
     */
    create<T extends JobApplicantsCreateArgs>(args: SelectSubset<T, JobApplicantsCreateArgs<ExtArgs>>): Prisma__JobApplicantsClient<$Result.GetResult<Prisma.$JobApplicantsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobApplicants.
     * @param {JobApplicantsCreateManyArgs} args - Arguments to create many JobApplicants.
     * @example
     * // Create many JobApplicants
     * const jobApplicants = await prisma.jobApplicants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobApplicantsCreateManyArgs>(args?: SelectSubset<T, JobApplicantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobApplicants and returns the data saved in the database.
     * @param {JobApplicantsCreateManyAndReturnArgs} args - Arguments to create many JobApplicants.
     * @example
     * // Create many JobApplicants
     * const jobApplicants = await prisma.jobApplicants.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobApplicants and only return the `id`
     * const jobApplicantsWithIdOnly = await prisma.jobApplicants.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobApplicantsCreateManyAndReturnArgs>(args?: SelectSubset<T, JobApplicantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicantsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobApplicants.
     * @param {JobApplicantsDeleteArgs} args - Arguments to delete one JobApplicants.
     * @example
     * // Delete one JobApplicants
     * const JobApplicants = await prisma.jobApplicants.delete({
     *   where: {
     *     // ... filter to delete one JobApplicants
     *   }
     * })
     * 
     */
    delete<T extends JobApplicantsDeleteArgs>(args: SelectSubset<T, JobApplicantsDeleteArgs<ExtArgs>>): Prisma__JobApplicantsClient<$Result.GetResult<Prisma.$JobApplicantsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobApplicants.
     * @param {JobApplicantsUpdateArgs} args - Arguments to update one JobApplicants.
     * @example
     * // Update one JobApplicants
     * const jobApplicants = await prisma.jobApplicants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobApplicantsUpdateArgs>(args: SelectSubset<T, JobApplicantsUpdateArgs<ExtArgs>>): Prisma__JobApplicantsClient<$Result.GetResult<Prisma.$JobApplicantsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobApplicants.
     * @param {JobApplicantsDeleteManyArgs} args - Arguments to filter JobApplicants to delete.
     * @example
     * // Delete a few JobApplicants
     * const { count } = await prisma.jobApplicants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobApplicantsDeleteManyArgs>(args?: SelectSubset<T, JobApplicantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobApplicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobApplicants
     * const jobApplicants = await prisma.jobApplicants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobApplicantsUpdateManyArgs>(args: SelectSubset<T, JobApplicantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobApplicants and returns the data updated in the database.
     * @param {JobApplicantsUpdateManyAndReturnArgs} args - Arguments to update many JobApplicants.
     * @example
     * // Update many JobApplicants
     * const jobApplicants = await prisma.jobApplicants.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobApplicants and only return the `id`
     * const jobApplicantsWithIdOnly = await prisma.jobApplicants.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobApplicantsUpdateManyAndReturnArgs>(args: SelectSubset<T, JobApplicantsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicantsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobApplicants.
     * @param {JobApplicantsUpsertArgs} args - Arguments to update or create a JobApplicants.
     * @example
     * // Update or create a JobApplicants
     * const jobApplicants = await prisma.jobApplicants.upsert({
     *   create: {
     *     // ... data to create a JobApplicants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobApplicants we want to update
     *   }
     * })
     */
    upsert<T extends JobApplicantsUpsertArgs>(args: SelectSubset<T, JobApplicantsUpsertArgs<ExtArgs>>): Prisma__JobApplicantsClient<$Result.GetResult<Prisma.$JobApplicantsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobApplicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicantsCountArgs} args - Arguments to filter JobApplicants to count.
     * @example
     * // Count the number of JobApplicants
     * const count = await prisma.jobApplicants.count({
     *   where: {
     *     // ... the filter for the JobApplicants we want to count
     *   }
     * })
    **/
    count<T extends JobApplicantsCountArgs>(
      args?: Subset<T, JobApplicantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobApplicantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobApplicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobApplicantsAggregateArgs>(args: Subset<T, JobApplicantsAggregateArgs>): Prisma.PrismaPromise<GetJobApplicantsAggregateType<T>>

    /**
     * Group by JobApplicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobApplicantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobApplicantsGroupByArgs['orderBy'] }
        : { orderBy?: JobApplicantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobApplicantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobApplicantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobApplicants model
   */
  readonly fields: JobApplicantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobApplicants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobApplicantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    jobPosting<T extends JobPostingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostingDefaultArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobApplicants model
   */
  interface JobApplicantsFieldRefs {
    readonly id: FieldRef<"JobApplicants", 'String'>
    readonly userId: FieldRef<"JobApplicants", 'String'>
    readonly jobPostingId: FieldRef<"JobApplicants", 'String'>
    readonly status: FieldRef<"JobApplicants", 'String'>
    readonly appliedAt: FieldRef<"JobApplicants", 'String'>
    readonly gotJob: FieldRef<"JobApplicants", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * JobApplicants findUnique
   */
  export type JobApplicantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicants
     */
    select?: JobApplicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicants
     */
    omit?: JobApplicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicantsInclude<ExtArgs> | null
    /**
     * Filter, which JobApplicants to fetch.
     */
    where: JobApplicantsWhereUniqueInput
  }

  /**
   * JobApplicants findUniqueOrThrow
   */
  export type JobApplicantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicants
     */
    select?: JobApplicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicants
     */
    omit?: JobApplicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicantsInclude<ExtArgs> | null
    /**
     * Filter, which JobApplicants to fetch.
     */
    where: JobApplicantsWhereUniqueInput
  }

  /**
   * JobApplicants findFirst
   */
  export type JobApplicantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicants
     */
    select?: JobApplicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicants
     */
    omit?: JobApplicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicantsInclude<ExtArgs> | null
    /**
     * Filter, which JobApplicants to fetch.
     */
    where?: JobApplicantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplicants to fetch.
     */
    orderBy?: JobApplicantsOrderByWithRelationInput | JobApplicantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobApplicants.
     */
    cursor?: JobApplicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobApplicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobApplicants.
     */
    distinct?: JobApplicantsScalarFieldEnum | JobApplicantsScalarFieldEnum[]
  }

  /**
   * JobApplicants findFirstOrThrow
   */
  export type JobApplicantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicants
     */
    select?: JobApplicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicants
     */
    omit?: JobApplicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicantsInclude<ExtArgs> | null
    /**
     * Filter, which JobApplicants to fetch.
     */
    where?: JobApplicantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplicants to fetch.
     */
    orderBy?: JobApplicantsOrderByWithRelationInput | JobApplicantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobApplicants.
     */
    cursor?: JobApplicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobApplicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobApplicants.
     */
    distinct?: JobApplicantsScalarFieldEnum | JobApplicantsScalarFieldEnum[]
  }

  /**
   * JobApplicants findMany
   */
  export type JobApplicantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicants
     */
    select?: JobApplicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicants
     */
    omit?: JobApplicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicantsInclude<ExtArgs> | null
    /**
     * Filter, which JobApplicants to fetch.
     */
    where?: JobApplicantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplicants to fetch.
     */
    orderBy?: JobApplicantsOrderByWithRelationInput | JobApplicantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobApplicants.
     */
    cursor?: JobApplicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` JobApplicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplicants.
     */
    skip?: number
    distinct?: JobApplicantsScalarFieldEnum | JobApplicantsScalarFieldEnum[]
  }

  /**
   * JobApplicants create
   */
  export type JobApplicantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicants
     */
    select?: JobApplicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicants
     */
    omit?: JobApplicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicantsInclude<ExtArgs> | null
    /**
     * The data needed to create a JobApplicants.
     */
    data: XOR<JobApplicantsCreateInput, JobApplicantsUncheckedCreateInput>
  }

  /**
   * JobApplicants createMany
   */
  export type JobApplicantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobApplicants.
     */
    data: JobApplicantsCreateManyInput | JobApplicantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobApplicants createManyAndReturn
   */
  export type JobApplicantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicants
     */
    select?: JobApplicantsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicants
     */
    omit?: JobApplicantsOmit<ExtArgs> | null
    /**
     * The data used to create many JobApplicants.
     */
    data: JobApplicantsCreateManyInput | JobApplicantsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicantsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobApplicants update
   */
  export type JobApplicantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicants
     */
    select?: JobApplicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicants
     */
    omit?: JobApplicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicantsInclude<ExtArgs> | null
    /**
     * The data needed to update a JobApplicants.
     */
    data: XOR<JobApplicantsUpdateInput, JobApplicantsUncheckedUpdateInput>
    /**
     * Choose, which JobApplicants to update.
     */
    where: JobApplicantsWhereUniqueInput
  }

  /**
   * JobApplicants updateMany
   */
  export type JobApplicantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobApplicants.
     */
    data: XOR<JobApplicantsUpdateManyMutationInput, JobApplicantsUncheckedUpdateManyInput>
    /**
     * Filter which JobApplicants to update
     */
    where?: JobApplicantsWhereInput
    /**
     * Limit how many JobApplicants to update.
     */
    limit?: number
  }

  /**
   * JobApplicants updateManyAndReturn
   */
  export type JobApplicantsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicants
     */
    select?: JobApplicantsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicants
     */
    omit?: JobApplicantsOmit<ExtArgs> | null
    /**
     * The data used to update JobApplicants.
     */
    data: XOR<JobApplicantsUpdateManyMutationInput, JobApplicantsUncheckedUpdateManyInput>
    /**
     * Filter which JobApplicants to update
     */
    where?: JobApplicantsWhereInput
    /**
     * Limit how many JobApplicants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicantsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobApplicants upsert
   */
  export type JobApplicantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicants
     */
    select?: JobApplicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicants
     */
    omit?: JobApplicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicantsInclude<ExtArgs> | null
    /**
     * The filter to search for the JobApplicants to update in case it exists.
     */
    where: JobApplicantsWhereUniqueInput
    /**
     * In case the JobApplicants found by the `where` argument doesn't exist, create a new JobApplicants with this data.
     */
    create: XOR<JobApplicantsCreateInput, JobApplicantsUncheckedCreateInput>
    /**
     * In case the JobApplicants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobApplicantsUpdateInput, JobApplicantsUncheckedUpdateInput>
  }

  /**
   * JobApplicants delete
   */
  export type JobApplicantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicants
     */
    select?: JobApplicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicants
     */
    omit?: JobApplicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicantsInclude<ExtArgs> | null
    /**
     * Filter which JobApplicants to delete.
     */
    where: JobApplicantsWhereUniqueInput
  }

  /**
   * JobApplicants deleteMany
   */
  export type JobApplicantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobApplicants to delete
     */
    where?: JobApplicantsWhereInput
    /**
     * Limit how many JobApplicants to delete.
     */
    limit?: number
  }

  /**
   * JobApplicants without action
   */
  export type JobApplicantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicants
     */
    select?: JobApplicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicants
     */
    omit?: JobApplicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicantsInclude<ExtArgs> | null
  }


  /**
   * Model UserProcess
   */

  export type AggregateUserProcess = {
    _count: UserProcessCountAggregateOutputType | null
    _min: UserProcessMinAggregateOutputType | null
    _max: UserProcessMaxAggregateOutputType | null
  }

  export type UserProcessMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.StatusUserJobProcesses | null
    startedAt: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: string | null
    jobPostingId: string | null
    processId: string | null
  }

  export type UserProcessMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.StatusUserJobProcesses | null
    startedAt: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: string | null
    jobPostingId: string | null
    processId: string | null
  }

  export type UserProcessCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    startedAt: number
    createdAt: number
    updatedAt: number
    completedAt: number
    jobPostingId: number
    processId: number
    _all: number
  }


  export type UserProcessMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    startedAt?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    jobPostingId?: true
    processId?: true
  }

  export type UserProcessMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    startedAt?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    jobPostingId?: true
    processId?: true
  }

  export type UserProcessCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    startedAt?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    jobPostingId?: true
    processId?: true
    _all?: true
  }

  export type UserProcessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProcess to aggregate.
     */
    where?: UserProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProcesses to fetch.
     */
    orderBy?: UserProcessOrderByWithRelationInput | UserProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProcesses
    **/
    _count?: true | UserProcessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProcessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProcessMaxAggregateInputType
  }

  export type GetUserProcessAggregateType<T extends UserProcessAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProcess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProcess[P]>
      : GetScalarType<T[P], AggregateUserProcess[P]>
  }




  export type UserProcessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProcessWhereInput
    orderBy?: UserProcessOrderByWithAggregationInput | UserProcessOrderByWithAggregationInput[]
    by: UserProcessScalarFieldEnum[] | UserProcessScalarFieldEnum
    having?: UserProcessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProcessCountAggregateInputType | true
    _min?: UserProcessMinAggregateInputType
    _max?: UserProcessMaxAggregateInputType
  }

  export type UserProcessGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.StatusUserJobProcesses
    startedAt: string | null
    createdAt: Date
    updatedAt: Date
    completedAt: string | null
    jobPostingId: string
    processId: string | null
    _count: UserProcessCountAggregateOutputType | null
    _min: UserProcessMinAggregateOutputType | null
    _max: UserProcessMaxAggregateOutputType | null
  }

  type GetUserProcessGroupByPayload<T extends UserProcessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProcessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProcessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProcessGroupByOutputType[P]>
            : GetScalarType<T[P], UserProcessGroupByOutputType[P]>
        }
      >
    >


  export type UserProcessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    startedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    jobPostingId?: boolean
    processId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    steps?: boolean | UserProcess$stepsArgs<ExtArgs>
    jobPosting?: boolean | UserProcess$jobPostingArgs<ExtArgs>
    process?: boolean | UserProcess$processArgs<ExtArgs>
    todos?: boolean | UserProcess$todosArgs<ExtArgs>
    _count?: boolean | UserProcessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProcess"]>

  export type UserProcessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    startedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    jobPostingId?: boolean
    processId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobPosting?: boolean | UserProcess$jobPostingArgs<ExtArgs>
    process?: boolean | UserProcess$processArgs<ExtArgs>
  }, ExtArgs["result"]["userProcess"]>

  export type UserProcessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    startedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    jobPostingId?: boolean
    processId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobPosting?: boolean | UserProcess$jobPostingArgs<ExtArgs>
    process?: boolean | UserProcess$processArgs<ExtArgs>
  }, ExtArgs["result"]["userProcess"]>

  export type UserProcessSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    startedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    jobPostingId?: boolean
    processId?: boolean
  }

  export type UserProcessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "startedAt" | "createdAt" | "updatedAt" | "completedAt" | "jobPostingId" | "processId", ExtArgs["result"]["userProcess"]>
  export type UserProcessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    steps?: boolean | UserProcess$stepsArgs<ExtArgs>
    jobPosting?: boolean | UserProcess$jobPostingArgs<ExtArgs>
    process?: boolean | UserProcess$processArgs<ExtArgs>
    todos?: boolean | UserProcess$todosArgs<ExtArgs>
    _count?: boolean | UserProcessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserProcessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobPosting?: boolean | UserProcess$jobPostingArgs<ExtArgs>
    process?: boolean | UserProcess$processArgs<ExtArgs>
  }
  export type UserProcessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobPosting?: boolean | UserProcess$jobPostingArgs<ExtArgs>
    process?: boolean | UserProcess$processArgs<ExtArgs>
  }

  export type $UserProcessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProcess"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      steps: Prisma.$UserProcessStepPayload<ExtArgs>[]
      jobPosting: Prisma.$JobPostingPayload<ExtArgs> | null
      process: Prisma.$ProcessPayload<ExtArgs> | null
      todos: Prisma.$TodoUserProcessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.StatusUserJobProcesses
      startedAt: string | null
      createdAt: Date
      updatedAt: Date
      completedAt: string | null
      jobPostingId: string
      processId: string | null
    }, ExtArgs["result"]["userProcess"]>
    composites: {}
  }

  type UserProcessGetPayload<S extends boolean | null | undefined | UserProcessDefaultArgs> = $Result.GetResult<Prisma.$UserProcessPayload, S>

  type UserProcessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProcessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProcessCountAggregateInputType | true
    }

  export interface UserProcessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProcess'], meta: { name: 'UserProcess' } }
    /**
     * Find zero or one UserProcess that matches the filter.
     * @param {UserProcessFindUniqueArgs} args - Arguments to find a UserProcess
     * @example
     * // Get one UserProcess
     * const userProcess = await prisma.userProcess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProcessFindUniqueArgs>(args: SelectSubset<T, UserProcessFindUniqueArgs<ExtArgs>>): Prisma__UserProcessClient<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProcess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProcessFindUniqueOrThrowArgs} args - Arguments to find a UserProcess
     * @example
     * // Get one UserProcess
     * const userProcess = await prisma.userProcess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProcessFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProcessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProcessClient<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProcess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProcessFindFirstArgs} args - Arguments to find a UserProcess
     * @example
     * // Get one UserProcess
     * const userProcess = await prisma.userProcess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProcessFindFirstArgs>(args?: SelectSubset<T, UserProcessFindFirstArgs<ExtArgs>>): Prisma__UserProcessClient<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProcess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProcessFindFirstOrThrowArgs} args - Arguments to find a UserProcess
     * @example
     * // Get one UserProcess
     * const userProcess = await prisma.userProcess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProcessFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProcessFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProcessClient<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProcesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProcessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProcesses
     * const userProcesses = await prisma.userProcess.findMany()
     * 
     * // Get first 10 UserProcesses
     * const userProcesses = await prisma.userProcess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProcessWithIdOnly = await prisma.userProcess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProcessFindManyArgs>(args?: SelectSubset<T, UserProcessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProcess.
     * @param {UserProcessCreateArgs} args - Arguments to create a UserProcess.
     * @example
     * // Create one UserProcess
     * const UserProcess = await prisma.userProcess.create({
     *   data: {
     *     // ... data to create a UserProcess
     *   }
     * })
     * 
     */
    create<T extends UserProcessCreateArgs>(args: SelectSubset<T, UserProcessCreateArgs<ExtArgs>>): Prisma__UserProcessClient<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProcesses.
     * @param {UserProcessCreateManyArgs} args - Arguments to create many UserProcesses.
     * @example
     * // Create many UserProcesses
     * const userProcess = await prisma.userProcess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProcessCreateManyArgs>(args?: SelectSubset<T, UserProcessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProcesses and returns the data saved in the database.
     * @param {UserProcessCreateManyAndReturnArgs} args - Arguments to create many UserProcesses.
     * @example
     * // Create many UserProcesses
     * const userProcess = await prisma.userProcess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProcesses and only return the `id`
     * const userProcessWithIdOnly = await prisma.userProcess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProcessCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProcessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProcess.
     * @param {UserProcessDeleteArgs} args - Arguments to delete one UserProcess.
     * @example
     * // Delete one UserProcess
     * const UserProcess = await prisma.userProcess.delete({
     *   where: {
     *     // ... filter to delete one UserProcess
     *   }
     * })
     * 
     */
    delete<T extends UserProcessDeleteArgs>(args: SelectSubset<T, UserProcessDeleteArgs<ExtArgs>>): Prisma__UserProcessClient<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProcess.
     * @param {UserProcessUpdateArgs} args - Arguments to update one UserProcess.
     * @example
     * // Update one UserProcess
     * const userProcess = await prisma.userProcess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProcessUpdateArgs>(args: SelectSubset<T, UserProcessUpdateArgs<ExtArgs>>): Prisma__UserProcessClient<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProcesses.
     * @param {UserProcessDeleteManyArgs} args - Arguments to filter UserProcesses to delete.
     * @example
     * // Delete a few UserProcesses
     * const { count } = await prisma.userProcess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProcessDeleteManyArgs>(args?: SelectSubset<T, UserProcessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProcessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProcesses
     * const userProcess = await prisma.userProcess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProcessUpdateManyArgs>(args: SelectSubset<T, UserProcessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProcesses and returns the data updated in the database.
     * @param {UserProcessUpdateManyAndReturnArgs} args - Arguments to update many UserProcesses.
     * @example
     * // Update many UserProcesses
     * const userProcess = await prisma.userProcess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProcesses and only return the `id`
     * const userProcessWithIdOnly = await prisma.userProcess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProcessUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProcessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProcess.
     * @param {UserProcessUpsertArgs} args - Arguments to update or create a UserProcess.
     * @example
     * // Update or create a UserProcess
     * const userProcess = await prisma.userProcess.upsert({
     *   create: {
     *     // ... data to create a UserProcess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProcess we want to update
     *   }
     * })
     */
    upsert<T extends UserProcessUpsertArgs>(args: SelectSubset<T, UserProcessUpsertArgs<ExtArgs>>): Prisma__UserProcessClient<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProcessCountArgs} args - Arguments to filter UserProcesses to count.
     * @example
     * // Count the number of UserProcesses
     * const count = await prisma.userProcess.count({
     *   where: {
     *     // ... the filter for the UserProcesses we want to count
     *   }
     * })
    **/
    count<T extends UserProcessCountArgs>(
      args?: Subset<T, UserProcessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProcessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProcess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProcessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProcessAggregateArgs>(args: Subset<T, UserProcessAggregateArgs>): Prisma.PrismaPromise<GetUserProcessAggregateType<T>>

    /**
     * Group by UserProcess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProcessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProcessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProcessGroupByArgs['orderBy'] }
        : { orderBy?: UserProcessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProcessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProcessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProcess model
   */
  readonly fields: UserProcessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProcess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProcessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    steps<T extends UserProcess$stepsArgs<ExtArgs> = {}>(args?: Subset<T, UserProcess$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProcessStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobPosting<T extends UserProcess$jobPostingArgs<ExtArgs> = {}>(args?: Subset<T, UserProcess$jobPostingArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    process<T extends UserProcess$processArgs<ExtArgs> = {}>(args?: Subset<T, UserProcess$processArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    todos<T extends UserProcess$todosArgs<ExtArgs> = {}>(args?: Subset<T, UserProcess$todosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoUserProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProcess model
   */
  interface UserProcessFieldRefs {
    readonly id: FieldRef<"UserProcess", 'String'>
    readonly userId: FieldRef<"UserProcess", 'String'>
    readonly status: FieldRef<"UserProcess", 'StatusUserJobProcesses'>
    readonly startedAt: FieldRef<"UserProcess", 'String'>
    readonly createdAt: FieldRef<"UserProcess", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProcess", 'DateTime'>
    readonly completedAt: FieldRef<"UserProcess", 'String'>
    readonly jobPostingId: FieldRef<"UserProcess", 'String'>
    readonly processId: FieldRef<"UserProcess", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserProcess findUnique
   */
  export type UserProcessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessInclude<ExtArgs> | null
    /**
     * Filter, which UserProcess to fetch.
     */
    where: UserProcessWhereUniqueInput
  }

  /**
   * UserProcess findUniqueOrThrow
   */
  export type UserProcessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessInclude<ExtArgs> | null
    /**
     * Filter, which UserProcess to fetch.
     */
    where: UserProcessWhereUniqueInput
  }

  /**
   * UserProcess findFirst
   */
  export type UserProcessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessInclude<ExtArgs> | null
    /**
     * Filter, which UserProcess to fetch.
     */
    where?: UserProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProcesses to fetch.
     */
    orderBy?: UserProcessOrderByWithRelationInput | UserProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProcesses.
     */
    cursor?: UserProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProcesses.
     */
    distinct?: UserProcessScalarFieldEnum | UserProcessScalarFieldEnum[]
  }

  /**
   * UserProcess findFirstOrThrow
   */
  export type UserProcessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessInclude<ExtArgs> | null
    /**
     * Filter, which UserProcess to fetch.
     */
    where?: UserProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProcesses to fetch.
     */
    orderBy?: UserProcessOrderByWithRelationInput | UserProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProcesses.
     */
    cursor?: UserProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProcesses.
     */
    distinct?: UserProcessScalarFieldEnum | UserProcessScalarFieldEnum[]
  }

  /**
   * UserProcess findMany
   */
  export type UserProcessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessInclude<ExtArgs> | null
    /**
     * Filter, which UserProcesses to fetch.
     */
    where?: UserProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProcesses to fetch.
     */
    orderBy?: UserProcessOrderByWithRelationInput | UserProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProcesses.
     */
    cursor?: UserProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProcesses.
     */
    skip?: number
    distinct?: UserProcessScalarFieldEnum | UserProcessScalarFieldEnum[]
  }

  /**
   * UserProcess create
   */
  export type UserProcessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProcess.
     */
    data: XOR<UserProcessCreateInput, UserProcessUncheckedCreateInput>
  }

  /**
   * UserProcess createMany
   */
  export type UserProcessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProcesses.
     */
    data: UserProcessCreateManyInput | UserProcessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProcess createManyAndReturn
   */
  export type UserProcessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * The data used to create many UserProcesses.
     */
    data: UserProcessCreateManyInput | UserProcessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProcess update
   */
  export type UserProcessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProcess.
     */
    data: XOR<UserProcessUpdateInput, UserProcessUncheckedUpdateInput>
    /**
     * Choose, which UserProcess to update.
     */
    where: UserProcessWhereUniqueInput
  }

  /**
   * UserProcess updateMany
   */
  export type UserProcessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProcesses.
     */
    data: XOR<UserProcessUpdateManyMutationInput, UserProcessUncheckedUpdateManyInput>
    /**
     * Filter which UserProcesses to update
     */
    where?: UserProcessWhereInput
    /**
     * Limit how many UserProcesses to update.
     */
    limit?: number
  }

  /**
   * UserProcess updateManyAndReturn
   */
  export type UserProcessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * The data used to update UserProcesses.
     */
    data: XOR<UserProcessUpdateManyMutationInput, UserProcessUncheckedUpdateManyInput>
    /**
     * Filter which UserProcesses to update
     */
    where?: UserProcessWhereInput
    /**
     * Limit how many UserProcesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProcess upsert
   */
  export type UserProcessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProcess to update in case it exists.
     */
    where: UserProcessWhereUniqueInput
    /**
     * In case the UserProcess found by the `where` argument doesn't exist, create a new UserProcess with this data.
     */
    create: XOR<UserProcessCreateInput, UserProcessUncheckedCreateInput>
    /**
     * In case the UserProcess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProcessUpdateInput, UserProcessUncheckedUpdateInput>
  }

  /**
   * UserProcess delete
   */
  export type UserProcessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessInclude<ExtArgs> | null
    /**
     * Filter which UserProcess to delete.
     */
    where: UserProcessWhereUniqueInput
  }

  /**
   * UserProcess deleteMany
   */
  export type UserProcessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProcesses to delete
     */
    where?: UserProcessWhereInput
    /**
     * Limit how many UserProcesses to delete.
     */
    limit?: number
  }

  /**
   * UserProcess.steps
   */
  export type UserProcess$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStep
     */
    select?: UserProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcessStep
     */
    omit?: UserProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessStepInclude<ExtArgs> | null
    where?: UserProcessStepWhereInput
    orderBy?: UserProcessStepOrderByWithRelationInput | UserProcessStepOrderByWithRelationInput[]
    cursor?: UserProcessStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProcessStepScalarFieldEnum | UserProcessStepScalarFieldEnum[]
  }

  /**
   * UserProcess.jobPosting
   */
  export type UserProcess$jobPostingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    where?: JobPostingWhereInput
  }

  /**
   * UserProcess.process
   */
  export type UserProcess$processArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
  }

  /**
   * UserProcess.todos
   */
  export type UserProcess$todosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoUserProcess
     */
    select?: TodoUserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoUserProcess
     */
    omit?: TodoUserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoUserProcessInclude<ExtArgs> | null
    where?: TodoUserProcessWhereInput
    orderBy?: TodoUserProcessOrderByWithRelationInput | TodoUserProcessOrderByWithRelationInput[]
    cursor?: TodoUserProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TodoUserProcessScalarFieldEnum | TodoUserProcessScalarFieldEnum[]
  }

  /**
   * UserProcess without action
   */
  export type UserProcessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessInclude<ExtArgs> | null
  }


  /**
   * Model UserProcessStep
   */

  export type AggregateUserProcessStep = {
    _count: UserProcessStepCountAggregateOutputType | null
    _min: UserProcessStepMinAggregateOutputType | null
    _max: UserProcessStepMaxAggregateOutputType | null
  }

  export type UserProcessStepMinAggregateOutputType = {
    id: string | null
    userProcessId: string | null
    stepId: string | null
    isExecuted: boolean | null
    executedAt: string | null
  }

  export type UserProcessStepMaxAggregateOutputType = {
    id: string | null
    userProcessId: string | null
    stepId: string | null
    isExecuted: boolean | null
    executedAt: string | null
  }

  export type UserProcessStepCountAggregateOutputType = {
    id: number
    userProcessId: number
    stepId: number
    isExecuted: number
    executedAt: number
    _all: number
  }


  export type UserProcessStepMinAggregateInputType = {
    id?: true
    userProcessId?: true
    stepId?: true
    isExecuted?: true
    executedAt?: true
  }

  export type UserProcessStepMaxAggregateInputType = {
    id?: true
    userProcessId?: true
    stepId?: true
    isExecuted?: true
    executedAt?: true
  }

  export type UserProcessStepCountAggregateInputType = {
    id?: true
    userProcessId?: true
    stepId?: true
    isExecuted?: true
    executedAt?: true
    _all?: true
  }

  export type UserProcessStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProcessStep to aggregate.
     */
    where?: UserProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProcessSteps to fetch.
     */
    orderBy?: UserProcessStepOrderByWithRelationInput | UserProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProcessSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProcessSteps
    **/
    _count?: true | UserProcessStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProcessStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProcessStepMaxAggregateInputType
  }

  export type GetUserProcessStepAggregateType<T extends UserProcessStepAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProcessStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProcessStep[P]>
      : GetScalarType<T[P], AggregateUserProcessStep[P]>
  }




  export type UserProcessStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProcessStepWhereInput
    orderBy?: UserProcessStepOrderByWithAggregationInput | UserProcessStepOrderByWithAggregationInput[]
    by: UserProcessStepScalarFieldEnum[] | UserProcessStepScalarFieldEnum
    having?: UserProcessStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProcessStepCountAggregateInputType | true
    _min?: UserProcessStepMinAggregateInputType
    _max?: UserProcessStepMaxAggregateInputType
  }

  export type UserProcessStepGroupByOutputType = {
    id: string
    userProcessId: string
    stepId: string | null
    isExecuted: boolean
    executedAt: string | null
    _count: UserProcessStepCountAggregateOutputType | null
    _min: UserProcessStepMinAggregateOutputType | null
    _max: UserProcessStepMaxAggregateOutputType | null
  }

  type GetUserProcessStepGroupByPayload<T extends UserProcessStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProcessStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProcessStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProcessStepGroupByOutputType[P]>
            : GetScalarType<T[P], UserProcessStepGroupByOutputType[P]>
        }
      >
    >


  export type UserProcessStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProcessId?: boolean
    stepId?: boolean
    isExecuted?: boolean
    executedAt?: boolean
    comments?: boolean | UserProcessStep$commentsArgs<ExtArgs>
    process?: boolean | UserProcessDefaultArgs<ExtArgs>
    step?: boolean | UserProcessStep$stepArgs<ExtArgs>
    _count?: boolean | UserProcessStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProcessStep"]>

  export type UserProcessStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProcessId?: boolean
    stepId?: boolean
    isExecuted?: boolean
    executedAt?: boolean
    process?: boolean | UserProcessDefaultArgs<ExtArgs>
    step?: boolean | UserProcessStep$stepArgs<ExtArgs>
  }, ExtArgs["result"]["userProcessStep"]>

  export type UserProcessStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProcessId?: boolean
    stepId?: boolean
    isExecuted?: boolean
    executedAt?: boolean
    process?: boolean | UserProcessDefaultArgs<ExtArgs>
    step?: boolean | UserProcessStep$stepArgs<ExtArgs>
  }, ExtArgs["result"]["userProcessStep"]>

  export type UserProcessStepSelectScalar = {
    id?: boolean
    userProcessId?: boolean
    stepId?: boolean
    isExecuted?: boolean
    executedAt?: boolean
  }

  export type UserProcessStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProcessId" | "stepId" | "isExecuted" | "executedAt", ExtArgs["result"]["userProcessStep"]>
  export type UserProcessStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | UserProcessStep$commentsArgs<ExtArgs>
    process?: boolean | UserProcessDefaultArgs<ExtArgs>
    step?: boolean | UserProcessStep$stepArgs<ExtArgs>
    _count?: boolean | UserProcessStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserProcessStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | UserProcessDefaultArgs<ExtArgs>
    step?: boolean | UserProcessStep$stepArgs<ExtArgs>
  }
  export type UserProcessStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | UserProcessDefaultArgs<ExtArgs>
    step?: boolean | UserProcessStep$stepArgs<ExtArgs>
  }

  export type $UserProcessStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProcessStep"
    objects: {
      comments: Prisma.$UserPipelineStepCommentPayload<ExtArgs>[]
      process: Prisma.$UserProcessPayload<ExtArgs>
      step: Prisma.$ProcessStepPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProcessId: string
      stepId: string | null
      isExecuted: boolean
      executedAt: string | null
    }, ExtArgs["result"]["userProcessStep"]>
    composites: {}
  }

  type UserProcessStepGetPayload<S extends boolean | null | undefined | UserProcessStepDefaultArgs> = $Result.GetResult<Prisma.$UserProcessStepPayload, S>

  type UserProcessStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProcessStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProcessStepCountAggregateInputType | true
    }

  export interface UserProcessStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProcessStep'], meta: { name: 'UserProcessStep' } }
    /**
     * Find zero or one UserProcessStep that matches the filter.
     * @param {UserProcessStepFindUniqueArgs} args - Arguments to find a UserProcessStep
     * @example
     * // Get one UserProcessStep
     * const userProcessStep = await prisma.userProcessStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProcessStepFindUniqueArgs>(args: SelectSubset<T, UserProcessStepFindUniqueArgs<ExtArgs>>): Prisma__UserProcessStepClient<$Result.GetResult<Prisma.$UserProcessStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProcessStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProcessStepFindUniqueOrThrowArgs} args - Arguments to find a UserProcessStep
     * @example
     * // Get one UserProcessStep
     * const userProcessStep = await prisma.userProcessStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProcessStepFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProcessStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProcessStepClient<$Result.GetResult<Prisma.$UserProcessStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProcessStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProcessStepFindFirstArgs} args - Arguments to find a UserProcessStep
     * @example
     * // Get one UserProcessStep
     * const userProcessStep = await prisma.userProcessStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProcessStepFindFirstArgs>(args?: SelectSubset<T, UserProcessStepFindFirstArgs<ExtArgs>>): Prisma__UserProcessStepClient<$Result.GetResult<Prisma.$UserProcessStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProcessStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProcessStepFindFirstOrThrowArgs} args - Arguments to find a UserProcessStep
     * @example
     * // Get one UserProcessStep
     * const userProcessStep = await prisma.userProcessStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProcessStepFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProcessStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProcessStepClient<$Result.GetResult<Prisma.$UserProcessStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProcessSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProcessStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProcessSteps
     * const userProcessSteps = await prisma.userProcessStep.findMany()
     * 
     * // Get first 10 UserProcessSteps
     * const userProcessSteps = await prisma.userProcessStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProcessStepWithIdOnly = await prisma.userProcessStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProcessStepFindManyArgs>(args?: SelectSubset<T, UserProcessStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProcessStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProcessStep.
     * @param {UserProcessStepCreateArgs} args - Arguments to create a UserProcessStep.
     * @example
     * // Create one UserProcessStep
     * const UserProcessStep = await prisma.userProcessStep.create({
     *   data: {
     *     // ... data to create a UserProcessStep
     *   }
     * })
     * 
     */
    create<T extends UserProcessStepCreateArgs>(args: SelectSubset<T, UserProcessStepCreateArgs<ExtArgs>>): Prisma__UserProcessStepClient<$Result.GetResult<Prisma.$UserProcessStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProcessSteps.
     * @param {UserProcessStepCreateManyArgs} args - Arguments to create many UserProcessSteps.
     * @example
     * // Create many UserProcessSteps
     * const userProcessStep = await prisma.userProcessStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProcessStepCreateManyArgs>(args?: SelectSubset<T, UserProcessStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProcessSteps and returns the data saved in the database.
     * @param {UserProcessStepCreateManyAndReturnArgs} args - Arguments to create many UserProcessSteps.
     * @example
     * // Create many UserProcessSteps
     * const userProcessStep = await prisma.userProcessStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProcessSteps and only return the `id`
     * const userProcessStepWithIdOnly = await prisma.userProcessStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProcessStepCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProcessStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProcessStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProcessStep.
     * @param {UserProcessStepDeleteArgs} args - Arguments to delete one UserProcessStep.
     * @example
     * // Delete one UserProcessStep
     * const UserProcessStep = await prisma.userProcessStep.delete({
     *   where: {
     *     // ... filter to delete one UserProcessStep
     *   }
     * })
     * 
     */
    delete<T extends UserProcessStepDeleteArgs>(args: SelectSubset<T, UserProcessStepDeleteArgs<ExtArgs>>): Prisma__UserProcessStepClient<$Result.GetResult<Prisma.$UserProcessStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProcessStep.
     * @param {UserProcessStepUpdateArgs} args - Arguments to update one UserProcessStep.
     * @example
     * // Update one UserProcessStep
     * const userProcessStep = await prisma.userProcessStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProcessStepUpdateArgs>(args: SelectSubset<T, UserProcessStepUpdateArgs<ExtArgs>>): Prisma__UserProcessStepClient<$Result.GetResult<Prisma.$UserProcessStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProcessSteps.
     * @param {UserProcessStepDeleteManyArgs} args - Arguments to filter UserProcessSteps to delete.
     * @example
     * // Delete a few UserProcessSteps
     * const { count } = await prisma.userProcessStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProcessStepDeleteManyArgs>(args?: SelectSubset<T, UserProcessStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProcessSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProcessStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProcessSteps
     * const userProcessStep = await prisma.userProcessStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProcessStepUpdateManyArgs>(args: SelectSubset<T, UserProcessStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProcessSteps and returns the data updated in the database.
     * @param {UserProcessStepUpdateManyAndReturnArgs} args - Arguments to update many UserProcessSteps.
     * @example
     * // Update many UserProcessSteps
     * const userProcessStep = await prisma.userProcessStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProcessSteps and only return the `id`
     * const userProcessStepWithIdOnly = await prisma.userProcessStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProcessStepUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProcessStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProcessStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProcessStep.
     * @param {UserProcessStepUpsertArgs} args - Arguments to update or create a UserProcessStep.
     * @example
     * // Update or create a UserProcessStep
     * const userProcessStep = await prisma.userProcessStep.upsert({
     *   create: {
     *     // ... data to create a UserProcessStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProcessStep we want to update
     *   }
     * })
     */
    upsert<T extends UserProcessStepUpsertArgs>(args: SelectSubset<T, UserProcessStepUpsertArgs<ExtArgs>>): Prisma__UserProcessStepClient<$Result.GetResult<Prisma.$UserProcessStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProcessSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProcessStepCountArgs} args - Arguments to filter UserProcessSteps to count.
     * @example
     * // Count the number of UserProcessSteps
     * const count = await prisma.userProcessStep.count({
     *   where: {
     *     // ... the filter for the UserProcessSteps we want to count
     *   }
     * })
    **/
    count<T extends UserProcessStepCountArgs>(
      args?: Subset<T, UserProcessStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProcessStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProcessStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProcessStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProcessStepAggregateArgs>(args: Subset<T, UserProcessStepAggregateArgs>): Prisma.PrismaPromise<GetUserProcessStepAggregateType<T>>

    /**
     * Group by UserProcessStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProcessStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProcessStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProcessStepGroupByArgs['orderBy'] }
        : { orderBy?: UserProcessStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProcessStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProcessStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProcessStep model
   */
  readonly fields: UserProcessStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProcessStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProcessStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends UserProcessStep$commentsArgs<ExtArgs> = {}>(args?: Subset<T, UserProcessStep$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPipelineStepCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    process<T extends UserProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProcessDefaultArgs<ExtArgs>>): Prisma__UserProcessClient<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    step<T extends UserProcessStep$stepArgs<ExtArgs> = {}>(args?: Subset<T, UserProcessStep$stepArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProcessStep model
   */
  interface UserProcessStepFieldRefs {
    readonly id: FieldRef<"UserProcessStep", 'String'>
    readonly userProcessId: FieldRef<"UserProcessStep", 'String'>
    readonly stepId: FieldRef<"UserProcessStep", 'String'>
    readonly isExecuted: FieldRef<"UserProcessStep", 'Boolean'>
    readonly executedAt: FieldRef<"UserProcessStep", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserProcessStep findUnique
   */
  export type UserProcessStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStep
     */
    select?: UserProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcessStep
     */
    omit?: UserProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which UserProcessStep to fetch.
     */
    where: UserProcessStepWhereUniqueInput
  }

  /**
   * UserProcessStep findUniqueOrThrow
   */
  export type UserProcessStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStep
     */
    select?: UserProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcessStep
     */
    omit?: UserProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which UserProcessStep to fetch.
     */
    where: UserProcessStepWhereUniqueInput
  }

  /**
   * UserProcessStep findFirst
   */
  export type UserProcessStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStep
     */
    select?: UserProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcessStep
     */
    omit?: UserProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which UserProcessStep to fetch.
     */
    where?: UserProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProcessSteps to fetch.
     */
    orderBy?: UserProcessStepOrderByWithRelationInput | UserProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProcessSteps.
     */
    cursor?: UserProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProcessSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProcessSteps.
     */
    distinct?: UserProcessStepScalarFieldEnum | UserProcessStepScalarFieldEnum[]
  }

  /**
   * UserProcessStep findFirstOrThrow
   */
  export type UserProcessStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStep
     */
    select?: UserProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcessStep
     */
    omit?: UserProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which UserProcessStep to fetch.
     */
    where?: UserProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProcessSteps to fetch.
     */
    orderBy?: UserProcessStepOrderByWithRelationInput | UserProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProcessSteps.
     */
    cursor?: UserProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProcessSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProcessSteps.
     */
    distinct?: UserProcessStepScalarFieldEnum | UserProcessStepScalarFieldEnum[]
  }

  /**
   * UserProcessStep findMany
   */
  export type UserProcessStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStep
     */
    select?: UserProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcessStep
     */
    omit?: UserProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which UserProcessSteps to fetch.
     */
    where?: UserProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProcessSteps to fetch.
     */
    orderBy?: UserProcessStepOrderByWithRelationInput | UserProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProcessSteps.
     */
    cursor?: UserProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProcessSteps.
     */
    skip?: number
    distinct?: UserProcessStepScalarFieldEnum | UserProcessStepScalarFieldEnum[]
  }

  /**
   * UserProcessStep create
   */
  export type UserProcessStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStep
     */
    select?: UserProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcessStep
     */
    omit?: UserProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessStepInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProcessStep.
     */
    data: XOR<UserProcessStepCreateInput, UserProcessStepUncheckedCreateInput>
  }

  /**
   * UserProcessStep createMany
   */
  export type UserProcessStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProcessSteps.
     */
    data: UserProcessStepCreateManyInput | UserProcessStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProcessStep createManyAndReturn
   */
  export type UserProcessStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStep
     */
    select?: UserProcessStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcessStep
     */
    omit?: UserProcessStepOmit<ExtArgs> | null
    /**
     * The data used to create many UserProcessSteps.
     */
    data: UserProcessStepCreateManyInput | UserProcessStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProcessStep update
   */
  export type UserProcessStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStep
     */
    select?: UserProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcessStep
     */
    omit?: UserProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessStepInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProcessStep.
     */
    data: XOR<UserProcessStepUpdateInput, UserProcessStepUncheckedUpdateInput>
    /**
     * Choose, which UserProcessStep to update.
     */
    where: UserProcessStepWhereUniqueInput
  }

  /**
   * UserProcessStep updateMany
   */
  export type UserProcessStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProcessSteps.
     */
    data: XOR<UserProcessStepUpdateManyMutationInput, UserProcessStepUncheckedUpdateManyInput>
    /**
     * Filter which UserProcessSteps to update
     */
    where?: UserProcessStepWhereInput
    /**
     * Limit how many UserProcessSteps to update.
     */
    limit?: number
  }

  /**
   * UserProcessStep updateManyAndReturn
   */
  export type UserProcessStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStep
     */
    select?: UserProcessStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcessStep
     */
    omit?: UserProcessStepOmit<ExtArgs> | null
    /**
     * The data used to update UserProcessSteps.
     */
    data: XOR<UserProcessStepUpdateManyMutationInput, UserProcessStepUncheckedUpdateManyInput>
    /**
     * Filter which UserProcessSteps to update
     */
    where?: UserProcessStepWhereInput
    /**
     * Limit how many UserProcessSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProcessStep upsert
   */
  export type UserProcessStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStep
     */
    select?: UserProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcessStep
     */
    omit?: UserProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessStepInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProcessStep to update in case it exists.
     */
    where: UserProcessStepWhereUniqueInput
    /**
     * In case the UserProcessStep found by the `where` argument doesn't exist, create a new UserProcessStep with this data.
     */
    create: XOR<UserProcessStepCreateInput, UserProcessStepUncheckedCreateInput>
    /**
     * In case the UserProcessStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProcessStepUpdateInput, UserProcessStepUncheckedUpdateInput>
  }

  /**
   * UserProcessStep delete
   */
  export type UserProcessStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStep
     */
    select?: UserProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcessStep
     */
    omit?: UserProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessStepInclude<ExtArgs> | null
    /**
     * Filter which UserProcessStep to delete.
     */
    where: UserProcessStepWhereUniqueInput
  }

  /**
   * UserProcessStep deleteMany
   */
  export type UserProcessStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProcessSteps to delete
     */
    where?: UserProcessStepWhereInput
    /**
     * Limit how many UserProcessSteps to delete.
     */
    limit?: number
  }

  /**
   * UserProcessStep.comments
   */
  export type UserProcessStep$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPipelineStepComment
     */
    select?: UserPipelineStepCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPipelineStepComment
     */
    omit?: UserPipelineStepCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPipelineStepCommentInclude<ExtArgs> | null
    where?: UserPipelineStepCommentWhereInput
    orderBy?: UserPipelineStepCommentOrderByWithRelationInput | UserPipelineStepCommentOrderByWithRelationInput[]
    cursor?: UserPipelineStepCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPipelineStepCommentScalarFieldEnum | UserPipelineStepCommentScalarFieldEnum[]
  }

  /**
   * UserProcessStep.step
   */
  export type UserProcessStep$stepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
  }

  /**
   * UserProcessStep without action
   */
  export type UserProcessStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStep
     */
    select?: UserProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcessStep
     */
    omit?: UserProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessStepInclude<ExtArgs> | null
  }


  /**
   * Model UserPipelineStepComment
   */

  export type AggregateUserPipelineStepComment = {
    _count: UserPipelineStepCommentCountAggregateOutputType | null
    _min: UserPipelineStepCommentMinAggregateOutputType | null
    _max: UserPipelineStepCommentMaxAggregateOutputType | null
  }

  export type UserPipelineStepCommentMinAggregateOutputType = {
    id: string | null
    userPipelineStepId: string | null
    userId: string | null
    comment: string | null
    createdAt: string | null
  }

  export type UserPipelineStepCommentMaxAggregateOutputType = {
    id: string | null
    userPipelineStepId: string | null
    userId: string | null
    comment: string | null
    createdAt: string | null
  }

  export type UserPipelineStepCommentCountAggregateOutputType = {
    id: number
    userPipelineStepId: number
    userId: number
    comment: number
    createdAt: number
    _all: number
  }


  export type UserPipelineStepCommentMinAggregateInputType = {
    id?: true
    userPipelineStepId?: true
    userId?: true
    comment?: true
    createdAt?: true
  }

  export type UserPipelineStepCommentMaxAggregateInputType = {
    id?: true
    userPipelineStepId?: true
    userId?: true
    comment?: true
    createdAt?: true
  }

  export type UserPipelineStepCommentCountAggregateInputType = {
    id?: true
    userPipelineStepId?: true
    userId?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type UserPipelineStepCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPipelineStepComment to aggregate.
     */
    where?: UserPipelineStepCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPipelineStepComments to fetch.
     */
    orderBy?: UserPipelineStepCommentOrderByWithRelationInput | UserPipelineStepCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPipelineStepCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserPipelineStepComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPipelineStepComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPipelineStepComments
    **/
    _count?: true | UserPipelineStepCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPipelineStepCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPipelineStepCommentMaxAggregateInputType
  }

  export type GetUserPipelineStepCommentAggregateType<T extends UserPipelineStepCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPipelineStepComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPipelineStepComment[P]>
      : GetScalarType<T[P], AggregateUserPipelineStepComment[P]>
  }




  export type UserPipelineStepCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPipelineStepCommentWhereInput
    orderBy?: UserPipelineStepCommentOrderByWithAggregationInput | UserPipelineStepCommentOrderByWithAggregationInput[]
    by: UserPipelineStepCommentScalarFieldEnum[] | UserPipelineStepCommentScalarFieldEnum
    having?: UserPipelineStepCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPipelineStepCommentCountAggregateInputType | true
    _min?: UserPipelineStepCommentMinAggregateInputType
    _max?: UserPipelineStepCommentMaxAggregateInputType
  }

  export type UserPipelineStepCommentGroupByOutputType = {
    id: string
    userPipelineStepId: string
    userId: string
    comment: string
    createdAt: string
    _count: UserPipelineStepCommentCountAggregateOutputType | null
    _min: UserPipelineStepCommentMinAggregateOutputType | null
    _max: UserPipelineStepCommentMaxAggregateOutputType | null
  }

  type GetUserPipelineStepCommentGroupByPayload<T extends UserPipelineStepCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPipelineStepCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPipelineStepCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPipelineStepCommentGroupByOutputType[P]>
            : GetScalarType<T[P], UserPipelineStepCommentGroupByOutputType[P]>
        }
      >
    >


  export type UserPipelineStepCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userPipelineStepId?: boolean
    userId?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    step?: boolean | UserProcessStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPipelineStepComment"]>

  export type UserPipelineStepCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userPipelineStepId?: boolean
    userId?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    step?: boolean | UserProcessStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPipelineStepComment"]>

  export type UserPipelineStepCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userPipelineStepId?: boolean
    userId?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    step?: boolean | UserProcessStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPipelineStepComment"]>

  export type UserPipelineStepCommentSelectScalar = {
    id?: boolean
    userPipelineStepId?: boolean
    userId?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type UserPipelineStepCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userPipelineStepId" | "userId" | "comment" | "createdAt", ExtArgs["result"]["userPipelineStepComment"]>
  export type UserPipelineStepCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    step?: boolean | UserProcessStepDefaultArgs<ExtArgs>
  }
  export type UserPipelineStepCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    step?: boolean | UserProcessStepDefaultArgs<ExtArgs>
  }
  export type UserPipelineStepCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    step?: boolean | UserProcessStepDefaultArgs<ExtArgs>
  }

  export type $UserPipelineStepCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPipelineStepComment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      step: Prisma.$UserProcessStepPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userPipelineStepId: string
      userId: string
      comment: string
      createdAt: string
    }, ExtArgs["result"]["userPipelineStepComment"]>
    composites: {}
  }

  type UserPipelineStepCommentGetPayload<S extends boolean | null | undefined | UserPipelineStepCommentDefaultArgs> = $Result.GetResult<Prisma.$UserPipelineStepCommentPayload, S>

  type UserPipelineStepCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPipelineStepCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPipelineStepCommentCountAggregateInputType | true
    }

  export interface UserPipelineStepCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPipelineStepComment'], meta: { name: 'UserPipelineStepComment' } }
    /**
     * Find zero or one UserPipelineStepComment that matches the filter.
     * @param {UserPipelineStepCommentFindUniqueArgs} args - Arguments to find a UserPipelineStepComment
     * @example
     * // Get one UserPipelineStepComment
     * const userPipelineStepComment = await prisma.userPipelineStepComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPipelineStepCommentFindUniqueArgs>(args: SelectSubset<T, UserPipelineStepCommentFindUniqueArgs<ExtArgs>>): Prisma__UserPipelineStepCommentClient<$Result.GetResult<Prisma.$UserPipelineStepCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPipelineStepComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPipelineStepCommentFindUniqueOrThrowArgs} args - Arguments to find a UserPipelineStepComment
     * @example
     * // Get one UserPipelineStepComment
     * const userPipelineStepComment = await prisma.userPipelineStepComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPipelineStepCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPipelineStepCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPipelineStepCommentClient<$Result.GetResult<Prisma.$UserPipelineStepCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPipelineStepComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPipelineStepCommentFindFirstArgs} args - Arguments to find a UserPipelineStepComment
     * @example
     * // Get one UserPipelineStepComment
     * const userPipelineStepComment = await prisma.userPipelineStepComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPipelineStepCommentFindFirstArgs>(args?: SelectSubset<T, UserPipelineStepCommentFindFirstArgs<ExtArgs>>): Prisma__UserPipelineStepCommentClient<$Result.GetResult<Prisma.$UserPipelineStepCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPipelineStepComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPipelineStepCommentFindFirstOrThrowArgs} args - Arguments to find a UserPipelineStepComment
     * @example
     * // Get one UserPipelineStepComment
     * const userPipelineStepComment = await prisma.userPipelineStepComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPipelineStepCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPipelineStepCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPipelineStepCommentClient<$Result.GetResult<Prisma.$UserPipelineStepCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPipelineStepComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPipelineStepCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPipelineStepComments
     * const userPipelineStepComments = await prisma.userPipelineStepComment.findMany()
     * 
     * // Get first 10 UserPipelineStepComments
     * const userPipelineStepComments = await prisma.userPipelineStepComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPipelineStepCommentWithIdOnly = await prisma.userPipelineStepComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPipelineStepCommentFindManyArgs>(args?: SelectSubset<T, UserPipelineStepCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPipelineStepCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPipelineStepComment.
     * @param {UserPipelineStepCommentCreateArgs} args - Arguments to create a UserPipelineStepComment.
     * @example
     * // Create one UserPipelineStepComment
     * const UserPipelineStepComment = await prisma.userPipelineStepComment.create({
     *   data: {
     *     // ... data to create a UserPipelineStepComment
     *   }
     * })
     * 
     */
    create<T extends UserPipelineStepCommentCreateArgs>(args: SelectSubset<T, UserPipelineStepCommentCreateArgs<ExtArgs>>): Prisma__UserPipelineStepCommentClient<$Result.GetResult<Prisma.$UserPipelineStepCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPipelineStepComments.
     * @param {UserPipelineStepCommentCreateManyArgs} args - Arguments to create many UserPipelineStepComments.
     * @example
     * // Create many UserPipelineStepComments
     * const userPipelineStepComment = await prisma.userPipelineStepComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPipelineStepCommentCreateManyArgs>(args?: SelectSubset<T, UserPipelineStepCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPipelineStepComments and returns the data saved in the database.
     * @param {UserPipelineStepCommentCreateManyAndReturnArgs} args - Arguments to create many UserPipelineStepComments.
     * @example
     * // Create many UserPipelineStepComments
     * const userPipelineStepComment = await prisma.userPipelineStepComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPipelineStepComments and only return the `id`
     * const userPipelineStepCommentWithIdOnly = await prisma.userPipelineStepComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPipelineStepCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPipelineStepCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPipelineStepCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPipelineStepComment.
     * @param {UserPipelineStepCommentDeleteArgs} args - Arguments to delete one UserPipelineStepComment.
     * @example
     * // Delete one UserPipelineStepComment
     * const UserPipelineStepComment = await prisma.userPipelineStepComment.delete({
     *   where: {
     *     // ... filter to delete one UserPipelineStepComment
     *   }
     * })
     * 
     */
    delete<T extends UserPipelineStepCommentDeleteArgs>(args: SelectSubset<T, UserPipelineStepCommentDeleteArgs<ExtArgs>>): Prisma__UserPipelineStepCommentClient<$Result.GetResult<Prisma.$UserPipelineStepCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPipelineStepComment.
     * @param {UserPipelineStepCommentUpdateArgs} args - Arguments to update one UserPipelineStepComment.
     * @example
     * // Update one UserPipelineStepComment
     * const userPipelineStepComment = await prisma.userPipelineStepComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPipelineStepCommentUpdateArgs>(args: SelectSubset<T, UserPipelineStepCommentUpdateArgs<ExtArgs>>): Prisma__UserPipelineStepCommentClient<$Result.GetResult<Prisma.$UserPipelineStepCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPipelineStepComments.
     * @param {UserPipelineStepCommentDeleteManyArgs} args - Arguments to filter UserPipelineStepComments to delete.
     * @example
     * // Delete a few UserPipelineStepComments
     * const { count } = await prisma.userPipelineStepComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPipelineStepCommentDeleteManyArgs>(args?: SelectSubset<T, UserPipelineStepCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPipelineStepComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPipelineStepCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPipelineStepComments
     * const userPipelineStepComment = await prisma.userPipelineStepComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPipelineStepCommentUpdateManyArgs>(args: SelectSubset<T, UserPipelineStepCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPipelineStepComments and returns the data updated in the database.
     * @param {UserPipelineStepCommentUpdateManyAndReturnArgs} args - Arguments to update many UserPipelineStepComments.
     * @example
     * // Update many UserPipelineStepComments
     * const userPipelineStepComment = await prisma.userPipelineStepComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPipelineStepComments and only return the `id`
     * const userPipelineStepCommentWithIdOnly = await prisma.userPipelineStepComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPipelineStepCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPipelineStepCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPipelineStepCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPipelineStepComment.
     * @param {UserPipelineStepCommentUpsertArgs} args - Arguments to update or create a UserPipelineStepComment.
     * @example
     * // Update or create a UserPipelineStepComment
     * const userPipelineStepComment = await prisma.userPipelineStepComment.upsert({
     *   create: {
     *     // ... data to create a UserPipelineStepComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPipelineStepComment we want to update
     *   }
     * })
     */
    upsert<T extends UserPipelineStepCommentUpsertArgs>(args: SelectSubset<T, UserPipelineStepCommentUpsertArgs<ExtArgs>>): Prisma__UserPipelineStepCommentClient<$Result.GetResult<Prisma.$UserPipelineStepCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPipelineStepComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPipelineStepCommentCountArgs} args - Arguments to filter UserPipelineStepComments to count.
     * @example
     * // Count the number of UserPipelineStepComments
     * const count = await prisma.userPipelineStepComment.count({
     *   where: {
     *     // ... the filter for the UserPipelineStepComments we want to count
     *   }
     * })
    **/
    count<T extends UserPipelineStepCommentCountArgs>(
      args?: Subset<T, UserPipelineStepCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPipelineStepCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPipelineStepComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPipelineStepCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPipelineStepCommentAggregateArgs>(args: Subset<T, UserPipelineStepCommentAggregateArgs>): Prisma.PrismaPromise<GetUserPipelineStepCommentAggregateType<T>>

    /**
     * Group by UserPipelineStepComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPipelineStepCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPipelineStepCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPipelineStepCommentGroupByArgs['orderBy'] }
        : { orderBy?: UserPipelineStepCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPipelineStepCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPipelineStepCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPipelineStepComment model
   */
  readonly fields: UserPipelineStepCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPipelineStepComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPipelineStepCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    step<T extends UserProcessStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProcessStepDefaultArgs<ExtArgs>>): Prisma__UserProcessStepClient<$Result.GetResult<Prisma.$UserProcessStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPipelineStepComment model
   */
  interface UserPipelineStepCommentFieldRefs {
    readonly id: FieldRef<"UserPipelineStepComment", 'String'>
    readonly userPipelineStepId: FieldRef<"UserPipelineStepComment", 'String'>
    readonly userId: FieldRef<"UserPipelineStepComment", 'String'>
    readonly comment: FieldRef<"UserPipelineStepComment", 'String'>
    readonly createdAt: FieldRef<"UserPipelineStepComment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserPipelineStepComment findUnique
   */
  export type UserPipelineStepCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPipelineStepComment
     */
    select?: UserPipelineStepCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPipelineStepComment
     */
    omit?: UserPipelineStepCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPipelineStepCommentInclude<ExtArgs> | null
    /**
     * Filter, which UserPipelineStepComment to fetch.
     */
    where: UserPipelineStepCommentWhereUniqueInput
  }

  /**
   * UserPipelineStepComment findUniqueOrThrow
   */
  export type UserPipelineStepCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPipelineStepComment
     */
    select?: UserPipelineStepCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPipelineStepComment
     */
    omit?: UserPipelineStepCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPipelineStepCommentInclude<ExtArgs> | null
    /**
     * Filter, which UserPipelineStepComment to fetch.
     */
    where: UserPipelineStepCommentWhereUniqueInput
  }

  /**
   * UserPipelineStepComment findFirst
   */
  export type UserPipelineStepCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPipelineStepComment
     */
    select?: UserPipelineStepCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPipelineStepComment
     */
    omit?: UserPipelineStepCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPipelineStepCommentInclude<ExtArgs> | null
    /**
     * Filter, which UserPipelineStepComment to fetch.
     */
    where?: UserPipelineStepCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPipelineStepComments to fetch.
     */
    orderBy?: UserPipelineStepCommentOrderByWithRelationInput | UserPipelineStepCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPipelineStepComments.
     */
    cursor?: UserPipelineStepCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserPipelineStepComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPipelineStepComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPipelineStepComments.
     */
    distinct?: UserPipelineStepCommentScalarFieldEnum | UserPipelineStepCommentScalarFieldEnum[]
  }

  /**
   * UserPipelineStepComment findFirstOrThrow
   */
  export type UserPipelineStepCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPipelineStepComment
     */
    select?: UserPipelineStepCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPipelineStepComment
     */
    omit?: UserPipelineStepCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPipelineStepCommentInclude<ExtArgs> | null
    /**
     * Filter, which UserPipelineStepComment to fetch.
     */
    where?: UserPipelineStepCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPipelineStepComments to fetch.
     */
    orderBy?: UserPipelineStepCommentOrderByWithRelationInput | UserPipelineStepCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPipelineStepComments.
     */
    cursor?: UserPipelineStepCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserPipelineStepComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPipelineStepComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPipelineStepComments.
     */
    distinct?: UserPipelineStepCommentScalarFieldEnum | UserPipelineStepCommentScalarFieldEnum[]
  }

  /**
   * UserPipelineStepComment findMany
   */
  export type UserPipelineStepCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPipelineStepComment
     */
    select?: UserPipelineStepCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPipelineStepComment
     */
    omit?: UserPipelineStepCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPipelineStepCommentInclude<ExtArgs> | null
    /**
     * Filter, which UserPipelineStepComments to fetch.
     */
    where?: UserPipelineStepCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPipelineStepComments to fetch.
     */
    orderBy?: UserPipelineStepCommentOrderByWithRelationInput | UserPipelineStepCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPipelineStepComments.
     */
    cursor?: UserPipelineStepCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserPipelineStepComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPipelineStepComments.
     */
    skip?: number
    distinct?: UserPipelineStepCommentScalarFieldEnum | UserPipelineStepCommentScalarFieldEnum[]
  }

  /**
   * UserPipelineStepComment create
   */
  export type UserPipelineStepCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPipelineStepComment
     */
    select?: UserPipelineStepCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPipelineStepComment
     */
    omit?: UserPipelineStepCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPipelineStepCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPipelineStepComment.
     */
    data: XOR<UserPipelineStepCommentCreateInput, UserPipelineStepCommentUncheckedCreateInput>
  }

  /**
   * UserPipelineStepComment createMany
   */
  export type UserPipelineStepCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPipelineStepComments.
     */
    data: UserPipelineStepCommentCreateManyInput | UserPipelineStepCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPipelineStepComment createManyAndReturn
   */
  export type UserPipelineStepCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPipelineStepComment
     */
    select?: UserPipelineStepCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPipelineStepComment
     */
    omit?: UserPipelineStepCommentOmit<ExtArgs> | null
    /**
     * The data used to create many UserPipelineStepComments.
     */
    data: UserPipelineStepCommentCreateManyInput | UserPipelineStepCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPipelineStepCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPipelineStepComment update
   */
  export type UserPipelineStepCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPipelineStepComment
     */
    select?: UserPipelineStepCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPipelineStepComment
     */
    omit?: UserPipelineStepCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPipelineStepCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPipelineStepComment.
     */
    data: XOR<UserPipelineStepCommentUpdateInput, UserPipelineStepCommentUncheckedUpdateInput>
    /**
     * Choose, which UserPipelineStepComment to update.
     */
    where: UserPipelineStepCommentWhereUniqueInput
  }

  /**
   * UserPipelineStepComment updateMany
   */
  export type UserPipelineStepCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPipelineStepComments.
     */
    data: XOR<UserPipelineStepCommentUpdateManyMutationInput, UserPipelineStepCommentUncheckedUpdateManyInput>
    /**
     * Filter which UserPipelineStepComments to update
     */
    where?: UserPipelineStepCommentWhereInput
    /**
     * Limit how many UserPipelineStepComments to update.
     */
    limit?: number
  }

  /**
   * UserPipelineStepComment updateManyAndReturn
   */
  export type UserPipelineStepCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPipelineStepComment
     */
    select?: UserPipelineStepCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPipelineStepComment
     */
    omit?: UserPipelineStepCommentOmit<ExtArgs> | null
    /**
     * The data used to update UserPipelineStepComments.
     */
    data: XOR<UserPipelineStepCommentUpdateManyMutationInput, UserPipelineStepCommentUncheckedUpdateManyInput>
    /**
     * Filter which UserPipelineStepComments to update
     */
    where?: UserPipelineStepCommentWhereInput
    /**
     * Limit how many UserPipelineStepComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPipelineStepCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPipelineStepComment upsert
   */
  export type UserPipelineStepCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPipelineStepComment
     */
    select?: UserPipelineStepCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPipelineStepComment
     */
    omit?: UserPipelineStepCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPipelineStepCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPipelineStepComment to update in case it exists.
     */
    where: UserPipelineStepCommentWhereUniqueInput
    /**
     * In case the UserPipelineStepComment found by the `where` argument doesn't exist, create a new UserPipelineStepComment with this data.
     */
    create: XOR<UserPipelineStepCommentCreateInput, UserPipelineStepCommentUncheckedCreateInput>
    /**
     * In case the UserPipelineStepComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPipelineStepCommentUpdateInput, UserPipelineStepCommentUncheckedUpdateInput>
  }

  /**
   * UserPipelineStepComment delete
   */
  export type UserPipelineStepCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPipelineStepComment
     */
    select?: UserPipelineStepCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPipelineStepComment
     */
    omit?: UserPipelineStepCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPipelineStepCommentInclude<ExtArgs> | null
    /**
     * Filter which UserPipelineStepComment to delete.
     */
    where: UserPipelineStepCommentWhereUniqueInput
  }

  /**
   * UserPipelineStepComment deleteMany
   */
  export type UserPipelineStepCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPipelineStepComments to delete
     */
    where?: UserPipelineStepCommentWhereInput
    /**
     * Limit how many UserPipelineStepComments to delete.
     */
    limit?: number
  }

  /**
   * UserPipelineStepComment without action
   */
  export type UserPipelineStepCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPipelineStepComment
     */
    select?: UserPipelineStepCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPipelineStepComment
     */
    omit?: UserPipelineStepCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPipelineStepCommentInclude<ExtArgs> | null
  }


  /**
   * Model Process
   */

  export type AggregateProcess = {
    _count: ProcessCountAggregateOutputType | null
    _min: ProcessMinAggregateOutputType | null
    _max: ProcessMaxAggregateOutputType | null
  }

  export type ProcessMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    ownerId: string | null
    isTemplate: boolean | null
    isPublic: boolean | null
  }

  export type ProcessMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    ownerId: string | null
    isTemplate: boolean | null
    isPublic: boolean | null
  }

  export type ProcessCountAggregateOutputType = {
    id: number
    name: number
    description: number
    icon: number
    ownerId: number
    isTemplate: number
    isPublic: number
    _all: number
  }


  export type ProcessMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    ownerId?: true
    isTemplate?: true
    isPublic?: true
  }

  export type ProcessMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    ownerId?: true
    isTemplate?: true
    isPublic?: true
  }

  export type ProcessCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    ownerId?: true
    isTemplate?: true
    isPublic?: true
    _all?: true
  }

  export type ProcessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Process to aggregate.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Processes
    **/
    _count?: true | ProcessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessMaxAggregateInputType
  }

  export type GetProcessAggregateType<T extends ProcessAggregateArgs> = {
        [P in keyof T & keyof AggregateProcess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcess[P]>
      : GetScalarType<T[P], AggregateProcess[P]>
  }




  export type ProcessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithAggregationInput | ProcessOrderByWithAggregationInput[]
    by: ProcessScalarFieldEnum[] | ProcessScalarFieldEnum
    having?: ProcessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessCountAggregateInputType | true
    _min?: ProcessMinAggregateInputType
    _max?: ProcessMaxAggregateInputType
  }

  export type ProcessGroupByOutputType = {
    id: string
    name: string
    description: string | null
    icon: string | null
    ownerId: string | null
    isTemplate: boolean
    isPublic: boolean
    _count: ProcessCountAggregateOutputType | null
    _min: ProcessMinAggregateOutputType | null
    _max: ProcessMaxAggregateOutputType | null
  }

  type GetProcessGroupByPayload<T extends ProcessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessGroupByOutputType[P]>
        }
      >
    >


  export type ProcessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    ownerId?: boolean
    isTemplate?: boolean
    isPublic?: boolean
    user?: boolean | Process$userArgs<ExtArgs>
    steps?: boolean | Process$stepsArgs<ExtArgs>
    processes?: boolean | Process$processesArgs<ExtArgs>
    _count?: boolean | ProcessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["process"]>

  export type ProcessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    ownerId?: boolean
    isTemplate?: boolean
    isPublic?: boolean
    user?: boolean | Process$userArgs<ExtArgs>
  }, ExtArgs["result"]["process"]>

  export type ProcessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    ownerId?: boolean
    isTemplate?: boolean
    isPublic?: boolean
    user?: boolean | Process$userArgs<ExtArgs>
  }, ExtArgs["result"]["process"]>

  export type ProcessSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    ownerId?: boolean
    isTemplate?: boolean
    isPublic?: boolean
  }

  export type ProcessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "icon" | "ownerId" | "isTemplate" | "isPublic", ExtArgs["result"]["process"]>
  export type ProcessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Process$userArgs<ExtArgs>
    steps?: boolean | Process$stepsArgs<ExtArgs>
    processes?: boolean | Process$processesArgs<ExtArgs>
    _count?: boolean | ProcessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Process$userArgs<ExtArgs>
  }
  export type ProcessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Process$userArgs<ExtArgs>
  }

  export type $ProcessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Process"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      /**
       * All steps that belong to this pipeline template
       */
      steps: Prisma.$ProcessStepPayload<ExtArgs>[]
      /**
       * All user processes that are currently using this process
       */
      processes: Prisma.$UserProcessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * Primary key
       */
      id: string
      /**
       * Display name in UI (e.g. "Default Pipeline")
       */
      name: string
      /**
       * Optional longer description
       */
      description: string | null
      /**
       * Lucide icon name for UI
       */
      icon: string | null
      ownerId: string | null
      isTemplate: boolean
      isPublic: boolean
    }, ExtArgs["result"]["process"]>
    composites: {}
  }

  type ProcessGetPayload<S extends boolean | null | undefined | ProcessDefaultArgs> = $Result.GetResult<Prisma.$ProcessPayload, S>

  type ProcessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProcessCountAggregateInputType | true
    }

  export interface ProcessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Process'], meta: { name: 'Process' } }
    /**
     * Find zero or one Process that matches the filter.
     * @param {ProcessFindUniqueArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessFindUniqueArgs>(args: SelectSubset<T, ProcessFindUniqueArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Process that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcessFindUniqueOrThrowArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Process that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindFirstArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessFindFirstArgs>(args?: SelectSubset<T, ProcessFindFirstArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Process that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindFirstOrThrowArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Processes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Processes
     * const processes = await prisma.process.findMany()
     * 
     * // Get first 10 Processes
     * const processes = await prisma.process.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processWithIdOnly = await prisma.process.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessFindManyArgs>(args?: SelectSubset<T, ProcessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Process.
     * @param {ProcessCreateArgs} args - Arguments to create a Process.
     * @example
     * // Create one Process
     * const Process = await prisma.process.create({
     *   data: {
     *     // ... data to create a Process
     *   }
     * })
     * 
     */
    create<T extends ProcessCreateArgs>(args: SelectSubset<T, ProcessCreateArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Processes.
     * @param {ProcessCreateManyArgs} args - Arguments to create many Processes.
     * @example
     * // Create many Processes
     * const process = await prisma.process.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessCreateManyArgs>(args?: SelectSubset<T, ProcessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Processes and returns the data saved in the database.
     * @param {ProcessCreateManyAndReturnArgs} args - Arguments to create many Processes.
     * @example
     * // Create many Processes
     * const process = await prisma.process.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Processes and only return the `id`
     * const processWithIdOnly = await prisma.process.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Process.
     * @param {ProcessDeleteArgs} args - Arguments to delete one Process.
     * @example
     * // Delete one Process
     * const Process = await prisma.process.delete({
     *   where: {
     *     // ... filter to delete one Process
     *   }
     * })
     * 
     */
    delete<T extends ProcessDeleteArgs>(args: SelectSubset<T, ProcessDeleteArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Process.
     * @param {ProcessUpdateArgs} args - Arguments to update one Process.
     * @example
     * // Update one Process
     * const process = await prisma.process.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessUpdateArgs>(args: SelectSubset<T, ProcessUpdateArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Processes.
     * @param {ProcessDeleteManyArgs} args - Arguments to filter Processes to delete.
     * @example
     * // Delete a few Processes
     * const { count } = await prisma.process.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessDeleteManyArgs>(args?: SelectSubset<T, ProcessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Processes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Processes
     * const process = await prisma.process.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessUpdateManyArgs>(args: SelectSubset<T, ProcessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Processes and returns the data updated in the database.
     * @param {ProcessUpdateManyAndReturnArgs} args - Arguments to update many Processes.
     * @example
     * // Update many Processes
     * const process = await prisma.process.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Processes and only return the `id`
     * const processWithIdOnly = await prisma.process.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcessUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Process.
     * @param {ProcessUpsertArgs} args - Arguments to update or create a Process.
     * @example
     * // Update or create a Process
     * const process = await prisma.process.upsert({
     *   create: {
     *     // ... data to create a Process
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Process we want to update
     *   }
     * })
     */
    upsert<T extends ProcessUpsertArgs>(args: SelectSubset<T, ProcessUpsertArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Processes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCountArgs} args - Arguments to filter Processes to count.
     * @example
     * // Count the number of Processes
     * const count = await prisma.process.count({
     *   where: {
     *     // ... the filter for the Processes we want to count
     *   }
     * })
    **/
    count<T extends ProcessCountArgs>(
      args?: Subset<T, ProcessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Process.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessAggregateArgs>(args: Subset<T, ProcessAggregateArgs>): Prisma.PrismaPromise<GetProcessAggregateType<T>>

    /**
     * Group by Process.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessGroupByArgs['orderBy'] }
        : { orderBy?: ProcessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Process model
   */
  readonly fields: ProcessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Process.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Process$userArgs<ExtArgs> = {}>(args?: Subset<T, Process$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    steps<T extends Process$stepsArgs<ExtArgs> = {}>(args?: Subset<T, Process$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processes<T extends Process$processesArgs<ExtArgs> = {}>(args?: Subset<T, Process$processesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Process model
   */
  interface ProcessFieldRefs {
    readonly id: FieldRef<"Process", 'String'>
    readonly name: FieldRef<"Process", 'String'>
    readonly description: FieldRef<"Process", 'String'>
    readonly icon: FieldRef<"Process", 'String'>
    readonly ownerId: FieldRef<"Process", 'String'>
    readonly isTemplate: FieldRef<"Process", 'Boolean'>
    readonly isPublic: FieldRef<"Process", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Process findUnique
   */
  export type ProcessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process findUniqueOrThrow
   */
  export type ProcessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process findFirst
   */
  export type ProcessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processes.
     */
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Process findFirstOrThrow
   */
  export type ProcessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processes.
     */
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Process findMany
   */
  export type ProcessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Processes to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Process create
   */
  export type ProcessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The data needed to create a Process.
     */
    data: XOR<ProcessCreateInput, ProcessUncheckedCreateInput>
  }

  /**
   * Process createMany
   */
  export type ProcessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Processes.
     */
    data: ProcessCreateManyInput | ProcessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Process createManyAndReturn
   */
  export type ProcessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * The data used to create many Processes.
     */
    data: ProcessCreateManyInput | ProcessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Process update
   */
  export type ProcessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The data needed to update a Process.
     */
    data: XOR<ProcessUpdateInput, ProcessUncheckedUpdateInput>
    /**
     * Choose, which Process to update.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process updateMany
   */
  export type ProcessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Processes.
     */
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyInput>
    /**
     * Filter which Processes to update
     */
    where?: ProcessWhereInput
    /**
     * Limit how many Processes to update.
     */
    limit?: number
  }

  /**
   * Process updateManyAndReturn
   */
  export type ProcessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * The data used to update Processes.
     */
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyInput>
    /**
     * Filter which Processes to update
     */
    where?: ProcessWhereInput
    /**
     * Limit how many Processes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Process upsert
   */
  export type ProcessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The filter to search for the Process to update in case it exists.
     */
    where: ProcessWhereUniqueInput
    /**
     * In case the Process found by the `where` argument doesn't exist, create a new Process with this data.
     */
    create: XOR<ProcessCreateInput, ProcessUncheckedCreateInput>
    /**
     * In case the Process was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessUpdateInput, ProcessUncheckedUpdateInput>
  }

  /**
   * Process delete
   */
  export type ProcessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter which Process to delete.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process deleteMany
   */
  export type ProcessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Processes to delete
     */
    where?: ProcessWhereInput
    /**
     * Limit how many Processes to delete.
     */
    limit?: number
  }

  /**
   * Process.user
   */
  export type Process$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Process.steps
   */
  export type Process$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    cursor?: ProcessStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * Process.processes
   */
  export type Process$processesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcess
     */
    select?: UserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcess
     */
    omit?: UserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessInclude<ExtArgs> | null
    where?: UserProcessWhereInput
    orderBy?: UserProcessOrderByWithRelationInput | UserProcessOrderByWithRelationInput[]
    cursor?: UserProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProcessScalarFieldEnum | UserProcessScalarFieldEnum[]
  }

  /**
   * Process without action
   */
  export type ProcessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
  }


  /**
   * Model ProcessStep
   */

  export type AggregateProcessStep = {
    _count: ProcessStepCountAggregateOutputType | null
    _avg: ProcessStepAvgAggregateOutputType | null
    _sum: ProcessStepSumAggregateOutputType | null
    _min: ProcessStepMinAggregateOutputType | null
    _max: ProcessStepMaxAggregateOutputType | null
  }

  export type ProcessStepAvgAggregateOutputType = {
    order: number | null
  }

  export type ProcessStepSumAggregateOutputType = {
    order: number | null
  }

  export type ProcessStepMinAggregateOutputType = {
    id: string | null
    processId: string | null
    title: string | null
    description: string | null
    icon: string | null
    order: number | null
    userId: string | null
  }

  export type ProcessStepMaxAggregateOutputType = {
    id: string | null
    processId: string | null
    title: string | null
    description: string | null
    icon: string | null
    order: number | null
    userId: string | null
  }

  export type ProcessStepCountAggregateOutputType = {
    id: number
    processId: number
    title: number
    description: number
    icon: number
    order: number
    userId: number
    _all: number
  }


  export type ProcessStepAvgAggregateInputType = {
    order?: true
  }

  export type ProcessStepSumAggregateInputType = {
    order?: true
  }

  export type ProcessStepMinAggregateInputType = {
    id?: true
    processId?: true
    title?: true
    description?: true
    icon?: true
    order?: true
    userId?: true
  }

  export type ProcessStepMaxAggregateInputType = {
    id?: true
    processId?: true
    title?: true
    description?: true
    icon?: true
    order?: true
    userId?: true
  }

  export type ProcessStepCountAggregateInputType = {
    id?: true
    processId?: true
    title?: true
    description?: true
    icon?: true
    order?: true
    userId?: true
    _all?: true
  }

  export type ProcessStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessStep to aggregate.
     */
    where?: ProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSteps to fetch.
     */
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessSteps
    **/
    _count?: true | ProcessStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessStepMaxAggregateInputType
  }

  export type GetProcessStepAggregateType<T extends ProcessStepAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessStep[P]>
      : GetScalarType<T[P], AggregateProcessStep[P]>
  }




  export type ProcessStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessStepWhereInput
    orderBy?: ProcessStepOrderByWithAggregationInput | ProcessStepOrderByWithAggregationInput[]
    by: ProcessStepScalarFieldEnum[] | ProcessStepScalarFieldEnum
    having?: ProcessStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessStepCountAggregateInputType | true
    _avg?: ProcessStepAvgAggregateInputType
    _sum?: ProcessStepSumAggregateInputType
    _min?: ProcessStepMinAggregateInputType
    _max?: ProcessStepMaxAggregateInputType
  }

  export type ProcessStepGroupByOutputType = {
    id: string
    processId: string
    title: string
    description: string
    icon: string | null
    order: number
    userId: string | null
    _count: ProcessStepCountAggregateOutputType | null
    _avg: ProcessStepAvgAggregateOutputType | null
    _sum: ProcessStepSumAggregateOutputType | null
    _min: ProcessStepMinAggregateOutputType | null
    _max: ProcessStepMaxAggregateOutputType | null
  }

  type GetProcessStepGroupByPayload<T extends ProcessStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessStepGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessStepGroupByOutputType[P]>
        }
      >
    >


  export type ProcessStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    userId?: boolean
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    triggers?: boolean | ProcessStep$triggersArgs<ExtArgs>
    actions?: boolean | ProcessStep$actionsArgs<ExtArgs>
    user?: boolean | ProcessStep$userArgs<ExtArgs>
    userProcessSteps?: boolean | ProcessStep$userProcessStepsArgs<ExtArgs>
    _count?: boolean | ProcessStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processStep"]>

  export type ProcessStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    userId?: boolean
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    user?: boolean | ProcessStep$userArgs<ExtArgs>
  }, ExtArgs["result"]["processStep"]>

  export type ProcessStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    userId?: boolean
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    user?: boolean | ProcessStep$userArgs<ExtArgs>
  }, ExtArgs["result"]["processStep"]>

  export type ProcessStepSelectScalar = {
    id?: boolean
    processId?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    userId?: boolean
  }

  export type ProcessStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "processId" | "title" | "description" | "icon" | "order" | "userId", ExtArgs["result"]["processStep"]>
  export type ProcessStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    triggers?: boolean | ProcessStep$triggersArgs<ExtArgs>
    actions?: boolean | ProcessStep$actionsArgs<ExtArgs>
    user?: boolean | ProcessStep$userArgs<ExtArgs>
    userProcessSteps?: boolean | ProcessStep$userProcessStepsArgs<ExtArgs>
    _count?: boolean | ProcessStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcessStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    user?: boolean | ProcessStep$userArgs<ExtArgs>
  }
  export type ProcessStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    user?: boolean | ProcessStep$userArgs<ExtArgs>
  }

  export type $ProcessStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessStep"
    objects: {
      process: Prisma.$ProcessPayload<ExtArgs>
      triggers: Prisma.$TriggerDefinitionPayload<ExtArgs>[]
      actions: Prisma.$ActionDefinitionPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
      /**
       * All user-specific instances of this step (one per UserJobProcess)
       */
      userProcessSteps: Prisma.$UserProcessStepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * Primary key
       */
      id: string
      /**
       * FK to PipelineTemplate
       */
      processId: string
      title: string
      description: string
      icon: string | null
      order: number
      userId: string | null
    }, ExtArgs["result"]["processStep"]>
    composites: {}
  }

  type ProcessStepGetPayload<S extends boolean | null | undefined | ProcessStepDefaultArgs> = $Result.GetResult<Prisma.$ProcessStepPayload, S>

  type ProcessStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcessStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProcessStepCountAggregateInputType | true
    }

  export interface ProcessStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessStep'], meta: { name: 'ProcessStep' } }
    /**
     * Find zero or one ProcessStep that matches the filter.
     * @param {ProcessStepFindUniqueArgs} args - Arguments to find a ProcessStep
     * @example
     * // Get one ProcessStep
     * const processStep = await prisma.processStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessStepFindUniqueArgs>(args: SelectSubset<T, ProcessStepFindUniqueArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProcessStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcessStepFindUniqueOrThrowArgs} args - Arguments to find a ProcessStep
     * @example
     * // Get one ProcessStep
     * const processStep = await prisma.processStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessStepFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepFindFirstArgs} args - Arguments to find a ProcessStep
     * @example
     * // Get one ProcessStep
     * const processStep = await prisma.processStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessStepFindFirstArgs>(args?: SelectSubset<T, ProcessStepFindFirstArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepFindFirstOrThrowArgs} args - Arguments to find a ProcessStep
     * @example
     * // Get one ProcessStep
     * const processStep = await prisma.processStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessStepFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProcessSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessSteps
     * const processSteps = await prisma.processStep.findMany()
     * 
     * // Get first 10 ProcessSteps
     * const processSteps = await prisma.processStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processStepWithIdOnly = await prisma.processStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessStepFindManyArgs>(args?: SelectSubset<T, ProcessStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProcessStep.
     * @param {ProcessStepCreateArgs} args - Arguments to create a ProcessStep.
     * @example
     * // Create one ProcessStep
     * const ProcessStep = await prisma.processStep.create({
     *   data: {
     *     // ... data to create a ProcessStep
     *   }
     * })
     * 
     */
    create<T extends ProcessStepCreateArgs>(args: SelectSubset<T, ProcessStepCreateArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProcessSteps.
     * @param {ProcessStepCreateManyArgs} args - Arguments to create many ProcessSteps.
     * @example
     * // Create many ProcessSteps
     * const processStep = await prisma.processStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessStepCreateManyArgs>(args?: SelectSubset<T, ProcessStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcessSteps and returns the data saved in the database.
     * @param {ProcessStepCreateManyAndReturnArgs} args - Arguments to create many ProcessSteps.
     * @example
     * // Create many ProcessSteps
     * const processStep = await prisma.processStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcessSteps and only return the `id`
     * const processStepWithIdOnly = await prisma.processStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessStepCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProcessStep.
     * @param {ProcessStepDeleteArgs} args - Arguments to delete one ProcessStep.
     * @example
     * // Delete one ProcessStep
     * const ProcessStep = await prisma.processStep.delete({
     *   where: {
     *     // ... filter to delete one ProcessStep
     *   }
     * })
     * 
     */
    delete<T extends ProcessStepDeleteArgs>(args: SelectSubset<T, ProcessStepDeleteArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProcessStep.
     * @param {ProcessStepUpdateArgs} args - Arguments to update one ProcessStep.
     * @example
     * // Update one ProcessStep
     * const processStep = await prisma.processStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessStepUpdateArgs>(args: SelectSubset<T, ProcessStepUpdateArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProcessSteps.
     * @param {ProcessStepDeleteManyArgs} args - Arguments to filter ProcessSteps to delete.
     * @example
     * // Delete a few ProcessSteps
     * const { count } = await prisma.processStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessStepDeleteManyArgs>(args?: SelectSubset<T, ProcessStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessSteps
     * const processStep = await prisma.processStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessStepUpdateManyArgs>(args: SelectSubset<T, ProcessStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessSteps and returns the data updated in the database.
     * @param {ProcessStepUpdateManyAndReturnArgs} args - Arguments to update many ProcessSteps.
     * @example
     * // Update many ProcessSteps
     * const processStep = await prisma.processStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProcessSteps and only return the `id`
     * const processStepWithIdOnly = await prisma.processStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcessStepUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcessStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProcessStep.
     * @param {ProcessStepUpsertArgs} args - Arguments to update or create a ProcessStep.
     * @example
     * // Update or create a ProcessStep
     * const processStep = await prisma.processStep.upsert({
     *   create: {
     *     // ... data to create a ProcessStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessStep we want to update
     *   }
     * })
     */
    upsert<T extends ProcessStepUpsertArgs>(args: SelectSubset<T, ProcessStepUpsertArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProcessSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepCountArgs} args - Arguments to filter ProcessSteps to count.
     * @example
     * // Count the number of ProcessSteps
     * const count = await prisma.processStep.count({
     *   where: {
     *     // ... the filter for the ProcessSteps we want to count
     *   }
     * })
    **/
    count<T extends ProcessStepCountArgs>(
      args?: Subset<T, ProcessStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessStepAggregateArgs>(args: Subset<T, ProcessStepAggregateArgs>): Prisma.PrismaPromise<GetProcessStepAggregateType<T>>

    /**
     * Group by ProcessStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessStepGroupByArgs['orderBy'] }
        : { orderBy?: ProcessStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessStep model
   */
  readonly fields: ProcessStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    process<T extends ProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDefaultArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    triggers<T extends ProcessStep$triggersArgs<ExtArgs> = {}>(args?: Subset<T, ProcessStep$triggersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggerDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    actions<T extends ProcessStep$actionsArgs<ExtArgs> = {}>(args?: Subset<T, ProcessStep$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends ProcessStep$userArgs<ExtArgs> = {}>(args?: Subset<T, ProcessStep$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userProcessSteps<T extends ProcessStep$userProcessStepsArgs<ExtArgs> = {}>(args?: Subset<T, ProcessStep$userProcessStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProcessStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessStep model
   */
  interface ProcessStepFieldRefs {
    readonly id: FieldRef<"ProcessStep", 'String'>
    readonly processId: FieldRef<"ProcessStep", 'String'>
    readonly title: FieldRef<"ProcessStep", 'String'>
    readonly description: FieldRef<"ProcessStep", 'String'>
    readonly icon: FieldRef<"ProcessStep", 'String'>
    readonly order: FieldRef<"ProcessStep", 'Int'>
    readonly userId: FieldRef<"ProcessStep", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProcessStep findUnique
   */
  export type ProcessStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStep to fetch.
     */
    where: ProcessStepWhereUniqueInput
  }

  /**
   * ProcessStep findUniqueOrThrow
   */
  export type ProcessStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStep to fetch.
     */
    where: ProcessStepWhereUniqueInput
  }

  /**
   * ProcessStep findFirst
   */
  export type ProcessStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStep to fetch.
     */
    where?: ProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSteps to fetch.
     */
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessSteps.
     */
    cursor?: ProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessSteps.
     */
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * ProcessStep findFirstOrThrow
   */
  export type ProcessStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessStep to fetch.
     */
    where?: ProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSteps to fetch.
     */
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessSteps.
     */
    cursor?: ProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessSteps.
     */
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * ProcessStep findMany
   */
  export type ProcessStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter, which ProcessSteps to fetch.
     */
    where?: ProcessStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSteps to fetch.
     */
    orderBy?: ProcessStepOrderByWithRelationInput | ProcessStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessSteps.
     */
    cursor?: ProcessStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ProcessSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSteps.
     */
    skip?: number
    distinct?: ProcessStepScalarFieldEnum | ProcessStepScalarFieldEnum[]
  }

  /**
   * ProcessStep create
   */
  export type ProcessStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessStep.
     */
    data: XOR<ProcessStepCreateInput, ProcessStepUncheckedCreateInput>
  }

  /**
   * ProcessStep createMany
   */
  export type ProcessStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessSteps.
     */
    data: ProcessStepCreateManyInput | ProcessStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessStep createManyAndReturn
   */
  export type ProcessStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * The data used to create many ProcessSteps.
     */
    data: ProcessStepCreateManyInput | ProcessStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessStep update
   */
  export type ProcessStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessStep.
     */
    data: XOR<ProcessStepUpdateInput, ProcessStepUncheckedUpdateInput>
    /**
     * Choose, which ProcessStep to update.
     */
    where: ProcessStepWhereUniqueInput
  }

  /**
   * ProcessStep updateMany
   */
  export type ProcessStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessSteps.
     */
    data: XOR<ProcessStepUpdateManyMutationInput, ProcessStepUncheckedUpdateManyInput>
    /**
     * Filter which ProcessSteps to update
     */
    where?: ProcessStepWhereInput
    /**
     * Limit how many ProcessSteps to update.
     */
    limit?: number
  }

  /**
   * ProcessStep updateManyAndReturn
   */
  export type ProcessStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * The data used to update ProcessSteps.
     */
    data: XOR<ProcessStepUpdateManyMutationInput, ProcessStepUncheckedUpdateManyInput>
    /**
     * Filter which ProcessSteps to update
     */
    where?: ProcessStepWhereInput
    /**
     * Limit how many ProcessSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessStep upsert
   */
  export type ProcessStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessStep to update in case it exists.
     */
    where: ProcessStepWhereUniqueInput
    /**
     * In case the ProcessStep found by the `where` argument doesn't exist, create a new ProcessStep with this data.
     */
    create: XOR<ProcessStepCreateInput, ProcessStepUncheckedCreateInput>
    /**
     * In case the ProcessStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessStepUpdateInput, ProcessStepUncheckedUpdateInput>
  }

  /**
   * ProcessStep delete
   */
  export type ProcessStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    /**
     * Filter which ProcessStep to delete.
     */
    where: ProcessStepWhereUniqueInput
  }

  /**
   * ProcessStep deleteMany
   */
  export type ProcessStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessSteps to delete
     */
    where?: ProcessStepWhereInput
    /**
     * Limit how many ProcessSteps to delete.
     */
    limit?: number
  }

  /**
   * ProcessStep.triggers
   */
  export type ProcessStep$triggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerDefinition
     */
    select?: TriggerDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriggerDefinition
     */
    omit?: TriggerDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerDefinitionInclude<ExtArgs> | null
    where?: TriggerDefinitionWhereInput
    orderBy?: TriggerDefinitionOrderByWithRelationInput | TriggerDefinitionOrderByWithRelationInput[]
    cursor?: TriggerDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TriggerDefinitionScalarFieldEnum | TriggerDefinitionScalarFieldEnum[]
  }

  /**
   * ProcessStep.actions
   */
  export type ProcessStep$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionDefinition
     */
    select?: ActionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionDefinition
     */
    omit?: ActionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionDefinitionInclude<ExtArgs> | null
    where?: ActionDefinitionWhereInput
    orderBy?: ActionDefinitionOrderByWithRelationInput | ActionDefinitionOrderByWithRelationInput[]
    cursor?: ActionDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionDefinitionScalarFieldEnum | ActionDefinitionScalarFieldEnum[]
  }

  /**
   * ProcessStep.user
   */
  export type ProcessStep$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProcessStep.userProcessSteps
   */
  export type ProcessStep$userProcessStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProcessStep
     */
    select?: UserProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProcessStep
     */
    omit?: UserProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProcessStepInclude<ExtArgs> | null
    where?: UserProcessStepWhereInput
    orderBy?: UserProcessStepOrderByWithRelationInput | UserProcessStepOrderByWithRelationInput[]
    cursor?: UserProcessStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProcessStepScalarFieldEnum | UserProcessStepScalarFieldEnum[]
  }

  /**
   * ProcessStep without action
   */
  export type ProcessStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
  }


  /**
   * Model ActionDefinition
   */

  export type AggregateActionDefinition = {
    _count: ActionDefinitionCountAggregateOutputType | null
    _avg: ActionDefinitionAvgAggregateOutputType | null
    _sum: ActionDefinitionSumAggregateOutputType | null
    _min: ActionDefinitionMinAggregateOutputType | null
    _max: ActionDefinitionMaxAggregateOutputType | null
  }

  export type ActionDefinitionAvgAggregateOutputType = {
    order: number | null
  }

  export type ActionDefinitionSumAggregateOutputType = {
    order: number | null
  }

  export type ActionDefinitionMinAggregateOutputType = {
    id: string | null
    name: string | null
    isPublic: boolean | null
    order: number | null
    stepId: string | null
  }

  export type ActionDefinitionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isPublic: boolean | null
    order: number | null
    stepId: string | null
  }

  export type ActionDefinitionCountAggregateOutputType = {
    id: number
    name: number
    isPublic: number
    order: number
    config: number
    stepId: number
    _all: number
  }


  export type ActionDefinitionAvgAggregateInputType = {
    order?: true
  }

  export type ActionDefinitionSumAggregateInputType = {
    order?: true
  }

  export type ActionDefinitionMinAggregateInputType = {
    id?: true
    name?: true
    isPublic?: true
    order?: true
    stepId?: true
  }

  export type ActionDefinitionMaxAggregateInputType = {
    id?: true
    name?: true
    isPublic?: true
    order?: true
    stepId?: true
  }

  export type ActionDefinitionCountAggregateInputType = {
    id?: true
    name?: true
    isPublic?: true
    order?: true
    config?: true
    stepId?: true
    _all?: true
  }

  export type ActionDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionDefinition to aggregate.
     */
    where?: ActionDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionDefinitions to fetch.
     */
    orderBy?: ActionDefinitionOrderByWithRelationInput | ActionDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ActionDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActionDefinitions
    **/
    _count?: true | ActionDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionDefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionDefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionDefinitionMaxAggregateInputType
  }

  export type GetActionDefinitionAggregateType<T extends ActionDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateActionDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActionDefinition[P]>
      : GetScalarType<T[P], AggregateActionDefinition[P]>
  }




  export type ActionDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionDefinitionWhereInput
    orderBy?: ActionDefinitionOrderByWithAggregationInput | ActionDefinitionOrderByWithAggregationInput[]
    by: ActionDefinitionScalarFieldEnum[] | ActionDefinitionScalarFieldEnum
    having?: ActionDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionDefinitionCountAggregateInputType | true
    _avg?: ActionDefinitionAvgAggregateInputType
    _sum?: ActionDefinitionSumAggregateInputType
    _min?: ActionDefinitionMinAggregateInputType
    _max?: ActionDefinitionMaxAggregateInputType
  }

  export type ActionDefinitionGroupByOutputType = {
    id: string
    name: string
    isPublic: boolean
    order: number
    config: JsonValue
    stepId: string | null
    _count: ActionDefinitionCountAggregateOutputType | null
    _avg: ActionDefinitionAvgAggregateOutputType | null
    _sum: ActionDefinitionSumAggregateOutputType | null
    _min: ActionDefinitionMinAggregateOutputType | null
    _max: ActionDefinitionMaxAggregateOutputType | null
  }

  type GetActionDefinitionGroupByPayload<T extends ActionDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], ActionDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type ActionDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isPublic?: boolean
    order?: boolean
    config?: boolean
    stepId?: boolean
    step?: boolean | ActionDefinition$stepArgs<ExtArgs>
  }, ExtArgs["result"]["actionDefinition"]>

  export type ActionDefinitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isPublic?: boolean
    order?: boolean
    config?: boolean
    stepId?: boolean
    step?: boolean | ActionDefinition$stepArgs<ExtArgs>
  }, ExtArgs["result"]["actionDefinition"]>

  export type ActionDefinitionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isPublic?: boolean
    order?: boolean
    config?: boolean
    stepId?: boolean
    step?: boolean | ActionDefinition$stepArgs<ExtArgs>
  }, ExtArgs["result"]["actionDefinition"]>

  export type ActionDefinitionSelectScalar = {
    id?: boolean
    name?: boolean
    isPublic?: boolean
    order?: boolean
    config?: boolean
    stepId?: boolean
  }

  export type ActionDefinitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isPublic" | "order" | "config" | "stepId", ExtArgs["result"]["actionDefinition"]>
  export type ActionDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    step?: boolean | ActionDefinition$stepArgs<ExtArgs>
  }
  export type ActionDefinitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    step?: boolean | ActionDefinition$stepArgs<ExtArgs>
  }
  export type ActionDefinitionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    step?: boolean | ActionDefinition$stepArgs<ExtArgs>
  }

  export type $ActionDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActionDefinition"
    objects: {
      step: Prisma.$ProcessStepPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      isPublic: boolean
      order: number
      config: Prisma.JsonValue
      stepId: string | null
    }, ExtArgs["result"]["actionDefinition"]>
    composites: {}
  }

  type ActionDefinitionGetPayload<S extends boolean | null | undefined | ActionDefinitionDefaultArgs> = $Result.GetResult<Prisma.$ActionDefinitionPayload, S>

  type ActionDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActionDefinitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActionDefinitionCountAggregateInputType | true
    }

  export interface ActionDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActionDefinition'], meta: { name: 'ActionDefinition' } }
    /**
     * Find zero or one ActionDefinition that matches the filter.
     * @param {ActionDefinitionFindUniqueArgs} args - Arguments to find a ActionDefinition
     * @example
     * // Get one ActionDefinition
     * const actionDefinition = await prisma.actionDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionDefinitionFindUniqueArgs>(args: SelectSubset<T, ActionDefinitionFindUniqueArgs<ExtArgs>>): Prisma__ActionDefinitionClient<$Result.GetResult<Prisma.$ActionDefinitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActionDefinition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActionDefinitionFindUniqueOrThrowArgs} args - Arguments to find a ActionDefinition
     * @example
     * // Get one ActionDefinition
     * const actionDefinition = await prisma.actionDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionDefinitionClient<$Result.GetResult<Prisma.$ActionDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActionDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionDefinitionFindFirstArgs} args - Arguments to find a ActionDefinition
     * @example
     * // Get one ActionDefinition
     * const actionDefinition = await prisma.actionDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionDefinitionFindFirstArgs>(args?: SelectSubset<T, ActionDefinitionFindFirstArgs<ExtArgs>>): Prisma__ActionDefinitionClient<$Result.GetResult<Prisma.$ActionDefinitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActionDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionDefinitionFindFirstOrThrowArgs} args - Arguments to find a ActionDefinition
     * @example
     * // Get one ActionDefinition
     * const actionDefinition = await prisma.actionDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionDefinitionClient<$Result.GetResult<Prisma.$ActionDefinitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActionDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActionDefinitions
     * const actionDefinitions = await prisma.actionDefinition.findMany()
     * 
     * // Get first 10 ActionDefinitions
     * const actionDefinitions = await prisma.actionDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionDefinitionWithIdOnly = await prisma.actionDefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionDefinitionFindManyArgs>(args?: SelectSubset<T, ActionDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActionDefinition.
     * @param {ActionDefinitionCreateArgs} args - Arguments to create a ActionDefinition.
     * @example
     * // Create one ActionDefinition
     * const ActionDefinition = await prisma.actionDefinition.create({
     *   data: {
     *     // ... data to create a ActionDefinition
     *   }
     * })
     * 
     */
    create<T extends ActionDefinitionCreateArgs>(args: SelectSubset<T, ActionDefinitionCreateArgs<ExtArgs>>): Prisma__ActionDefinitionClient<$Result.GetResult<Prisma.$ActionDefinitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActionDefinitions.
     * @param {ActionDefinitionCreateManyArgs} args - Arguments to create many ActionDefinitions.
     * @example
     * // Create many ActionDefinitions
     * const actionDefinition = await prisma.actionDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionDefinitionCreateManyArgs>(args?: SelectSubset<T, ActionDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActionDefinitions and returns the data saved in the database.
     * @param {ActionDefinitionCreateManyAndReturnArgs} args - Arguments to create many ActionDefinitions.
     * @example
     * // Create many ActionDefinitions
     * const actionDefinition = await prisma.actionDefinition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActionDefinitions and only return the `id`
     * const actionDefinitionWithIdOnly = await prisma.actionDefinition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionDefinitionCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionDefinitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionDefinitionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActionDefinition.
     * @param {ActionDefinitionDeleteArgs} args - Arguments to delete one ActionDefinition.
     * @example
     * // Delete one ActionDefinition
     * const ActionDefinition = await prisma.actionDefinition.delete({
     *   where: {
     *     // ... filter to delete one ActionDefinition
     *   }
     * })
     * 
     */
    delete<T extends ActionDefinitionDeleteArgs>(args: SelectSubset<T, ActionDefinitionDeleteArgs<ExtArgs>>): Prisma__ActionDefinitionClient<$Result.GetResult<Prisma.$ActionDefinitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActionDefinition.
     * @param {ActionDefinitionUpdateArgs} args - Arguments to update one ActionDefinition.
     * @example
     * // Update one ActionDefinition
     * const actionDefinition = await prisma.actionDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionDefinitionUpdateArgs>(args: SelectSubset<T, ActionDefinitionUpdateArgs<ExtArgs>>): Prisma__ActionDefinitionClient<$Result.GetResult<Prisma.$ActionDefinitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActionDefinitions.
     * @param {ActionDefinitionDeleteManyArgs} args - Arguments to filter ActionDefinitions to delete.
     * @example
     * // Delete a few ActionDefinitions
     * const { count } = await prisma.actionDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionDefinitionDeleteManyArgs>(args?: SelectSubset<T, ActionDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActionDefinitions
     * const actionDefinition = await prisma.actionDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionDefinitionUpdateManyArgs>(args: SelectSubset<T, ActionDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionDefinitions and returns the data updated in the database.
     * @param {ActionDefinitionUpdateManyAndReturnArgs} args - Arguments to update many ActionDefinitions.
     * @example
     * // Update many ActionDefinitions
     * const actionDefinition = await prisma.actionDefinition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActionDefinitions and only return the `id`
     * const actionDefinitionWithIdOnly = await prisma.actionDefinition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActionDefinitionUpdateManyAndReturnArgs>(args: SelectSubset<T, ActionDefinitionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionDefinitionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActionDefinition.
     * @param {ActionDefinitionUpsertArgs} args - Arguments to update or create a ActionDefinition.
     * @example
     * // Update or create a ActionDefinition
     * const actionDefinition = await prisma.actionDefinition.upsert({
     *   create: {
     *     // ... data to create a ActionDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActionDefinition we want to update
     *   }
     * })
     */
    upsert<T extends ActionDefinitionUpsertArgs>(args: SelectSubset<T, ActionDefinitionUpsertArgs<ExtArgs>>): Prisma__ActionDefinitionClient<$Result.GetResult<Prisma.$ActionDefinitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActionDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionDefinitionCountArgs} args - Arguments to filter ActionDefinitions to count.
     * @example
     * // Count the number of ActionDefinitions
     * const count = await prisma.actionDefinition.count({
     *   where: {
     *     // ... the filter for the ActionDefinitions we want to count
     *   }
     * })
    **/
    count<T extends ActionDefinitionCountArgs>(
      args?: Subset<T, ActionDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActionDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionDefinitionAggregateArgs>(args: Subset<T, ActionDefinitionAggregateArgs>): Prisma.PrismaPromise<GetActionDefinitionAggregateType<T>>

    /**
     * Group by ActionDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: ActionDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActionDefinition model
   */
  readonly fields: ActionDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActionDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    step<T extends ActionDefinition$stepArgs<ExtArgs> = {}>(args?: Subset<T, ActionDefinition$stepArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActionDefinition model
   */
  interface ActionDefinitionFieldRefs {
    readonly id: FieldRef<"ActionDefinition", 'String'>
    readonly name: FieldRef<"ActionDefinition", 'String'>
    readonly isPublic: FieldRef<"ActionDefinition", 'Boolean'>
    readonly order: FieldRef<"ActionDefinition", 'Int'>
    readonly config: FieldRef<"ActionDefinition", 'Json'>
    readonly stepId: FieldRef<"ActionDefinition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ActionDefinition findUnique
   */
  export type ActionDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionDefinition
     */
    select?: ActionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionDefinition
     */
    omit?: ActionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ActionDefinition to fetch.
     */
    where: ActionDefinitionWhereUniqueInput
  }

  /**
   * ActionDefinition findUniqueOrThrow
   */
  export type ActionDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionDefinition
     */
    select?: ActionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionDefinition
     */
    omit?: ActionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ActionDefinition to fetch.
     */
    where: ActionDefinitionWhereUniqueInput
  }

  /**
   * ActionDefinition findFirst
   */
  export type ActionDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionDefinition
     */
    select?: ActionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionDefinition
     */
    omit?: ActionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ActionDefinition to fetch.
     */
    where?: ActionDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionDefinitions to fetch.
     */
    orderBy?: ActionDefinitionOrderByWithRelationInput | ActionDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionDefinitions.
     */
    cursor?: ActionDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ActionDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionDefinitions.
     */
    distinct?: ActionDefinitionScalarFieldEnum | ActionDefinitionScalarFieldEnum[]
  }

  /**
   * ActionDefinition findFirstOrThrow
   */
  export type ActionDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionDefinition
     */
    select?: ActionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionDefinition
     */
    omit?: ActionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ActionDefinition to fetch.
     */
    where?: ActionDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionDefinitions to fetch.
     */
    orderBy?: ActionDefinitionOrderByWithRelationInput | ActionDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionDefinitions.
     */
    cursor?: ActionDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ActionDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionDefinitions.
     */
    distinct?: ActionDefinitionScalarFieldEnum | ActionDefinitionScalarFieldEnum[]
  }

  /**
   * ActionDefinition findMany
   */
  export type ActionDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionDefinition
     */
    select?: ActionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionDefinition
     */
    omit?: ActionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ActionDefinitions to fetch.
     */
    where?: ActionDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionDefinitions to fetch.
     */
    orderBy?: ActionDefinitionOrderByWithRelationInput | ActionDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActionDefinitions.
     */
    cursor?: ActionDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ActionDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionDefinitions.
     */
    skip?: number
    distinct?: ActionDefinitionScalarFieldEnum | ActionDefinitionScalarFieldEnum[]
  }

  /**
   * ActionDefinition create
   */
  export type ActionDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionDefinition
     */
    select?: ActionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionDefinition
     */
    omit?: ActionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a ActionDefinition.
     */
    data: XOR<ActionDefinitionCreateInput, ActionDefinitionUncheckedCreateInput>
  }

  /**
   * ActionDefinition createMany
   */
  export type ActionDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActionDefinitions.
     */
    data: ActionDefinitionCreateManyInput | ActionDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActionDefinition createManyAndReturn
   */
  export type ActionDefinitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionDefinition
     */
    select?: ActionDefinitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActionDefinition
     */
    omit?: ActionDefinitionOmit<ExtArgs> | null
    /**
     * The data used to create many ActionDefinitions.
     */
    data: ActionDefinitionCreateManyInput | ActionDefinitionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionDefinitionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionDefinition update
   */
  export type ActionDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionDefinition
     */
    select?: ActionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionDefinition
     */
    omit?: ActionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a ActionDefinition.
     */
    data: XOR<ActionDefinitionUpdateInput, ActionDefinitionUncheckedUpdateInput>
    /**
     * Choose, which ActionDefinition to update.
     */
    where: ActionDefinitionWhereUniqueInput
  }

  /**
   * ActionDefinition updateMany
   */
  export type ActionDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActionDefinitions.
     */
    data: XOR<ActionDefinitionUpdateManyMutationInput, ActionDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which ActionDefinitions to update
     */
    where?: ActionDefinitionWhereInput
    /**
     * Limit how many ActionDefinitions to update.
     */
    limit?: number
  }

  /**
   * ActionDefinition updateManyAndReturn
   */
  export type ActionDefinitionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionDefinition
     */
    select?: ActionDefinitionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActionDefinition
     */
    omit?: ActionDefinitionOmit<ExtArgs> | null
    /**
     * The data used to update ActionDefinitions.
     */
    data: XOR<ActionDefinitionUpdateManyMutationInput, ActionDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which ActionDefinitions to update
     */
    where?: ActionDefinitionWhereInput
    /**
     * Limit how many ActionDefinitions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionDefinitionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionDefinition upsert
   */
  export type ActionDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionDefinition
     */
    select?: ActionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionDefinition
     */
    omit?: ActionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the ActionDefinition to update in case it exists.
     */
    where: ActionDefinitionWhereUniqueInput
    /**
     * In case the ActionDefinition found by the `where` argument doesn't exist, create a new ActionDefinition with this data.
     */
    create: XOR<ActionDefinitionCreateInput, ActionDefinitionUncheckedCreateInput>
    /**
     * In case the ActionDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionDefinitionUpdateInput, ActionDefinitionUncheckedUpdateInput>
  }

  /**
   * ActionDefinition delete
   */
  export type ActionDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionDefinition
     */
    select?: ActionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionDefinition
     */
    omit?: ActionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionDefinitionInclude<ExtArgs> | null
    /**
     * Filter which ActionDefinition to delete.
     */
    where: ActionDefinitionWhereUniqueInput
  }

  /**
   * ActionDefinition deleteMany
   */
  export type ActionDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionDefinitions to delete
     */
    where?: ActionDefinitionWhereInput
    /**
     * Limit how many ActionDefinitions to delete.
     */
    limit?: number
  }

  /**
   * ActionDefinition.step
   */
  export type ActionDefinition$stepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
  }

  /**
   * ActionDefinition without action
   */
  export type ActionDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionDefinition
     */
    select?: ActionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionDefinition
     */
    omit?: ActionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model TriggerDefinition
   */

  export type AggregateTriggerDefinition = {
    _count: TriggerDefinitionCountAggregateOutputType | null
    _avg: TriggerDefinitionAvgAggregateOutputType | null
    _sum: TriggerDefinitionSumAggregateOutputType | null
    _min: TriggerDefinitionMinAggregateOutputType | null
    _max: TriggerDefinitionMaxAggregateOutputType | null
  }

  export type TriggerDefinitionAvgAggregateOutputType = {
    order: number | null
  }

  export type TriggerDefinitionSumAggregateOutputType = {
    order: number | null
  }

  export type TriggerDefinitionMinAggregateOutputType = {
    id: string | null
    order: number | null
    isPublic: boolean | null
    createdBy: string | null
    triggerCode: string | null
    executeWhen: $Enums.TriggerEventCode | null
    executeAt: string | null
    combinator: $Enums.CombinatorEnum | null
    expiration: string | null
    stepId: string | null
  }

  export type TriggerDefinitionMaxAggregateOutputType = {
    id: string | null
    order: number | null
    isPublic: boolean | null
    createdBy: string | null
    triggerCode: string | null
    executeWhen: $Enums.TriggerEventCode | null
    executeAt: string | null
    combinator: $Enums.CombinatorEnum | null
    expiration: string | null
    stepId: string | null
  }

  export type TriggerDefinitionCountAggregateOutputType = {
    id: number
    order: number
    isPublic: number
    createdBy: number
    triggerCode: number
    executeWhen: number
    executeAt: number
    combinator: number
    config: number
    expiration: number
    stepId: number
    _all: number
  }


  export type TriggerDefinitionAvgAggregateInputType = {
    order?: true
  }

  export type TriggerDefinitionSumAggregateInputType = {
    order?: true
  }

  export type TriggerDefinitionMinAggregateInputType = {
    id?: true
    order?: true
    isPublic?: true
    createdBy?: true
    triggerCode?: true
    executeWhen?: true
    executeAt?: true
    combinator?: true
    expiration?: true
    stepId?: true
  }

  export type TriggerDefinitionMaxAggregateInputType = {
    id?: true
    order?: true
    isPublic?: true
    createdBy?: true
    triggerCode?: true
    executeWhen?: true
    executeAt?: true
    combinator?: true
    expiration?: true
    stepId?: true
  }

  export type TriggerDefinitionCountAggregateInputType = {
    id?: true
    order?: true
    isPublic?: true
    createdBy?: true
    triggerCode?: true
    executeWhen?: true
    executeAt?: true
    combinator?: true
    config?: true
    expiration?: true
    stepId?: true
    _all?: true
  }

  export type TriggerDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TriggerDefinition to aggregate.
     */
    where?: TriggerDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriggerDefinitions to fetch.
     */
    orderBy?: TriggerDefinitionOrderByWithRelationInput | TriggerDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TriggerDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` TriggerDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriggerDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TriggerDefinitions
    **/
    _count?: true | TriggerDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TriggerDefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TriggerDefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TriggerDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TriggerDefinitionMaxAggregateInputType
  }

  export type GetTriggerDefinitionAggregateType<T extends TriggerDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateTriggerDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTriggerDefinition[P]>
      : GetScalarType<T[P], AggregateTriggerDefinition[P]>
  }




  export type TriggerDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriggerDefinitionWhereInput
    orderBy?: TriggerDefinitionOrderByWithAggregationInput | TriggerDefinitionOrderByWithAggregationInput[]
    by: TriggerDefinitionScalarFieldEnum[] | TriggerDefinitionScalarFieldEnum
    having?: TriggerDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TriggerDefinitionCountAggregateInputType | true
    _avg?: TriggerDefinitionAvgAggregateInputType
    _sum?: TriggerDefinitionSumAggregateInputType
    _min?: TriggerDefinitionMinAggregateInputType
    _max?: TriggerDefinitionMaxAggregateInputType
  }

  export type TriggerDefinitionGroupByOutputType = {
    id: string
    order: number
    isPublic: boolean
    createdBy: string
    triggerCode: string
    executeWhen: $Enums.TriggerEventCode | null
    executeAt: string | null
    combinator: $Enums.CombinatorEnum | null
    config: JsonValue
    expiration: string | null
    stepId: string | null
    _count: TriggerDefinitionCountAggregateOutputType | null
    _avg: TriggerDefinitionAvgAggregateOutputType | null
    _sum: TriggerDefinitionSumAggregateOutputType | null
    _min: TriggerDefinitionMinAggregateOutputType | null
    _max: TriggerDefinitionMaxAggregateOutputType | null
  }

  type GetTriggerDefinitionGroupByPayload<T extends TriggerDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TriggerDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TriggerDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TriggerDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], TriggerDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type TriggerDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    isPublic?: boolean
    createdBy?: boolean
    triggerCode?: boolean
    executeWhen?: boolean
    executeAt?: boolean
    combinator?: boolean
    config?: boolean
    expiration?: boolean
    stepId?: boolean
    conditions?: boolean | TriggerDefinition$conditionsArgs<ExtArgs>
    step?: boolean | TriggerDefinition$stepArgs<ExtArgs>
    _count?: boolean | TriggerDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["triggerDefinition"]>

  export type TriggerDefinitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    isPublic?: boolean
    createdBy?: boolean
    triggerCode?: boolean
    executeWhen?: boolean
    executeAt?: boolean
    combinator?: boolean
    config?: boolean
    expiration?: boolean
    stepId?: boolean
    step?: boolean | TriggerDefinition$stepArgs<ExtArgs>
  }, ExtArgs["result"]["triggerDefinition"]>

  export type TriggerDefinitionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    isPublic?: boolean
    createdBy?: boolean
    triggerCode?: boolean
    executeWhen?: boolean
    executeAt?: boolean
    combinator?: boolean
    config?: boolean
    expiration?: boolean
    stepId?: boolean
    step?: boolean | TriggerDefinition$stepArgs<ExtArgs>
  }, ExtArgs["result"]["triggerDefinition"]>

  export type TriggerDefinitionSelectScalar = {
    id?: boolean
    order?: boolean
    isPublic?: boolean
    createdBy?: boolean
    triggerCode?: boolean
    executeWhen?: boolean
    executeAt?: boolean
    combinator?: boolean
    config?: boolean
    expiration?: boolean
    stepId?: boolean
  }

  export type TriggerDefinitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "order" | "isPublic" | "createdBy" | "triggerCode" | "executeWhen" | "executeAt" | "combinator" | "config" | "expiration" | "stepId", ExtArgs["result"]["triggerDefinition"]>
  export type TriggerDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conditions?: boolean | TriggerDefinition$conditionsArgs<ExtArgs>
    step?: boolean | TriggerDefinition$stepArgs<ExtArgs>
    _count?: boolean | TriggerDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TriggerDefinitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    step?: boolean | TriggerDefinition$stepArgs<ExtArgs>
  }
  export type TriggerDefinitionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    step?: boolean | TriggerDefinition$stepArgs<ExtArgs>
  }

  export type $TriggerDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TriggerDefinition"
    objects: {
      conditions: Prisma.$ConditionalPayload<ExtArgs>[]
      step: Prisma.$ProcessStepPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      order: number
      isPublic: boolean
      createdBy: string
      triggerCode: string
      executeWhen: $Enums.TriggerEventCode | null
      executeAt: string | null
      combinator: $Enums.CombinatorEnum | null
      config: Prisma.JsonValue
      expiration: string | null
      stepId: string | null
    }, ExtArgs["result"]["triggerDefinition"]>
    composites: {}
  }

  type TriggerDefinitionGetPayload<S extends boolean | null | undefined | TriggerDefinitionDefaultArgs> = $Result.GetResult<Prisma.$TriggerDefinitionPayload, S>

  type TriggerDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TriggerDefinitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TriggerDefinitionCountAggregateInputType | true
    }

  export interface TriggerDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TriggerDefinition'], meta: { name: 'TriggerDefinition' } }
    /**
     * Find zero or one TriggerDefinition that matches the filter.
     * @param {TriggerDefinitionFindUniqueArgs} args - Arguments to find a TriggerDefinition
     * @example
     * // Get one TriggerDefinition
     * const triggerDefinition = await prisma.triggerDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TriggerDefinitionFindUniqueArgs>(args: SelectSubset<T, TriggerDefinitionFindUniqueArgs<ExtArgs>>): Prisma__TriggerDefinitionClient<$Result.GetResult<Prisma.$TriggerDefinitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TriggerDefinition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TriggerDefinitionFindUniqueOrThrowArgs} args - Arguments to find a TriggerDefinition
     * @example
     * // Get one TriggerDefinition
     * const triggerDefinition = await prisma.triggerDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TriggerDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, TriggerDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TriggerDefinitionClient<$Result.GetResult<Prisma.$TriggerDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TriggerDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerDefinitionFindFirstArgs} args - Arguments to find a TriggerDefinition
     * @example
     * // Get one TriggerDefinition
     * const triggerDefinition = await prisma.triggerDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TriggerDefinitionFindFirstArgs>(args?: SelectSubset<T, TriggerDefinitionFindFirstArgs<ExtArgs>>): Prisma__TriggerDefinitionClient<$Result.GetResult<Prisma.$TriggerDefinitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TriggerDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerDefinitionFindFirstOrThrowArgs} args - Arguments to find a TriggerDefinition
     * @example
     * // Get one TriggerDefinition
     * const triggerDefinition = await prisma.triggerDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TriggerDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, TriggerDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TriggerDefinitionClient<$Result.GetResult<Prisma.$TriggerDefinitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TriggerDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TriggerDefinitions
     * const triggerDefinitions = await prisma.triggerDefinition.findMany()
     * 
     * // Get first 10 TriggerDefinitions
     * const triggerDefinitions = await prisma.triggerDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const triggerDefinitionWithIdOnly = await prisma.triggerDefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TriggerDefinitionFindManyArgs>(args?: SelectSubset<T, TriggerDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggerDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TriggerDefinition.
     * @param {TriggerDefinitionCreateArgs} args - Arguments to create a TriggerDefinition.
     * @example
     * // Create one TriggerDefinition
     * const TriggerDefinition = await prisma.triggerDefinition.create({
     *   data: {
     *     // ... data to create a TriggerDefinition
     *   }
     * })
     * 
     */
    create<T extends TriggerDefinitionCreateArgs>(args: SelectSubset<T, TriggerDefinitionCreateArgs<ExtArgs>>): Prisma__TriggerDefinitionClient<$Result.GetResult<Prisma.$TriggerDefinitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TriggerDefinitions.
     * @param {TriggerDefinitionCreateManyArgs} args - Arguments to create many TriggerDefinitions.
     * @example
     * // Create many TriggerDefinitions
     * const triggerDefinition = await prisma.triggerDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TriggerDefinitionCreateManyArgs>(args?: SelectSubset<T, TriggerDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TriggerDefinitions and returns the data saved in the database.
     * @param {TriggerDefinitionCreateManyAndReturnArgs} args - Arguments to create many TriggerDefinitions.
     * @example
     * // Create many TriggerDefinitions
     * const triggerDefinition = await prisma.triggerDefinition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TriggerDefinitions and only return the `id`
     * const triggerDefinitionWithIdOnly = await prisma.triggerDefinition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TriggerDefinitionCreateManyAndReturnArgs>(args?: SelectSubset<T, TriggerDefinitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggerDefinitionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TriggerDefinition.
     * @param {TriggerDefinitionDeleteArgs} args - Arguments to delete one TriggerDefinition.
     * @example
     * // Delete one TriggerDefinition
     * const TriggerDefinition = await prisma.triggerDefinition.delete({
     *   where: {
     *     // ... filter to delete one TriggerDefinition
     *   }
     * })
     * 
     */
    delete<T extends TriggerDefinitionDeleteArgs>(args: SelectSubset<T, TriggerDefinitionDeleteArgs<ExtArgs>>): Prisma__TriggerDefinitionClient<$Result.GetResult<Prisma.$TriggerDefinitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TriggerDefinition.
     * @param {TriggerDefinitionUpdateArgs} args - Arguments to update one TriggerDefinition.
     * @example
     * // Update one TriggerDefinition
     * const triggerDefinition = await prisma.triggerDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TriggerDefinitionUpdateArgs>(args: SelectSubset<T, TriggerDefinitionUpdateArgs<ExtArgs>>): Prisma__TriggerDefinitionClient<$Result.GetResult<Prisma.$TriggerDefinitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TriggerDefinitions.
     * @param {TriggerDefinitionDeleteManyArgs} args - Arguments to filter TriggerDefinitions to delete.
     * @example
     * // Delete a few TriggerDefinitions
     * const { count } = await prisma.triggerDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TriggerDefinitionDeleteManyArgs>(args?: SelectSubset<T, TriggerDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TriggerDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TriggerDefinitions
     * const triggerDefinition = await prisma.triggerDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TriggerDefinitionUpdateManyArgs>(args: SelectSubset<T, TriggerDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TriggerDefinitions and returns the data updated in the database.
     * @param {TriggerDefinitionUpdateManyAndReturnArgs} args - Arguments to update many TriggerDefinitions.
     * @example
     * // Update many TriggerDefinitions
     * const triggerDefinition = await prisma.triggerDefinition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TriggerDefinitions and only return the `id`
     * const triggerDefinitionWithIdOnly = await prisma.triggerDefinition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TriggerDefinitionUpdateManyAndReturnArgs>(args: SelectSubset<T, TriggerDefinitionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggerDefinitionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TriggerDefinition.
     * @param {TriggerDefinitionUpsertArgs} args - Arguments to update or create a TriggerDefinition.
     * @example
     * // Update or create a TriggerDefinition
     * const triggerDefinition = await prisma.triggerDefinition.upsert({
     *   create: {
     *     // ... data to create a TriggerDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TriggerDefinition we want to update
     *   }
     * })
     */
    upsert<T extends TriggerDefinitionUpsertArgs>(args: SelectSubset<T, TriggerDefinitionUpsertArgs<ExtArgs>>): Prisma__TriggerDefinitionClient<$Result.GetResult<Prisma.$TriggerDefinitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TriggerDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerDefinitionCountArgs} args - Arguments to filter TriggerDefinitions to count.
     * @example
     * // Count the number of TriggerDefinitions
     * const count = await prisma.triggerDefinition.count({
     *   where: {
     *     // ... the filter for the TriggerDefinitions we want to count
     *   }
     * })
    **/
    count<T extends TriggerDefinitionCountArgs>(
      args?: Subset<T, TriggerDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TriggerDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TriggerDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TriggerDefinitionAggregateArgs>(args: Subset<T, TriggerDefinitionAggregateArgs>): Prisma.PrismaPromise<GetTriggerDefinitionAggregateType<T>>

    /**
     * Group by TriggerDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TriggerDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TriggerDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: TriggerDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TriggerDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTriggerDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TriggerDefinition model
   */
  readonly fields: TriggerDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TriggerDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TriggerDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conditions<T extends TriggerDefinition$conditionsArgs<ExtArgs> = {}>(args?: Subset<T, TriggerDefinition$conditionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    step<T extends TriggerDefinition$stepArgs<ExtArgs> = {}>(args?: Subset<T, TriggerDefinition$stepArgs<ExtArgs>>): Prisma__ProcessStepClient<$Result.GetResult<Prisma.$ProcessStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TriggerDefinition model
   */
  interface TriggerDefinitionFieldRefs {
    readonly id: FieldRef<"TriggerDefinition", 'String'>
    readonly order: FieldRef<"TriggerDefinition", 'Int'>
    readonly isPublic: FieldRef<"TriggerDefinition", 'Boolean'>
    readonly createdBy: FieldRef<"TriggerDefinition", 'String'>
    readonly triggerCode: FieldRef<"TriggerDefinition", 'String'>
    readonly executeWhen: FieldRef<"TriggerDefinition", 'TriggerEventCode'>
    readonly executeAt: FieldRef<"TriggerDefinition", 'String'>
    readonly combinator: FieldRef<"TriggerDefinition", 'CombinatorEnum'>
    readonly config: FieldRef<"TriggerDefinition", 'Json'>
    readonly expiration: FieldRef<"TriggerDefinition", 'String'>
    readonly stepId: FieldRef<"TriggerDefinition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TriggerDefinition findUnique
   */
  export type TriggerDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerDefinition
     */
    select?: TriggerDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriggerDefinition
     */
    omit?: TriggerDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which TriggerDefinition to fetch.
     */
    where: TriggerDefinitionWhereUniqueInput
  }

  /**
   * TriggerDefinition findUniqueOrThrow
   */
  export type TriggerDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerDefinition
     */
    select?: TriggerDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriggerDefinition
     */
    omit?: TriggerDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which TriggerDefinition to fetch.
     */
    where: TriggerDefinitionWhereUniqueInput
  }

  /**
   * TriggerDefinition findFirst
   */
  export type TriggerDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerDefinition
     */
    select?: TriggerDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriggerDefinition
     */
    omit?: TriggerDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which TriggerDefinition to fetch.
     */
    where?: TriggerDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriggerDefinitions to fetch.
     */
    orderBy?: TriggerDefinitionOrderByWithRelationInput | TriggerDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriggerDefinitions.
     */
    cursor?: TriggerDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` TriggerDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriggerDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriggerDefinitions.
     */
    distinct?: TriggerDefinitionScalarFieldEnum | TriggerDefinitionScalarFieldEnum[]
  }

  /**
   * TriggerDefinition findFirstOrThrow
   */
  export type TriggerDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerDefinition
     */
    select?: TriggerDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriggerDefinition
     */
    omit?: TriggerDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which TriggerDefinition to fetch.
     */
    where?: TriggerDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriggerDefinitions to fetch.
     */
    orderBy?: TriggerDefinitionOrderByWithRelationInput | TriggerDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriggerDefinitions.
     */
    cursor?: TriggerDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` TriggerDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriggerDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriggerDefinitions.
     */
    distinct?: TriggerDefinitionScalarFieldEnum | TriggerDefinitionScalarFieldEnum[]
  }

  /**
   * TriggerDefinition findMany
   */
  export type TriggerDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerDefinition
     */
    select?: TriggerDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriggerDefinition
     */
    omit?: TriggerDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which TriggerDefinitions to fetch.
     */
    where?: TriggerDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriggerDefinitions to fetch.
     */
    orderBy?: TriggerDefinitionOrderByWithRelationInput | TriggerDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TriggerDefinitions.
     */
    cursor?: TriggerDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` TriggerDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriggerDefinitions.
     */
    skip?: number
    distinct?: TriggerDefinitionScalarFieldEnum | TriggerDefinitionScalarFieldEnum[]
  }

  /**
   * TriggerDefinition create
   */
  export type TriggerDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerDefinition
     */
    select?: TriggerDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriggerDefinition
     */
    omit?: TriggerDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a TriggerDefinition.
     */
    data: XOR<TriggerDefinitionCreateInput, TriggerDefinitionUncheckedCreateInput>
  }

  /**
   * TriggerDefinition createMany
   */
  export type TriggerDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TriggerDefinitions.
     */
    data: TriggerDefinitionCreateManyInput | TriggerDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TriggerDefinition createManyAndReturn
   */
  export type TriggerDefinitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerDefinition
     */
    select?: TriggerDefinitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TriggerDefinition
     */
    omit?: TriggerDefinitionOmit<ExtArgs> | null
    /**
     * The data used to create many TriggerDefinitions.
     */
    data: TriggerDefinitionCreateManyInput | TriggerDefinitionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerDefinitionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TriggerDefinition update
   */
  export type TriggerDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerDefinition
     */
    select?: TriggerDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriggerDefinition
     */
    omit?: TriggerDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a TriggerDefinition.
     */
    data: XOR<TriggerDefinitionUpdateInput, TriggerDefinitionUncheckedUpdateInput>
    /**
     * Choose, which TriggerDefinition to update.
     */
    where: TriggerDefinitionWhereUniqueInput
  }

  /**
   * TriggerDefinition updateMany
   */
  export type TriggerDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TriggerDefinitions.
     */
    data: XOR<TriggerDefinitionUpdateManyMutationInput, TriggerDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which TriggerDefinitions to update
     */
    where?: TriggerDefinitionWhereInput
    /**
     * Limit how many TriggerDefinitions to update.
     */
    limit?: number
  }

  /**
   * TriggerDefinition updateManyAndReturn
   */
  export type TriggerDefinitionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerDefinition
     */
    select?: TriggerDefinitionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TriggerDefinition
     */
    omit?: TriggerDefinitionOmit<ExtArgs> | null
    /**
     * The data used to update TriggerDefinitions.
     */
    data: XOR<TriggerDefinitionUpdateManyMutationInput, TriggerDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which TriggerDefinitions to update
     */
    where?: TriggerDefinitionWhereInput
    /**
     * Limit how many TriggerDefinitions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerDefinitionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TriggerDefinition upsert
   */
  export type TriggerDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerDefinition
     */
    select?: TriggerDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriggerDefinition
     */
    omit?: TriggerDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the TriggerDefinition to update in case it exists.
     */
    where: TriggerDefinitionWhereUniqueInput
    /**
     * In case the TriggerDefinition found by the `where` argument doesn't exist, create a new TriggerDefinition with this data.
     */
    create: XOR<TriggerDefinitionCreateInput, TriggerDefinitionUncheckedCreateInput>
    /**
     * In case the TriggerDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TriggerDefinitionUpdateInput, TriggerDefinitionUncheckedUpdateInput>
  }

  /**
   * TriggerDefinition delete
   */
  export type TriggerDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerDefinition
     */
    select?: TriggerDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriggerDefinition
     */
    omit?: TriggerDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerDefinitionInclude<ExtArgs> | null
    /**
     * Filter which TriggerDefinition to delete.
     */
    where: TriggerDefinitionWhereUniqueInput
  }

  /**
   * TriggerDefinition deleteMany
   */
  export type TriggerDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TriggerDefinitions to delete
     */
    where?: TriggerDefinitionWhereInput
    /**
     * Limit how many TriggerDefinitions to delete.
     */
    limit?: number
  }

  /**
   * TriggerDefinition.conditions
   */
  export type TriggerDefinition$conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditional
     */
    select?: ConditionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditional
     */
    omit?: ConditionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionalInclude<ExtArgs> | null
    where?: ConditionalWhereInput
    orderBy?: ConditionalOrderByWithRelationInput | ConditionalOrderByWithRelationInput[]
    cursor?: ConditionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConditionalScalarFieldEnum | ConditionalScalarFieldEnum[]
  }

  /**
   * TriggerDefinition.step
   */
  export type TriggerDefinition$stepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessStep
     */
    select?: ProcessStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessStep
     */
    omit?: ProcessStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessStepInclude<ExtArgs> | null
    where?: ProcessStepWhereInput
  }

  /**
   * TriggerDefinition without action
   */
  export type TriggerDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerDefinition
     */
    select?: TriggerDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriggerDefinition
     */
    omit?: TriggerDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model Conditional
   */

  export type AggregateConditional = {
    _count: ConditionalCountAggregateOutputType | null
    _min: ConditionalMinAggregateOutputType | null
    _max: ConditionalMaxAggregateOutputType | null
  }

  export type ConditionalMinAggregateOutputType = {
    id: string | null
    triggerId: string | null
    fieldKey: string | null
    fieldKeyLabel: string | null
    operator: $Enums.ComparisonOperatorEnum | null
    comparisonValue: string | null
    combinator: $Enums.CombinatorEnum | null
  }

  export type ConditionalMaxAggregateOutputType = {
    id: string | null
    triggerId: string | null
    fieldKey: string | null
    fieldKeyLabel: string | null
    operator: $Enums.ComparisonOperatorEnum | null
    comparisonValue: string | null
    combinator: $Enums.CombinatorEnum | null
  }

  export type ConditionalCountAggregateOutputType = {
    id: number
    triggerId: number
    fieldKey: number
    fieldKeyLabel: number
    operator: number
    comparisonValue: number
    combinator: number
    _all: number
  }


  export type ConditionalMinAggregateInputType = {
    id?: true
    triggerId?: true
    fieldKey?: true
    fieldKeyLabel?: true
    operator?: true
    comparisonValue?: true
    combinator?: true
  }

  export type ConditionalMaxAggregateInputType = {
    id?: true
    triggerId?: true
    fieldKey?: true
    fieldKeyLabel?: true
    operator?: true
    comparisonValue?: true
    combinator?: true
  }

  export type ConditionalCountAggregateInputType = {
    id?: true
    triggerId?: true
    fieldKey?: true
    fieldKeyLabel?: true
    operator?: true
    comparisonValue?: true
    combinator?: true
    _all?: true
  }

  export type ConditionalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conditional to aggregate.
     */
    where?: ConditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditionals to fetch.
     */
    orderBy?: ConditionalOrderByWithRelationInput | ConditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Conditionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conditionals
    **/
    _count?: true | ConditionalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConditionalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConditionalMaxAggregateInputType
  }

  export type GetConditionalAggregateType<T extends ConditionalAggregateArgs> = {
        [P in keyof T & keyof AggregateConditional]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConditional[P]>
      : GetScalarType<T[P], AggregateConditional[P]>
  }




  export type ConditionalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConditionalWhereInput
    orderBy?: ConditionalOrderByWithAggregationInput | ConditionalOrderByWithAggregationInput[]
    by: ConditionalScalarFieldEnum[] | ConditionalScalarFieldEnum
    having?: ConditionalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConditionalCountAggregateInputType | true
    _min?: ConditionalMinAggregateInputType
    _max?: ConditionalMaxAggregateInputType
  }

  export type ConditionalGroupByOutputType = {
    id: string
    triggerId: string
    fieldKey: string
    fieldKeyLabel: string
    operator: $Enums.ComparisonOperatorEnum
    comparisonValue: string
    combinator: $Enums.CombinatorEnum | null
    _count: ConditionalCountAggregateOutputType | null
    _min: ConditionalMinAggregateOutputType | null
    _max: ConditionalMaxAggregateOutputType | null
  }

  type GetConditionalGroupByPayload<T extends ConditionalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConditionalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConditionalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConditionalGroupByOutputType[P]>
            : GetScalarType<T[P], ConditionalGroupByOutputType[P]>
        }
      >
    >


  export type ConditionalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    triggerId?: boolean
    fieldKey?: boolean
    fieldKeyLabel?: boolean
    operator?: boolean
    comparisonValue?: boolean
    combinator?: boolean
    trigger?: boolean | TriggerDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conditional"]>

  export type ConditionalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    triggerId?: boolean
    fieldKey?: boolean
    fieldKeyLabel?: boolean
    operator?: boolean
    comparisonValue?: boolean
    combinator?: boolean
    trigger?: boolean | TriggerDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conditional"]>

  export type ConditionalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    triggerId?: boolean
    fieldKey?: boolean
    fieldKeyLabel?: boolean
    operator?: boolean
    comparisonValue?: boolean
    combinator?: boolean
    trigger?: boolean | TriggerDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conditional"]>

  export type ConditionalSelectScalar = {
    id?: boolean
    triggerId?: boolean
    fieldKey?: boolean
    fieldKeyLabel?: boolean
    operator?: boolean
    comparisonValue?: boolean
    combinator?: boolean
  }

  export type ConditionalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "triggerId" | "fieldKey" | "fieldKeyLabel" | "operator" | "comparisonValue" | "combinator", ExtArgs["result"]["conditional"]>
  export type ConditionalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trigger?: boolean | TriggerDefinitionDefaultArgs<ExtArgs>
  }
  export type ConditionalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trigger?: boolean | TriggerDefinitionDefaultArgs<ExtArgs>
  }
  export type ConditionalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trigger?: boolean | TriggerDefinitionDefaultArgs<ExtArgs>
  }

  export type $ConditionalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conditional"
    objects: {
      trigger: Prisma.$TriggerDefinitionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      triggerId: string
      fieldKey: string
      fieldKeyLabel: string
      operator: $Enums.ComparisonOperatorEnum
      comparisonValue: string
      combinator: $Enums.CombinatorEnum | null
    }, ExtArgs["result"]["conditional"]>
    composites: {}
  }

  type ConditionalGetPayload<S extends boolean | null | undefined | ConditionalDefaultArgs> = $Result.GetResult<Prisma.$ConditionalPayload, S>

  type ConditionalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConditionalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConditionalCountAggregateInputType | true
    }

  export interface ConditionalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conditional'], meta: { name: 'Conditional' } }
    /**
     * Find zero or one Conditional that matches the filter.
     * @param {ConditionalFindUniqueArgs} args - Arguments to find a Conditional
     * @example
     * // Get one Conditional
     * const conditional = await prisma.conditional.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConditionalFindUniqueArgs>(args: SelectSubset<T, ConditionalFindUniqueArgs<ExtArgs>>): Prisma__ConditionalClient<$Result.GetResult<Prisma.$ConditionalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conditional that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConditionalFindUniqueOrThrowArgs} args - Arguments to find a Conditional
     * @example
     * // Get one Conditional
     * const conditional = await prisma.conditional.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConditionalFindUniqueOrThrowArgs>(args: SelectSubset<T, ConditionalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConditionalClient<$Result.GetResult<Prisma.$ConditionalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conditional that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalFindFirstArgs} args - Arguments to find a Conditional
     * @example
     * // Get one Conditional
     * const conditional = await prisma.conditional.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConditionalFindFirstArgs>(args?: SelectSubset<T, ConditionalFindFirstArgs<ExtArgs>>): Prisma__ConditionalClient<$Result.GetResult<Prisma.$ConditionalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conditional that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalFindFirstOrThrowArgs} args - Arguments to find a Conditional
     * @example
     * // Get one Conditional
     * const conditional = await prisma.conditional.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConditionalFindFirstOrThrowArgs>(args?: SelectSubset<T, ConditionalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConditionalClient<$Result.GetResult<Prisma.$ConditionalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conditionals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conditionals
     * const conditionals = await prisma.conditional.findMany()
     * 
     * // Get first 10 Conditionals
     * const conditionals = await prisma.conditional.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conditionalWithIdOnly = await prisma.conditional.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConditionalFindManyArgs>(args?: SelectSubset<T, ConditionalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conditional.
     * @param {ConditionalCreateArgs} args - Arguments to create a Conditional.
     * @example
     * // Create one Conditional
     * const Conditional = await prisma.conditional.create({
     *   data: {
     *     // ... data to create a Conditional
     *   }
     * })
     * 
     */
    create<T extends ConditionalCreateArgs>(args: SelectSubset<T, ConditionalCreateArgs<ExtArgs>>): Prisma__ConditionalClient<$Result.GetResult<Prisma.$ConditionalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conditionals.
     * @param {ConditionalCreateManyArgs} args - Arguments to create many Conditionals.
     * @example
     * // Create many Conditionals
     * const conditional = await prisma.conditional.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConditionalCreateManyArgs>(args?: SelectSubset<T, ConditionalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conditionals and returns the data saved in the database.
     * @param {ConditionalCreateManyAndReturnArgs} args - Arguments to create many Conditionals.
     * @example
     * // Create many Conditionals
     * const conditional = await prisma.conditional.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conditionals and only return the `id`
     * const conditionalWithIdOnly = await prisma.conditional.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConditionalCreateManyAndReturnArgs>(args?: SelectSubset<T, ConditionalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conditional.
     * @param {ConditionalDeleteArgs} args - Arguments to delete one Conditional.
     * @example
     * // Delete one Conditional
     * const Conditional = await prisma.conditional.delete({
     *   where: {
     *     // ... filter to delete one Conditional
     *   }
     * })
     * 
     */
    delete<T extends ConditionalDeleteArgs>(args: SelectSubset<T, ConditionalDeleteArgs<ExtArgs>>): Prisma__ConditionalClient<$Result.GetResult<Prisma.$ConditionalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conditional.
     * @param {ConditionalUpdateArgs} args - Arguments to update one Conditional.
     * @example
     * // Update one Conditional
     * const conditional = await prisma.conditional.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConditionalUpdateArgs>(args: SelectSubset<T, ConditionalUpdateArgs<ExtArgs>>): Prisma__ConditionalClient<$Result.GetResult<Prisma.$ConditionalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conditionals.
     * @param {ConditionalDeleteManyArgs} args - Arguments to filter Conditionals to delete.
     * @example
     * // Delete a few Conditionals
     * const { count } = await prisma.conditional.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConditionalDeleteManyArgs>(args?: SelectSubset<T, ConditionalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conditionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conditionals
     * const conditional = await prisma.conditional.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConditionalUpdateManyArgs>(args: SelectSubset<T, ConditionalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conditionals and returns the data updated in the database.
     * @param {ConditionalUpdateManyAndReturnArgs} args - Arguments to update many Conditionals.
     * @example
     * // Update many Conditionals
     * const conditional = await prisma.conditional.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conditionals and only return the `id`
     * const conditionalWithIdOnly = await prisma.conditional.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConditionalUpdateManyAndReturnArgs>(args: SelectSubset<T, ConditionalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conditional.
     * @param {ConditionalUpsertArgs} args - Arguments to update or create a Conditional.
     * @example
     * // Update or create a Conditional
     * const conditional = await prisma.conditional.upsert({
     *   create: {
     *     // ... data to create a Conditional
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conditional we want to update
     *   }
     * })
     */
    upsert<T extends ConditionalUpsertArgs>(args: SelectSubset<T, ConditionalUpsertArgs<ExtArgs>>): Prisma__ConditionalClient<$Result.GetResult<Prisma.$ConditionalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conditionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalCountArgs} args - Arguments to filter Conditionals to count.
     * @example
     * // Count the number of Conditionals
     * const count = await prisma.conditional.count({
     *   where: {
     *     // ... the filter for the Conditionals we want to count
     *   }
     * })
    **/
    count<T extends ConditionalCountArgs>(
      args?: Subset<T, ConditionalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConditionalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conditional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConditionalAggregateArgs>(args: Subset<T, ConditionalAggregateArgs>): Prisma.PrismaPromise<GetConditionalAggregateType<T>>

    /**
     * Group by Conditional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConditionalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConditionalGroupByArgs['orderBy'] }
        : { orderBy?: ConditionalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConditionalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConditionalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conditional model
   */
  readonly fields: ConditionalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conditional.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConditionalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trigger<T extends TriggerDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TriggerDefinitionDefaultArgs<ExtArgs>>): Prisma__TriggerDefinitionClient<$Result.GetResult<Prisma.$TriggerDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conditional model
   */
  interface ConditionalFieldRefs {
    readonly id: FieldRef<"Conditional", 'String'>
    readonly triggerId: FieldRef<"Conditional", 'String'>
    readonly fieldKey: FieldRef<"Conditional", 'String'>
    readonly fieldKeyLabel: FieldRef<"Conditional", 'String'>
    readonly operator: FieldRef<"Conditional", 'ComparisonOperatorEnum'>
    readonly comparisonValue: FieldRef<"Conditional", 'String'>
    readonly combinator: FieldRef<"Conditional", 'CombinatorEnum'>
  }
    

  // Custom InputTypes
  /**
   * Conditional findUnique
   */
  export type ConditionalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditional
     */
    select?: ConditionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditional
     */
    omit?: ConditionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionalInclude<ExtArgs> | null
    /**
     * Filter, which Conditional to fetch.
     */
    where: ConditionalWhereUniqueInput
  }

  /**
   * Conditional findUniqueOrThrow
   */
  export type ConditionalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditional
     */
    select?: ConditionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditional
     */
    omit?: ConditionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionalInclude<ExtArgs> | null
    /**
     * Filter, which Conditional to fetch.
     */
    where: ConditionalWhereUniqueInput
  }

  /**
   * Conditional findFirst
   */
  export type ConditionalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditional
     */
    select?: ConditionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditional
     */
    omit?: ConditionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionalInclude<ExtArgs> | null
    /**
     * Filter, which Conditional to fetch.
     */
    where?: ConditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditionals to fetch.
     */
    orderBy?: ConditionalOrderByWithRelationInput | ConditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conditionals.
     */
    cursor?: ConditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Conditionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conditionals.
     */
    distinct?: ConditionalScalarFieldEnum | ConditionalScalarFieldEnum[]
  }

  /**
   * Conditional findFirstOrThrow
   */
  export type ConditionalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditional
     */
    select?: ConditionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditional
     */
    omit?: ConditionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionalInclude<ExtArgs> | null
    /**
     * Filter, which Conditional to fetch.
     */
    where?: ConditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditionals to fetch.
     */
    orderBy?: ConditionalOrderByWithRelationInput | ConditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conditionals.
     */
    cursor?: ConditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Conditionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conditionals.
     */
    distinct?: ConditionalScalarFieldEnum | ConditionalScalarFieldEnum[]
  }

  /**
   * Conditional findMany
   */
  export type ConditionalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditional
     */
    select?: ConditionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditional
     */
    omit?: ConditionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionalInclude<ExtArgs> | null
    /**
     * Filter, which Conditionals to fetch.
     */
    where?: ConditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditionals to fetch.
     */
    orderBy?: ConditionalOrderByWithRelationInput | ConditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conditionals.
     */
    cursor?: ConditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Conditionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditionals.
     */
    skip?: number
    distinct?: ConditionalScalarFieldEnum | ConditionalScalarFieldEnum[]
  }

  /**
   * Conditional create
   */
  export type ConditionalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditional
     */
    select?: ConditionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditional
     */
    omit?: ConditionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionalInclude<ExtArgs> | null
    /**
     * The data needed to create a Conditional.
     */
    data: XOR<ConditionalCreateInput, ConditionalUncheckedCreateInput>
  }

  /**
   * Conditional createMany
   */
  export type ConditionalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conditionals.
     */
    data: ConditionalCreateManyInput | ConditionalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conditional createManyAndReturn
   */
  export type ConditionalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditional
     */
    select?: ConditionalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conditional
     */
    omit?: ConditionalOmit<ExtArgs> | null
    /**
     * The data used to create many Conditionals.
     */
    data: ConditionalCreateManyInput | ConditionalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conditional update
   */
  export type ConditionalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditional
     */
    select?: ConditionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditional
     */
    omit?: ConditionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionalInclude<ExtArgs> | null
    /**
     * The data needed to update a Conditional.
     */
    data: XOR<ConditionalUpdateInput, ConditionalUncheckedUpdateInput>
    /**
     * Choose, which Conditional to update.
     */
    where: ConditionalWhereUniqueInput
  }

  /**
   * Conditional updateMany
   */
  export type ConditionalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conditionals.
     */
    data: XOR<ConditionalUpdateManyMutationInput, ConditionalUncheckedUpdateManyInput>
    /**
     * Filter which Conditionals to update
     */
    where?: ConditionalWhereInput
    /**
     * Limit how many Conditionals to update.
     */
    limit?: number
  }

  /**
   * Conditional updateManyAndReturn
   */
  export type ConditionalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditional
     */
    select?: ConditionalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conditional
     */
    omit?: ConditionalOmit<ExtArgs> | null
    /**
     * The data used to update Conditionals.
     */
    data: XOR<ConditionalUpdateManyMutationInput, ConditionalUncheckedUpdateManyInput>
    /**
     * Filter which Conditionals to update
     */
    where?: ConditionalWhereInput
    /**
     * Limit how many Conditionals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conditional upsert
   */
  export type ConditionalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditional
     */
    select?: ConditionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditional
     */
    omit?: ConditionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionalInclude<ExtArgs> | null
    /**
     * The filter to search for the Conditional to update in case it exists.
     */
    where: ConditionalWhereUniqueInput
    /**
     * In case the Conditional found by the `where` argument doesn't exist, create a new Conditional with this data.
     */
    create: XOR<ConditionalCreateInput, ConditionalUncheckedCreateInput>
    /**
     * In case the Conditional was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConditionalUpdateInput, ConditionalUncheckedUpdateInput>
  }

  /**
   * Conditional delete
   */
  export type ConditionalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditional
     */
    select?: ConditionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditional
     */
    omit?: ConditionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionalInclude<ExtArgs> | null
    /**
     * Filter which Conditional to delete.
     */
    where: ConditionalWhereUniqueInput
  }

  /**
   * Conditional deleteMany
   */
  export type ConditionalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conditionals to delete
     */
    where?: ConditionalWhereInput
    /**
     * Limit how many Conditionals to delete.
     */
    limit?: number
  }

  /**
   * Conditional without action
   */
  export type ConditionalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conditional
     */
    select?: ConditionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conditional
     */
    omit?: ConditionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionalInclude<ExtArgs> | null
  }


  /**
   * Model Todo
   */

  export type AggregateTodo = {
    _count: TodoCountAggregateOutputType | null
    _min: TodoMinAggregateOutputType | null
    _max: TodoMaxAggregateOutputType | null
  }

  export type TodoMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    dueDate: Date | null
    completed: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodoMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    dueDate: Date | null
    completed: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodoCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    dueDate: number
    completed: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TodoMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    dueDate?: true
    completed?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodoMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    dueDate?: true
    completed?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodoCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    dueDate?: true
    completed?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TodoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Todo to aggregate.
     */
    where?: TodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todos to fetch.
     */
    orderBy?: TodoOrderByWithRelationInput | TodoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Todos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Todos
    **/
    _count?: true | TodoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TodoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TodoMaxAggregateInputType
  }

  export type GetTodoAggregateType<T extends TodoAggregateArgs> = {
        [P in keyof T & keyof AggregateTodo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTodo[P]>
      : GetScalarType<T[P], AggregateTodo[P]>
  }




  export type TodoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TodoWhereInput
    orderBy?: TodoOrderByWithAggregationInput | TodoOrderByWithAggregationInput[]
    by: TodoScalarFieldEnum[] | TodoScalarFieldEnum
    having?: TodoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TodoCountAggregateInputType | true
    _min?: TodoMinAggregateInputType
    _max?: TodoMaxAggregateInputType
  }

  export type TodoGroupByOutputType = {
    id: string
    userId: string
    title: string
    dueDate: Date
    completed: boolean
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TodoCountAggregateOutputType | null
    _min: TodoMinAggregateOutputType | null
    _max: TodoMaxAggregateOutputType | null
  }

  type GetTodoGroupByPayload<T extends TodoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TodoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TodoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TodoGroupByOutputType[P]>
            : GetScalarType<T[P], TodoGroupByOutputType[P]>
        }
      >
    >


  export type TodoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    dueDate?: boolean
    completed?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Todo$itemsArgs<ExtArgs>
    userProcesses?: boolean | Todo$userProcessesArgs<ExtArgs>
    _count?: boolean | TodoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todo"]>

  export type TodoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    dueDate?: boolean
    completed?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todo"]>

  export type TodoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    dueDate?: boolean
    completed?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todo"]>

  export type TodoSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    dueDate?: boolean
    completed?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TodoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "dueDate" | "completed" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["todo"]>
  export type TodoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Todo$itemsArgs<ExtArgs>
    userProcesses?: boolean | Todo$userProcessesArgs<ExtArgs>
    _count?: boolean | TodoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TodoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TodoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TodoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Todo"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$TodoItemPayload<ExtArgs>[]
      userProcesses: Prisma.$TodoUserProcessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      dueDate: Date
      completed: boolean
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["todo"]>
    composites: {}
  }

  type TodoGetPayload<S extends boolean | null | undefined | TodoDefaultArgs> = $Result.GetResult<Prisma.$TodoPayload, S>

  type TodoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TodoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TodoCountAggregateInputType | true
    }

  export interface TodoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Todo'], meta: { name: 'Todo' } }
    /**
     * Find zero or one Todo that matches the filter.
     * @param {TodoFindUniqueArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TodoFindUniqueArgs>(args: SelectSubset<T, TodoFindUniqueArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Todo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TodoFindUniqueOrThrowArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TodoFindUniqueOrThrowArgs>(args: SelectSubset<T, TodoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Todo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoFindFirstArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TodoFindFirstArgs>(args?: SelectSubset<T, TodoFindFirstArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Todo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoFindFirstOrThrowArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TodoFindFirstOrThrowArgs>(args?: SelectSubset<T, TodoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Todos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Todos
     * const todos = await prisma.todo.findMany()
     * 
     * // Get first 10 Todos
     * const todos = await prisma.todo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const todoWithIdOnly = await prisma.todo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TodoFindManyArgs>(args?: SelectSubset<T, TodoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Todo.
     * @param {TodoCreateArgs} args - Arguments to create a Todo.
     * @example
     * // Create one Todo
     * const Todo = await prisma.todo.create({
     *   data: {
     *     // ... data to create a Todo
     *   }
     * })
     * 
     */
    create<T extends TodoCreateArgs>(args: SelectSubset<T, TodoCreateArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Todos.
     * @param {TodoCreateManyArgs} args - Arguments to create many Todos.
     * @example
     * // Create many Todos
     * const todo = await prisma.todo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TodoCreateManyArgs>(args?: SelectSubset<T, TodoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Todos and returns the data saved in the database.
     * @param {TodoCreateManyAndReturnArgs} args - Arguments to create many Todos.
     * @example
     * // Create many Todos
     * const todo = await prisma.todo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Todos and only return the `id`
     * const todoWithIdOnly = await prisma.todo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TodoCreateManyAndReturnArgs>(args?: SelectSubset<T, TodoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Todo.
     * @param {TodoDeleteArgs} args - Arguments to delete one Todo.
     * @example
     * // Delete one Todo
     * const Todo = await prisma.todo.delete({
     *   where: {
     *     // ... filter to delete one Todo
     *   }
     * })
     * 
     */
    delete<T extends TodoDeleteArgs>(args: SelectSubset<T, TodoDeleteArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Todo.
     * @param {TodoUpdateArgs} args - Arguments to update one Todo.
     * @example
     * // Update one Todo
     * const todo = await prisma.todo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TodoUpdateArgs>(args: SelectSubset<T, TodoUpdateArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Todos.
     * @param {TodoDeleteManyArgs} args - Arguments to filter Todos to delete.
     * @example
     * // Delete a few Todos
     * const { count } = await prisma.todo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TodoDeleteManyArgs>(args?: SelectSubset<T, TodoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Todos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Todos
     * const todo = await prisma.todo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TodoUpdateManyArgs>(args: SelectSubset<T, TodoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Todos and returns the data updated in the database.
     * @param {TodoUpdateManyAndReturnArgs} args - Arguments to update many Todos.
     * @example
     * // Update many Todos
     * const todo = await prisma.todo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Todos and only return the `id`
     * const todoWithIdOnly = await prisma.todo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TodoUpdateManyAndReturnArgs>(args: SelectSubset<T, TodoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Todo.
     * @param {TodoUpsertArgs} args - Arguments to update or create a Todo.
     * @example
     * // Update or create a Todo
     * const todo = await prisma.todo.upsert({
     *   create: {
     *     // ... data to create a Todo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Todo we want to update
     *   }
     * })
     */
    upsert<T extends TodoUpsertArgs>(args: SelectSubset<T, TodoUpsertArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Todos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoCountArgs} args - Arguments to filter Todos to count.
     * @example
     * // Count the number of Todos
     * const count = await prisma.todo.count({
     *   where: {
     *     // ... the filter for the Todos we want to count
     *   }
     * })
    **/
    count<T extends TodoCountArgs>(
      args?: Subset<T, TodoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TodoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Todo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TodoAggregateArgs>(args: Subset<T, TodoAggregateArgs>): Prisma.PrismaPromise<GetTodoAggregateType<T>>

    /**
     * Group by Todo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TodoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TodoGroupByArgs['orderBy'] }
        : { orderBy?: TodoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TodoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Todo model
   */
  readonly fields: TodoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Todo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TodoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Todo$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Todo$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userProcesses<T extends Todo$userProcessesArgs<ExtArgs> = {}>(args?: Subset<T, Todo$userProcessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoUserProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Todo model
   */
  interface TodoFieldRefs {
    readonly id: FieldRef<"Todo", 'String'>
    readonly userId: FieldRef<"Todo", 'String'>
    readonly title: FieldRef<"Todo", 'String'>
    readonly dueDate: FieldRef<"Todo", 'DateTime'>
    readonly completed: FieldRef<"Todo", 'Boolean'>
    readonly completedAt: FieldRef<"Todo", 'DateTime'>
    readonly createdAt: FieldRef<"Todo", 'DateTime'>
    readonly updatedAt: FieldRef<"Todo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Todo findUnique
   */
  export type TodoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * Filter, which Todo to fetch.
     */
    where: TodoWhereUniqueInput
  }

  /**
   * Todo findUniqueOrThrow
   */
  export type TodoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * Filter, which Todo to fetch.
     */
    where: TodoWhereUniqueInput
  }

  /**
   * Todo findFirst
   */
  export type TodoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * Filter, which Todo to fetch.
     */
    where?: TodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todos to fetch.
     */
    orderBy?: TodoOrderByWithRelationInput | TodoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Todos.
     */
    cursor?: TodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Todos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Todos.
     */
    distinct?: TodoScalarFieldEnum | TodoScalarFieldEnum[]
  }

  /**
   * Todo findFirstOrThrow
   */
  export type TodoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * Filter, which Todo to fetch.
     */
    where?: TodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todos to fetch.
     */
    orderBy?: TodoOrderByWithRelationInput | TodoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Todos.
     */
    cursor?: TodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Todos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Todos.
     */
    distinct?: TodoScalarFieldEnum | TodoScalarFieldEnum[]
  }

  /**
   * Todo findMany
   */
  export type TodoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * Filter, which Todos to fetch.
     */
    where?: TodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todos to fetch.
     */
    orderBy?: TodoOrderByWithRelationInput | TodoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Todos.
     */
    cursor?: TodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Todos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todos.
     */
    skip?: number
    distinct?: TodoScalarFieldEnum | TodoScalarFieldEnum[]
  }

  /**
   * Todo create
   */
  export type TodoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * The data needed to create a Todo.
     */
    data: XOR<TodoCreateInput, TodoUncheckedCreateInput>
  }

  /**
   * Todo createMany
   */
  export type TodoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Todos.
     */
    data: TodoCreateManyInput | TodoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Todo createManyAndReturn
   */
  export type TodoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * The data used to create many Todos.
     */
    data: TodoCreateManyInput | TodoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Todo update
   */
  export type TodoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * The data needed to update a Todo.
     */
    data: XOR<TodoUpdateInput, TodoUncheckedUpdateInput>
    /**
     * Choose, which Todo to update.
     */
    where: TodoWhereUniqueInput
  }

  /**
   * Todo updateMany
   */
  export type TodoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Todos.
     */
    data: XOR<TodoUpdateManyMutationInput, TodoUncheckedUpdateManyInput>
    /**
     * Filter which Todos to update
     */
    where?: TodoWhereInput
    /**
     * Limit how many Todos to update.
     */
    limit?: number
  }

  /**
   * Todo updateManyAndReturn
   */
  export type TodoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * The data used to update Todos.
     */
    data: XOR<TodoUpdateManyMutationInput, TodoUncheckedUpdateManyInput>
    /**
     * Filter which Todos to update
     */
    where?: TodoWhereInput
    /**
     * Limit how many Todos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Todo upsert
   */
  export type TodoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * The filter to search for the Todo to update in case it exists.
     */
    where: TodoWhereUniqueInput
    /**
     * In case the Todo found by the `where` argument doesn't exist, create a new Todo with this data.
     */
    create: XOR<TodoCreateInput, TodoUncheckedCreateInput>
    /**
     * In case the Todo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TodoUpdateInput, TodoUncheckedUpdateInput>
  }

  /**
   * Todo delete
   */
  export type TodoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * Filter which Todo to delete.
     */
    where: TodoWhereUniqueInput
  }

  /**
   * Todo deleteMany
   */
  export type TodoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Todos to delete
     */
    where?: TodoWhereInput
    /**
     * Limit how many Todos to delete.
     */
    limit?: number
  }

  /**
   * Todo.items
   */
  export type Todo$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    where?: TodoItemWhereInput
    orderBy?: TodoItemOrderByWithRelationInput | TodoItemOrderByWithRelationInput[]
    cursor?: TodoItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TodoItemScalarFieldEnum | TodoItemScalarFieldEnum[]
  }

  /**
   * Todo.userProcesses
   */
  export type Todo$userProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoUserProcess
     */
    select?: TodoUserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoUserProcess
     */
    omit?: TodoUserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoUserProcessInclude<ExtArgs> | null
    where?: TodoUserProcessWhereInput
    orderBy?: TodoUserProcessOrderByWithRelationInput | TodoUserProcessOrderByWithRelationInput[]
    cursor?: TodoUserProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TodoUserProcessScalarFieldEnum | TodoUserProcessScalarFieldEnum[]
  }

  /**
   * Todo without action
   */
  export type TodoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
  }


  /**
   * Model TodoItem
   */

  export type AggregateTodoItem = {
    _count: TodoItemCountAggregateOutputType | null
    _avg: TodoItemAvgAggregateOutputType | null
    _sum: TodoItemSumAggregateOutputType | null
    _min: TodoItemMinAggregateOutputType | null
    _max: TodoItemMaxAggregateOutputType | null
  }

  export type TodoItemAvgAggregateOutputType = {
    order: number | null
  }

  export type TodoItemSumAggregateOutputType = {
    order: number | null
  }

  export type TodoItemMinAggregateOutputType = {
    id: string | null
    todoId: string | null
    type: $Enums.TodoItemTypeEnum | null
    content: string | null
    order: number | null
  }

  export type TodoItemMaxAggregateOutputType = {
    id: string | null
    todoId: string | null
    type: $Enums.TodoItemTypeEnum | null
    content: string | null
    order: number | null
  }

  export type TodoItemCountAggregateOutputType = {
    id: number
    todoId: number
    type: number
    content: number
    order: number
    _all: number
  }


  export type TodoItemAvgAggregateInputType = {
    order?: true
  }

  export type TodoItemSumAggregateInputType = {
    order?: true
  }

  export type TodoItemMinAggregateInputType = {
    id?: true
    todoId?: true
    type?: true
    content?: true
    order?: true
  }

  export type TodoItemMaxAggregateInputType = {
    id?: true
    todoId?: true
    type?: true
    content?: true
    order?: true
  }

  export type TodoItemCountAggregateInputType = {
    id?: true
    todoId?: true
    type?: true
    content?: true
    order?: true
    _all?: true
  }

  export type TodoItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TodoItem to aggregate.
     */
    where?: TodoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoItems to fetch.
     */
    orderBy?: TodoItemOrderByWithRelationInput | TodoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TodoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` TodoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TodoItems
    **/
    _count?: true | TodoItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TodoItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TodoItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TodoItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TodoItemMaxAggregateInputType
  }

  export type GetTodoItemAggregateType<T extends TodoItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTodoItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTodoItem[P]>
      : GetScalarType<T[P], AggregateTodoItem[P]>
  }




  export type TodoItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TodoItemWhereInput
    orderBy?: TodoItemOrderByWithAggregationInput | TodoItemOrderByWithAggregationInput[]
    by: TodoItemScalarFieldEnum[] | TodoItemScalarFieldEnum
    having?: TodoItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TodoItemCountAggregateInputType | true
    _avg?: TodoItemAvgAggregateInputType
    _sum?: TodoItemSumAggregateInputType
    _min?: TodoItemMinAggregateInputType
    _max?: TodoItemMaxAggregateInputType
  }

  export type TodoItemGroupByOutputType = {
    id: string
    todoId: string
    type: $Enums.TodoItemTypeEnum
    content: string
    order: number
    _count: TodoItemCountAggregateOutputType | null
    _avg: TodoItemAvgAggregateOutputType | null
    _sum: TodoItemSumAggregateOutputType | null
    _min: TodoItemMinAggregateOutputType | null
    _max: TodoItemMaxAggregateOutputType | null
  }

  type GetTodoItemGroupByPayload<T extends TodoItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TodoItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TodoItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TodoItemGroupByOutputType[P]>
            : GetScalarType<T[P], TodoItemGroupByOutputType[P]>
        }
      >
    >


  export type TodoItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    todoId?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    todo?: boolean | TodoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todoItem"]>

  export type TodoItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    todoId?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    todo?: boolean | TodoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todoItem"]>

  export type TodoItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    todoId?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    todo?: boolean | TodoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todoItem"]>

  export type TodoItemSelectScalar = {
    id?: boolean
    todoId?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
  }

  export type TodoItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "todoId" | "type" | "content" | "order", ExtArgs["result"]["todoItem"]>
  export type TodoItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    todo?: boolean | TodoDefaultArgs<ExtArgs>
  }
  export type TodoItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    todo?: boolean | TodoDefaultArgs<ExtArgs>
  }
  export type TodoItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    todo?: boolean | TodoDefaultArgs<ExtArgs>
  }

  export type $TodoItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TodoItem"
    objects: {
      todo: Prisma.$TodoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      todoId: string
      type: $Enums.TodoItemTypeEnum
      content: string
      order: number
    }, ExtArgs["result"]["todoItem"]>
    composites: {}
  }

  type TodoItemGetPayload<S extends boolean | null | undefined | TodoItemDefaultArgs> = $Result.GetResult<Prisma.$TodoItemPayload, S>

  type TodoItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TodoItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TodoItemCountAggregateInputType | true
    }

  export interface TodoItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TodoItem'], meta: { name: 'TodoItem' } }
    /**
     * Find zero or one TodoItem that matches the filter.
     * @param {TodoItemFindUniqueArgs} args - Arguments to find a TodoItem
     * @example
     * // Get one TodoItem
     * const todoItem = await prisma.todoItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TodoItemFindUniqueArgs>(args: SelectSubset<T, TodoItemFindUniqueArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TodoItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TodoItemFindUniqueOrThrowArgs} args - Arguments to find a TodoItem
     * @example
     * // Get one TodoItem
     * const todoItem = await prisma.todoItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TodoItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TodoItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TodoItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoItemFindFirstArgs} args - Arguments to find a TodoItem
     * @example
     * // Get one TodoItem
     * const todoItem = await prisma.todoItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TodoItemFindFirstArgs>(args?: SelectSubset<T, TodoItemFindFirstArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TodoItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoItemFindFirstOrThrowArgs} args - Arguments to find a TodoItem
     * @example
     * // Get one TodoItem
     * const todoItem = await prisma.todoItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TodoItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TodoItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TodoItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TodoItems
     * const todoItems = await prisma.todoItem.findMany()
     * 
     * // Get first 10 TodoItems
     * const todoItems = await prisma.todoItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const todoItemWithIdOnly = await prisma.todoItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TodoItemFindManyArgs>(args?: SelectSubset<T, TodoItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TodoItem.
     * @param {TodoItemCreateArgs} args - Arguments to create a TodoItem.
     * @example
     * // Create one TodoItem
     * const TodoItem = await prisma.todoItem.create({
     *   data: {
     *     // ... data to create a TodoItem
     *   }
     * })
     * 
     */
    create<T extends TodoItemCreateArgs>(args: SelectSubset<T, TodoItemCreateArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TodoItems.
     * @param {TodoItemCreateManyArgs} args - Arguments to create many TodoItems.
     * @example
     * // Create many TodoItems
     * const todoItem = await prisma.todoItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TodoItemCreateManyArgs>(args?: SelectSubset<T, TodoItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TodoItems and returns the data saved in the database.
     * @param {TodoItemCreateManyAndReturnArgs} args - Arguments to create many TodoItems.
     * @example
     * // Create many TodoItems
     * const todoItem = await prisma.todoItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TodoItems and only return the `id`
     * const todoItemWithIdOnly = await prisma.todoItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TodoItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TodoItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TodoItem.
     * @param {TodoItemDeleteArgs} args - Arguments to delete one TodoItem.
     * @example
     * // Delete one TodoItem
     * const TodoItem = await prisma.todoItem.delete({
     *   where: {
     *     // ... filter to delete one TodoItem
     *   }
     * })
     * 
     */
    delete<T extends TodoItemDeleteArgs>(args: SelectSubset<T, TodoItemDeleteArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TodoItem.
     * @param {TodoItemUpdateArgs} args - Arguments to update one TodoItem.
     * @example
     * // Update one TodoItem
     * const todoItem = await prisma.todoItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TodoItemUpdateArgs>(args: SelectSubset<T, TodoItemUpdateArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TodoItems.
     * @param {TodoItemDeleteManyArgs} args - Arguments to filter TodoItems to delete.
     * @example
     * // Delete a few TodoItems
     * const { count } = await prisma.todoItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TodoItemDeleteManyArgs>(args?: SelectSubset<T, TodoItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TodoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TodoItems
     * const todoItem = await prisma.todoItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TodoItemUpdateManyArgs>(args: SelectSubset<T, TodoItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TodoItems and returns the data updated in the database.
     * @param {TodoItemUpdateManyAndReturnArgs} args - Arguments to update many TodoItems.
     * @example
     * // Update many TodoItems
     * const todoItem = await prisma.todoItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TodoItems and only return the `id`
     * const todoItemWithIdOnly = await prisma.todoItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TodoItemUpdateManyAndReturnArgs>(args: SelectSubset<T, TodoItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TodoItem.
     * @param {TodoItemUpsertArgs} args - Arguments to update or create a TodoItem.
     * @example
     * // Update or create a TodoItem
     * const todoItem = await prisma.todoItem.upsert({
     *   create: {
     *     // ... data to create a TodoItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TodoItem we want to update
     *   }
     * })
     */
    upsert<T extends TodoItemUpsertArgs>(args: SelectSubset<T, TodoItemUpsertArgs<ExtArgs>>): Prisma__TodoItemClient<$Result.GetResult<Prisma.$TodoItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TodoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoItemCountArgs} args - Arguments to filter TodoItems to count.
     * @example
     * // Count the number of TodoItems
     * const count = await prisma.todoItem.count({
     *   where: {
     *     // ... the filter for the TodoItems we want to count
     *   }
     * })
    **/
    count<T extends TodoItemCountArgs>(
      args?: Subset<T, TodoItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TodoItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TodoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TodoItemAggregateArgs>(args: Subset<T, TodoItemAggregateArgs>): Prisma.PrismaPromise<GetTodoItemAggregateType<T>>

    /**
     * Group by TodoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TodoItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TodoItemGroupByArgs['orderBy'] }
        : { orderBy?: TodoItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TodoItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodoItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TodoItem model
   */
  readonly fields: TodoItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TodoItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TodoItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    todo<T extends TodoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TodoDefaultArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TodoItem model
   */
  interface TodoItemFieldRefs {
    readonly id: FieldRef<"TodoItem", 'String'>
    readonly todoId: FieldRef<"TodoItem", 'String'>
    readonly type: FieldRef<"TodoItem", 'TodoItemTypeEnum'>
    readonly content: FieldRef<"TodoItem", 'String'>
    readonly order: FieldRef<"TodoItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TodoItem findUnique
   */
  export type TodoItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * Filter, which TodoItem to fetch.
     */
    where: TodoItemWhereUniqueInput
  }

  /**
   * TodoItem findUniqueOrThrow
   */
  export type TodoItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * Filter, which TodoItem to fetch.
     */
    where: TodoItemWhereUniqueInput
  }

  /**
   * TodoItem findFirst
   */
  export type TodoItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * Filter, which TodoItem to fetch.
     */
    where?: TodoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoItems to fetch.
     */
    orderBy?: TodoItemOrderByWithRelationInput | TodoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoItems.
     */
    cursor?: TodoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` TodoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoItems.
     */
    distinct?: TodoItemScalarFieldEnum | TodoItemScalarFieldEnum[]
  }

  /**
   * TodoItem findFirstOrThrow
   */
  export type TodoItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * Filter, which TodoItem to fetch.
     */
    where?: TodoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoItems to fetch.
     */
    orderBy?: TodoItemOrderByWithRelationInput | TodoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoItems.
     */
    cursor?: TodoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` TodoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoItems.
     */
    distinct?: TodoItemScalarFieldEnum | TodoItemScalarFieldEnum[]
  }

  /**
   * TodoItem findMany
   */
  export type TodoItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * Filter, which TodoItems to fetch.
     */
    where?: TodoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoItems to fetch.
     */
    orderBy?: TodoItemOrderByWithRelationInput | TodoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TodoItems.
     */
    cursor?: TodoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` TodoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoItems.
     */
    skip?: number
    distinct?: TodoItemScalarFieldEnum | TodoItemScalarFieldEnum[]
  }

  /**
   * TodoItem create
   */
  export type TodoItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TodoItem.
     */
    data: XOR<TodoItemCreateInput, TodoItemUncheckedCreateInput>
  }

  /**
   * TodoItem createMany
   */
  export type TodoItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TodoItems.
     */
    data: TodoItemCreateManyInput | TodoItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TodoItem createManyAndReturn
   */
  export type TodoItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * The data used to create many TodoItems.
     */
    data: TodoItemCreateManyInput | TodoItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TodoItem update
   */
  export type TodoItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TodoItem.
     */
    data: XOR<TodoItemUpdateInput, TodoItemUncheckedUpdateInput>
    /**
     * Choose, which TodoItem to update.
     */
    where: TodoItemWhereUniqueInput
  }

  /**
   * TodoItem updateMany
   */
  export type TodoItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TodoItems.
     */
    data: XOR<TodoItemUpdateManyMutationInput, TodoItemUncheckedUpdateManyInput>
    /**
     * Filter which TodoItems to update
     */
    where?: TodoItemWhereInput
    /**
     * Limit how many TodoItems to update.
     */
    limit?: number
  }

  /**
   * TodoItem updateManyAndReturn
   */
  export type TodoItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * The data used to update TodoItems.
     */
    data: XOR<TodoItemUpdateManyMutationInput, TodoItemUncheckedUpdateManyInput>
    /**
     * Filter which TodoItems to update
     */
    where?: TodoItemWhereInput
    /**
     * Limit how many TodoItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TodoItem upsert
   */
  export type TodoItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TodoItem to update in case it exists.
     */
    where: TodoItemWhereUniqueInput
    /**
     * In case the TodoItem found by the `where` argument doesn't exist, create a new TodoItem with this data.
     */
    create: XOR<TodoItemCreateInput, TodoItemUncheckedCreateInput>
    /**
     * In case the TodoItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TodoItemUpdateInput, TodoItemUncheckedUpdateInput>
  }

  /**
   * TodoItem delete
   */
  export type TodoItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
    /**
     * Filter which TodoItem to delete.
     */
    where: TodoItemWhereUniqueInput
  }

  /**
   * TodoItem deleteMany
   */
  export type TodoItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TodoItems to delete
     */
    where?: TodoItemWhereInput
    /**
     * Limit how many TodoItems to delete.
     */
    limit?: number
  }

  /**
   * TodoItem without action
   */
  export type TodoItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoItem
     */
    select?: TodoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoItem
     */
    omit?: TodoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoItemInclude<ExtArgs> | null
  }


  /**
   * Model TodoUserProcess
   */

  export type AggregateTodoUserProcess = {
    _count: TodoUserProcessCountAggregateOutputType | null
    _min: TodoUserProcessMinAggregateOutputType | null
    _max: TodoUserProcessMaxAggregateOutputType | null
  }

  export type TodoUserProcessMinAggregateOutputType = {
    id: string | null
    todoId: string | null
    userProcessId: string | null
  }

  export type TodoUserProcessMaxAggregateOutputType = {
    id: string | null
    todoId: string | null
    userProcessId: string | null
  }

  export type TodoUserProcessCountAggregateOutputType = {
    id: number
    todoId: number
    userProcessId: number
    _all: number
  }


  export type TodoUserProcessMinAggregateInputType = {
    id?: true
    todoId?: true
    userProcessId?: true
  }

  export type TodoUserProcessMaxAggregateInputType = {
    id?: true
    todoId?: true
    userProcessId?: true
  }

  export type TodoUserProcessCountAggregateInputType = {
    id?: true
    todoId?: true
    userProcessId?: true
    _all?: true
  }

  export type TodoUserProcessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TodoUserProcess to aggregate.
     */
    where?: TodoUserProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoUserProcesses to fetch.
     */
    orderBy?: TodoUserProcessOrderByWithRelationInput | TodoUserProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TodoUserProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` TodoUserProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoUserProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TodoUserProcesses
    **/
    _count?: true | TodoUserProcessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TodoUserProcessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TodoUserProcessMaxAggregateInputType
  }

  export type GetTodoUserProcessAggregateType<T extends TodoUserProcessAggregateArgs> = {
        [P in keyof T & keyof AggregateTodoUserProcess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTodoUserProcess[P]>
      : GetScalarType<T[P], AggregateTodoUserProcess[P]>
  }




  export type TodoUserProcessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TodoUserProcessWhereInput
    orderBy?: TodoUserProcessOrderByWithAggregationInput | TodoUserProcessOrderByWithAggregationInput[]
    by: TodoUserProcessScalarFieldEnum[] | TodoUserProcessScalarFieldEnum
    having?: TodoUserProcessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TodoUserProcessCountAggregateInputType | true
    _min?: TodoUserProcessMinAggregateInputType
    _max?: TodoUserProcessMaxAggregateInputType
  }

  export type TodoUserProcessGroupByOutputType = {
    id: string
    todoId: string
    userProcessId: string
    _count: TodoUserProcessCountAggregateOutputType | null
    _min: TodoUserProcessMinAggregateOutputType | null
    _max: TodoUserProcessMaxAggregateOutputType | null
  }

  type GetTodoUserProcessGroupByPayload<T extends TodoUserProcessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TodoUserProcessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TodoUserProcessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TodoUserProcessGroupByOutputType[P]>
            : GetScalarType<T[P], TodoUserProcessGroupByOutputType[P]>
        }
      >
    >


  export type TodoUserProcessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    todoId?: boolean
    userProcessId?: boolean
    todo?: boolean | TodoDefaultArgs<ExtArgs>
    userProcess?: boolean | UserProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todoUserProcess"]>

  export type TodoUserProcessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    todoId?: boolean
    userProcessId?: boolean
    todo?: boolean | TodoDefaultArgs<ExtArgs>
    userProcess?: boolean | UserProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todoUserProcess"]>

  export type TodoUserProcessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    todoId?: boolean
    userProcessId?: boolean
    todo?: boolean | TodoDefaultArgs<ExtArgs>
    userProcess?: boolean | UserProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todoUserProcess"]>

  export type TodoUserProcessSelectScalar = {
    id?: boolean
    todoId?: boolean
    userProcessId?: boolean
  }

  export type TodoUserProcessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "todoId" | "userProcessId", ExtArgs["result"]["todoUserProcess"]>
  export type TodoUserProcessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    todo?: boolean | TodoDefaultArgs<ExtArgs>
    userProcess?: boolean | UserProcessDefaultArgs<ExtArgs>
  }
  export type TodoUserProcessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    todo?: boolean | TodoDefaultArgs<ExtArgs>
    userProcess?: boolean | UserProcessDefaultArgs<ExtArgs>
  }
  export type TodoUserProcessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    todo?: boolean | TodoDefaultArgs<ExtArgs>
    userProcess?: boolean | UserProcessDefaultArgs<ExtArgs>
  }

  export type $TodoUserProcessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TodoUserProcess"
    objects: {
      todo: Prisma.$TodoPayload<ExtArgs>
      userProcess: Prisma.$UserProcessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      todoId: string
      userProcessId: string
    }, ExtArgs["result"]["todoUserProcess"]>
    composites: {}
  }

  type TodoUserProcessGetPayload<S extends boolean | null | undefined | TodoUserProcessDefaultArgs> = $Result.GetResult<Prisma.$TodoUserProcessPayload, S>

  type TodoUserProcessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TodoUserProcessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TodoUserProcessCountAggregateInputType | true
    }

  export interface TodoUserProcessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TodoUserProcess'], meta: { name: 'TodoUserProcess' } }
    /**
     * Find zero or one TodoUserProcess that matches the filter.
     * @param {TodoUserProcessFindUniqueArgs} args - Arguments to find a TodoUserProcess
     * @example
     * // Get one TodoUserProcess
     * const todoUserProcess = await prisma.todoUserProcess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TodoUserProcessFindUniqueArgs>(args: SelectSubset<T, TodoUserProcessFindUniqueArgs<ExtArgs>>): Prisma__TodoUserProcessClient<$Result.GetResult<Prisma.$TodoUserProcessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TodoUserProcess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TodoUserProcessFindUniqueOrThrowArgs} args - Arguments to find a TodoUserProcess
     * @example
     * // Get one TodoUserProcess
     * const todoUserProcess = await prisma.todoUserProcess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TodoUserProcessFindUniqueOrThrowArgs>(args: SelectSubset<T, TodoUserProcessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TodoUserProcessClient<$Result.GetResult<Prisma.$TodoUserProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TodoUserProcess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoUserProcessFindFirstArgs} args - Arguments to find a TodoUserProcess
     * @example
     * // Get one TodoUserProcess
     * const todoUserProcess = await prisma.todoUserProcess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TodoUserProcessFindFirstArgs>(args?: SelectSubset<T, TodoUserProcessFindFirstArgs<ExtArgs>>): Prisma__TodoUserProcessClient<$Result.GetResult<Prisma.$TodoUserProcessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TodoUserProcess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoUserProcessFindFirstOrThrowArgs} args - Arguments to find a TodoUserProcess
     * @example
     * // Get one TodoUserProcess
     * const todoUserProcess = await prisma.todoUserProcess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TodoUserProcessFindFirstOrThrowArgs>(args?: SelectSubset<T, TodoUserProcessFindFirstOrThrowArgs<ExtArgs>>): Prisma__TodoUserProcessClient<$Result.GetResult<Prisma.$TodoUserProcessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TodoUserProcesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoUserProcessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TodoUserProcesses
     * const todoUserProcesses = await prisma.todoUserProcess.findMany()
     * 
     * // Get first 10 TodoUserProcesses
     * const todoUserProcesses = await prisma.todoUserProcess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const todoUserProcessWithIdOnly = await prisma.todoUserProcess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TodoUserProcessFindManyArgs>(args?: SelectSubset<T, TodoUserProcessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoUserProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TodoUserProcess.
     * @param {TodoUserProcessCreateArgs} args - Arguments to create a TodoUserProcess.
     * @example
     * // Create one TodoUserProcess
     * const TodoUserProcess = await prisma.todoUserProcess.create({
     *   data: {
     *     // ... data to create a TodoUserProcess
     *   }
     * })
     * 
     */
    create<T extends TodoUserProcessCreateArgs>(args: SelectSubset<T, TodoUserProcessCreateArgs<ExtArgs>>): Prisma__TodoUserProcessClient<$Result.GetResult<Prisma.$TodoUserProcessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TodoUserProcesses.
     * @param {TodoUserProcessCreateManyArgs} args - Arguments to create many TodoUserProcesses.
     * @example
     * // Create many TodoUserProcesses
     * const todoUserProcess = await prisma.todoUserProcess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TodoUserProcessCreateManyArgs>(args?: SelectSubset<T, TodoUserProcessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TodoUserProcesses and returns the data saved in the database.
     * @param {TodoUserProcessCreateManyAndReturnArgs} args - Arguments to create many TodoUserProcesses.
     * @example
     * // Create many TodoUserProcesses
     * const todoUserProcess = await prisma.todoUserProcess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TodoUserProcesses and only return the `id`
     * const todoUserProcessWithIdOnly = await prisma.todoUserProcess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TodoUserProcessCreateManyAndReturnArgs>(args?: SelectSubset<T, TodoUserProcessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoUserProcessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TodoUserProcess.
     * @param {TodoUserProcessDeleteArgs} args - Arguments to delete one TodoUserProcess.
     * @example
     * // Delete one TodoUserProcess
     * const TodoUserProcess = await prisma.todoUserProcess.delete({
     *   where: {
     *     // ... filter to delete one TodoUserProcess
     *   }
     * })
     * 
     */
    delete<T extends TodoUserProcessDeleteArgs>(args: SelectSubset<T, TodoUserProcessDeleteArgs<ExtArgs>>): Prisma__TodoUserProcessClient<$Result.GetResult<Prisma.$TodoUserProcessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TodoUserProcess.
     * @param {TodoUserProcessUpdateArgs} args - Arguments to update one TodoUserProcess.
     * @example
     * // Update one TodoUserProcess
     * const todoUserProcess = await prisma.todoUserProcess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TodoUserProcessUpdateArgs>(args: SelectSubset<T, TodoUserProcessUpdateArgs<ExtArgs>>): Prisma__TodoUserProcessClient<$Result.GetResult<Prisma.$TodoUserProcessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TodoUserProcesses.
     * @param {TodoUserProcessDeleteManyArgs} args - Arguments to filter TodoUserProcesses to delete.
     * @example
     * // Delete a few TodoUserProcesses
     * const { count } = await prisma.todoUserProcess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TodoUserProcessDeleteManyArgs>(args?: SelectSubset<T, TodoUserProcessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TodoUserProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoUserProcessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TodoUserProcesses
     * const todoUserProcess = await prisma.todoUserProcess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TodoUserProcessUpdateManyArgs>(args: SelectSubset<T, TodoUserProcessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TodoUserProcesses and returns the data updated in the database.
     * @param {TodoUserProcessUpdateManyAndReturnArgs} args - Arguments to update many TodoUserProcesses.
     * @example
     * // Update many TodoUserProcesses
     * const todoUserProcess = await prisma.todoUserProcess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TodoUserProcesses and only return the `id`
     * const todoUserProcessWithIdOnly = await prisma.todoUserProcess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TodoUserProcessUpdateManyAndReturnArgs>(args: SelectSubset<T, TodoUserProcessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoUserProcessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TodoUserProcess.
     * @param {TodoUserProcessUpsertArgs} args - Arguments to update or create a TodoUserProcess.
     * @example
     * // Update or create a TodoUserProcess
     * const todoUserProcess = await prisma.todoUserProcess.upsert({
     *   create: {
     *     // ... data to create a TodoUserProcess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TodoUserProcess we want to update
     *   }
     * })
     */
    upsert<T extends TodoUserProcessUpsertArgs>(args: SelectSubset<T, TodoUserProcessUpsertArgs<ExtArgs>>): Prisma__TodoUserProcessClient<$Result.GetResult<Prisma.$TodoUserProcessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TodoUserProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoUserProcessCountArgs} args - Arguments to filter TodoUserProcesses to count.
     * @example
     * // Count the number of TodoUserProcesses
     * const count = await prisma.todoUserProcess.count({
     *   where: {
     *     // ... the filter for the TodoUserProcesses we want to count
     *   }
     * })
    **/
    count<T extends TodoUserProcessCountArgs>(
      args?: Subset<T, TodoUserProcessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TodoUserProcessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TodoUserProcess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoUserProcessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TodoUserProcessAggregateArgs>(args: Subset<T, TodoUserProcessAggregateArgs>): Prisma.PrismaPromise<GetTodoUserProcessAggregateType<T>>

    /**
     * Group by TodoUserProcess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoUserProcessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TodoUserProcessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TodoUserProcessGroupByArgs['orderBy'] }
        : { orderBy?: TodoUserProcessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TodoUserProcessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodoUserProcessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TodoUserProcess model
   */
  readonly fields: TodoUserProcessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TodoUserProcess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TodoUserProcessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    todo<T extends TodoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TodoDefaultArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userProcess<T extends UserProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProcessDefaultArgs<ExtArgs>>): Prisma__UserProcessClient<$Result.GetResult<Prisma.$UserProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TodoUserProcess model
   */
  interface TodoUserProcessFieldRefs {
    readonly id: FieldRef<"TodoUserProcess", 'String'>
    readonly todoId: FieldRef<"TodoUserProcess", 'String'>
    readonly userProcessId: FieldRef<"TodoUserProcess", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TodoUserProcess findUnique
   */
  export type TodoUserProcessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoUserProcess
     */
    select?: TodoUserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoUserProcess
     */
    omit?: TodoUserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoUserProcessInclude<ExtArgs> | null
    /**
     * Filter, which TodoUserProcess to fetch.
     */
    where: TodoUserProcessWhereUniqueInput
  }

  /**
   * TodoUserProcess findUniqueOrThrow
   */
  export type TodoUserProcessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoUserProcess
     */
    select?: TodoUserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoUserProcess
     */
    omit?: TodoUserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoUserProcessInclude<ExtArgs> | null
    /**
     * Filter, which TodoUserProcess to fetch.
     */
    where: TodoUserProcessWhereUniqueInput
  }

  /**
   * TodoUserProcess findFirst
   */
  export type TodoUserProcessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoUserProcess
     */
    select?: TodoUserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoUserProcess
     */
    omit?: TodoUserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoUserProcessInclude<ExtArgs> | null
    /**
     * Filter, which TodoUserProcess to fetch.
     */
    where?: TodoUserProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoUserProcesses to fetch.
     */
    orderBy?: TodoUserProcessOrderByWithRelationInput | TodoUserProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoUserProcesses.
     */
    cursor?: TodoUserProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` TodoUserProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoUserProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoUserProcesses.
     */
    distinct?: TodoUserProcessScalarFieldEnum | TodoUserProcessScalarFieldEnum[]
  }

  /**
   * TodoUserProcess findFirstOrThrow
   */
  export type TodoUserProcessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoUserProcess
     */
    select?: TodoUserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoUserProcess
     */
    omit?: TodoUserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoUserProcessInclude<ExtArgs> | null
    /**
     * Filter, which TodoUserProcess to fetch.
     */
    where?: TodoUserProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoUserProcesses to fetch.
     */
    orderBy?: TodoUserProcessOrderByWithRelationInput | TodoUserProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoUserProcesses.
     */
    cursor?: TodoUserProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` TodoUserProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoUserProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoUserProcesses.
     */
    distinct?: TodoUserProcessScalarFieldEnum | TodoUserProcessScalarFieldEnum[]
  }

  /**
   * TodoUserProcess findMany
   */
  export type TodoUserProcessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoUserProcess
     */
    select?: TodoUserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoUserProcess
     */
    omit?: TodoUserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoUserProcessInclude<ExtArgs> | null
    /**
     * Filter, which TodoUserProcesses to fetch.
     */
    where?: TodoUserProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoUserProcesses to fetch.
     */
    orderBy?: TodoUserProcessOrderByWithRelationInput | TodoUserProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TodoUserProcesses.
     */
    cursor?: TodoUserProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` TodoUserProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoUserProcesses.
     */
    skip?: number
    distinct?: TodoUserProcessScalarFieldEnum | TodoUserProcessScalarFieldEnum[]
  }

  /**
   * TodoUserProcess create
   */
  export type TodoUserProcessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoUserProcess
     */
    select?: TodoUserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoUserProcess
     */
    omit?: TodoUserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoUserProcessInclude<ExtArgs> | null
    /**
     * The data needed to create a TodoUserProcess.
     */
    data: XOR<TodoUserProcessCreateInput, TodoUserProcessUncheckedCreateInput>
  }

  /**
   * TodoUserProcess createMany
   */
  export type TodoUserProcessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TodoUserProcesses.
     */
    data: TodoUserProcessCreateManyInput | TodoUserProcessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TodoUserProcess createManyAndReturn
   */
  export type TodoUserProcessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoUserProcess
     */
    select?: TodoUserProcessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TodoUserProcess
     */
    omit?: TodoUserProcessOmit<ExtArgs> | null
    /**
     * The data used to create many TodoUserProcesses.
     */
    data: TodoUserProcessCreateManyInput | TodoUserProcessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoUserProcessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TodoUserProcess update
   */
  export type TodoUserProcessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoUserProcess
     */
    select?: TodoUserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoUserProcess
     */
    omit?: TodoUserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoUserProcessInclude<ExtArgs> | null
    /**
     * The data needed to update a TodoUserProcess.
     */
    data: XOR<TodoUserProcessUpdateInput, TodoUserProcessUncheckedUpdateInput>
    /**
     * Choose, which TodoUserProcess to update.
     */
    where: TodoUserProcessWhereUniqueInput
  }

  /**
   * TodoUserProcess updateMany
   */
  export type TodoUserProcessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TodoUserProcesses.
     */
    data: XOR<TodoUserProcessUpdateManyMutationInput, TodoUserProcessUncheckedUpdateManyInput>
    /**
     * Filter which TodoUserProcesses to update
     */
    where?: TodoUserProcessWhereInput
    /**
     * Limit how many TodoUserProcesses to update.
     */
    limit?: number
  }

  /**
   * TodoUserProcess updateManyAndReturn
   */
  export type TodoUserProcessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoUserProcess
     */
    select?: TodoUserProcessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TodoUserProcess
     */
    omit?: TodoUserProcessOmit<ExtArgs> | null
    /**
     * The data used to update TodoUserProcesses.
     */
    data: XOR<TodoUserProcessUpdateManyMutationInput, TodoUserProcessUncheckedUpdateManyInput>
    /**
     * Filter which TodoUserProcesses to update
     */
    where?: TodoUserProcessWhereInput
    /**
     * Limit how many TodoUserProcesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoUserProcessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TodoUserProcess upsert
   */
  export type TodoUserProcessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoUserProcess
     */
    select?: TodoUserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoUserProcess
     */
    omit?: TodoUserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoUserProcessInclude<ExtArgs> | null
    /**
     * The filter to search for the TodoUserProcess to update in case it exists.
     */
    where: TodoUserProcessWhereUniqueInput
    /**
     * In case the TodoUserProcess found by the `where` argument doesn't exist, create a new TodoUserProcess with this data.
     */
    create: XOR<TodoUserProcessCreateInput, TodoUserProcessUncheckedCreateInput>
    /**
     * In case the TodoUserProcess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TodoUserProcessUpdateInput, TodoUserProcessUncheckedUpdateInput>
  }

  /**
   * TodoUserProcess delete
   */
  export type TodoUserProcessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoUserProcess
     */
    select?: TodoUserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoUserProcess
     */
    omit?: TodoUserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoUserProcessInclude<ExtArgs> | null
    /**
     * Filter which TodoUserProcess to delete.
     */
    where: TodoUserProcessWhereUniqueInput
  }

  /**
   * TodoUserProcess deleteMany
   */
  export type TodoUserProcessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TodoUserProcesses to delete
     */
    where?: TodoUserProcessWhereInput
    /**
     * Limit how many TodoUserProcesses to delete.
     */
    limit?: number
  }

  /**
   * TodoUserProcess without action
   */
  export type TodoUserProcessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TodoUserProcess
     */
    select?: TodoUserProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TodoUserProcess
     */
    omit?: TodoUserProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoUserProcessInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    companyId: 'companyId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProviderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    providerAccountId: 'providerAccountId'
  };

  export type ProviderScalarFieldEnum = (typeof ProviderScalarFieldEnum)[keyof typeof ProviderScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logo: 'logo'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const JobPostingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    companyName: 'companyName',
    companyLogo: 'companyLogo',
    jobPostingUrl: 'jobPostingUrl',
    jobDescription: 'jobDescription',
    markdownText: 'markdownText',
    status: 'status',
    endsAt: 'endsAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type JobPostingScalarFieldEnum = (typeof JobPostingScalarFieldEnum)[keyof typeof JobPostingScalarFieldEnum]


  export const JobPostingLanguageScalarFieldEnum: {
    id: 'id',
    jobPostingId: 'jobPostingId',
    language: 'language',
    level: 'level'
  };

  export type JobPostingLanguageScalarFieldEnum = (typeof JobPostingLanguageScalarFieldEnum)[keyof typeof JobPostingLanguageScalarFieldEnum]


  export const JobPostingRequirementScalarFieldEnum: {
    id: 'id',
    jobPostingId: 'jobPostingId',
    requirement: 'requirement'
  };

  export type JobPostingRequirementScalarFieldEnum = (typeof JobPostingRequirementScalarFieldEnum)[keyof typeof JobPostingRequirementScalarFieldEnum]


  export const JobPostingMeritScalarFieldEnum: {
    id: 'id',
    jobPostingId: 'jobPostingId',
    merit: 'merit'
  };

  export type JobPostingMeritScalarFieldEnum = (typeof JobPostingMeritScalarFieldEnum)[keyof typeof JobPostingMeritScalarFieldEnum]


  export const JobPostingApplicantQualityScalarFieldEnum: {
    id: 'id',
    jobPostingId: 'jobPostingId',
    quality: 'quality'
  };

  export type JobPostingApplicantQualityScalarFieldEnum = (typeof JobPostingApplicantQualityScalarFieldEnum)[keyof typeof JobPostingApplicantQualityScalarFieldEnum]


  export const JobPostingLocationScalarFieldEnum: {
    id: 'id',
    jobPostingId: 'jobPostingId',
    city: 'city',
    region: 'region',
    country: 'country',
    isRemote: 'isRemote',
    lat: 'lat',
    lng: 'lng'
  };

  export type JobPostingLocationScalarFieldEnum = (typeof JobPostingLocationScalarFieldEnum)[keyof typeof JobPostingLocationScalarFieldEnum]


  export const JobPostingWorkArrengmentScalarFieldEnum: {
    id: 'id',
    jobPostingId: 'jobPostingId',
    mode: 'mode'
  };

  export type JobPostingWorkArrengmentScalarFieldEnum = (typeof JobPostingWorkArrengmentScalarFieldEnum)[keyof typeof JobPostingWorkArrengmentScalarFieldEnum]


  export const JobPostingEmploymentTypeScalarFieldEnum: {
    id: 'id',
    jobPostingId: 'jobPostingId',
    type: 'type'
  };

  export type JobPostingEmploymentTypeScalarFieldEnum = (typeof JobPostingEmploymentTypeScalarFieldEnum)[keyof typeof JobPostingEmploymentTypeScalarFieldEnum]


  export const JobPostingSalaryScalarFieldEnum: {
    id: 'id',
    jobPostingId: 'jobPostingId',
    type: 'type',
    amount: 'amount',
    currency: 'currency',
    period: 'period',
    benefits: 'benefits',
    notes: 'notes'
  };

  export type JobPostingSalaryScalarFieldEnum = (typeof JobPostingSalaryScalarFieldEnum)[keyof typeof JobPostingSalaryScalarFieldEnum]


  export const CreatedJobPostingScalarFieldEnum: {
    id: 'id',
    jobPostingId: 'jobPostingId',
    createdByType: 'createdByType',
    createdById: 'createdById',
    source: 'source',
    importedAt: 'importedAt'
  };

  export type CreatedJobPostingScalarFieldEnum = (typeof CreatedJobPostingScalarFieldEnum)[keyof typeof CreatedJobPostingScalarFieldEnum]


  export const JobApplicantsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    jobPostingId: 'jobPostingId',
    status: 'status',
    appliedAt: 'appliedAt',
    gotJob: 'gotJob'
  };

  export type JobApplicantsScalarFieldEnum = (typeof JobApplicantsScalarFieldEnum)[keyof typeof JobApplicantsScalarFieldEnum]


  export const UserProcessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    startedAt: 'startedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt',
    jobPostingId: 'jobPostingId',
    processId: 'processId'
  };

  export type UserProcessScalarFieldEnum = (typeof UserProcessScalarFieldEnum)[keyof typeof UserProcessScalarFieldEnum]


  export const UserProcessStepScalarFieldEnum: {
    id: 'id',
    userProcessId: 'userProcessId',
    stepId: 'stepId',
    isExecuted: 'isExecuted',
    executedAt: 'executedAt'
  };

  export type UserProcessStepScalarFieldEnum = (typeof UserProcessStepScalarFieldEnum)[keyof typeof UserProcessStepScalarFieldEnum]


  export const UserPipelineStepCommentScalarFieldEnum: {
    id: 'id',
    userPipelineStepId: 'userPipelineStepId',
    userId: 'userId',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type UserPipelineStepCommentScalarFieldEnum = (typeof UserPipelineStepCommentScalarFieldEnum)[keyof typeof UserPipelineStepCommentScalarFieldEnum]


  export const ProcessScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    ownerId: 'ownerId',
    isTemplate: 'isTemplate',
    isPublic: 'isPublic'
  };

  export type ProcessScalarFieldEnum = (typeof ProcessScalarFieldEnum)[keyof typeof ProcessScalarFieldEnum]


  export const ProcessStepScalarFieldEnum: {
    id: 'id',
    processId: 'processId',
    title: 'title',
    description: 'description',
    icon: 'icon',
    order: 'order',
    userId: 'userId'
  };

  export type ProcessStepScalarFieldEnum = (typeof ProcessStepScalarFieldEnum)[keyof typeof ProcessStepScalarFieldEnum]


  export const ActionDefinitionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isPublic: 'isPublic',
    order: 'order',
    config: 'config',
    stepId: 'stepId'
  };

  export type ActionDefinitionScalarFieldEnum = (typeof ActionDefinitionScalarFieldEnum)[keyof typeof ActionDefinitionScalarFieldEnum]


  export const TriggerDefinitionScalarFieldEnum: {
    id: 'id',
    order: 'order',
    isPublic: 'isPublic',
    createdBy: 'createdBy',
    triggerCode: 'triggerCode',
    executeWhen: 'executeWhen',
    executeAt: 'executeAt',
    combinator: 'combinator',
    config: 'config',
    expiration: 'expiration',
    stepId: 'stepId'
  };

  export type TriggerDefinitionScalarFieldEnum = (typeof TriggerDefinitionScalarFieldEnum)[keyof typeof TriggerDefinitionScalarFieldEnum]


  export const ConditionalScalarFieldEnum: {
    id: 'id',
    triggerId: 'triggerId',
    fieldKey: 'fieldKey',
    fieldKeyLabel: 'fieldKeyLabel',
    operator: 'operator',
    comparisonValue: 'comparisonValue',
    combinator: 'combinator'
  };

  export type ConditionalScalarFieldEnum = (typeof ConditionalScalarFieldEnum)[keyof typeof ConditionalScalarFieldEnum]


  export const TodoScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    dueDate: 'dueDate',
    completed: 'completed',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TodoScalarFieldEnum = (typeof TodoScalarFieldEnum)[keyof typeof TodoScalarFieldEnum]


  export const TodoItemScalarFieldEnum: {
    id: 'id',
    todoId: 'todoId',
    type: 'type',
    content: 'content',
    order: 'order'
  };

  export type TodoItemScalarFieldEnum = (typeof TodoItemScalarFieldEnum)[keyof typeof TodoItemScalarFieldEnum]


  export const TodoUserProcessScalarFieldEnum: {
    id: 'id',
    todoId: 'todoId',
    userProcessId: 'userProcessId'
  };

  export type TodoUserProcessScalarFieldEnum = (typeof TodoUserProcessScalarFieldEnum)[keyof typeof TodoUserProcessScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'ProviderEnum'
   */
  export type EnumProviderEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProviderEnum'>
    


  /**
   * Reference to a field of type 'ProviderEnum[]'
   */
  export type ListEnumProviderEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProviderEnum[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CreatedByEnum'
   */
  export type EnumCreatedByEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreatedByEnum'>
    


  /**
   * Reference to a field of type 'CreatedByEnum[]'
   */
  export type ListEnumCreatedByEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreatedByEnum[]'>
    


  /**
   * Reference to a field of type 'JobSourceEnum'
   */
  export type EnumJobSourceEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobSourceEnum'>
    


  /**
   * Reference to a field of type 'JobSourceEnum[]'
   */
  export type ListEnumJobSourceEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobSourceEnum[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'StatusUserJobProcesses'
   */
  export type EnumStatusUserJobProcessesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusUserJobProcesses'>
    


  /**
   * Reference to a field of type 'StatusUserJobProcesses[]'
   */
  export type ListEnumStatusUserJobProcessesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusUserJobProcesses[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'TriggerEventCode'
   */
  export type EnumTriggerEventCodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerEventCode'>
    


  /**
   * Reference to a field of type 'TriggerEventCode[]'
   */
  export type ListEnumTriggerEventCodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerEventCode[]'>
    


  /**
   * Reference to a field of type 'CombinatorEnum'
   */
  export type EnumCombinatorEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CombinatorEnum'>
    


  /**
   * Reference to a field of type 'CombinatorEnum[]'
   */
  export type ListEnumCombinatorEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CombinatorEnum[]'>
    


  /**
   * Reference to a field of type 'ComparisonOperatorEnum'
   */
  export type EnumComparisonOperatorEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComparisonOperatorEnum'>
    


  /**
   * Reference to a field of type 'ComparisonOperatorEnum[]'
   */
  export type ListEnumComparisonOperatorEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComparisonOperatorEnum[]'>
    


  /**
   * Reference to a field of type 'TodoItemTypeEnum'
   */
  export type EnumTodoItemTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TodoItemTypeEnum'>
    


  /**
   * Reference to a field of type 'TodoItemTypeEnum[]'
   */
  export type ListEnumTodoItemTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TodoItemTypeEnum[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    companyId?: StringNullableFilter<"User"> | string | null
    providers?: ProviderListRelationFilter
    applications?: JobApplicantsListRelationFilter
    userProcess?: UserProcessListRelationFilter
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    createdJobPostings?: CreatedJobPostingListRelationFilter
    userPipelineStepComments?: UserPipelineStepCommentListRelationFilter
    processSteps?: ProcessStepListRelationFilter
    processes?: ProcessListRelationFilter
    todos?: TodoListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    providers?: ProviderOrderByRelationAggregateInput
    applications?: JobApplicantsOrderByRelationAggregateInput
    userProcess?: UserProcessOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    createdJobPostings?: CreatedJobPostingOrderByRelationAggregateInput
    userPipelineStepComments?: UserPipelineStepCommentOrderByRelationAggregateInput
    processSteps?: ProcessStepOrderByRelationAggregateInput
    processes?: ProcessOrderByRelationAggregateInput
    todos?: TodoOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    companyId?: StringNullableFilter<"User"> | string | null
    providers?: ProviderListRelationFilter
    applications?: JobApplicantsListRelationFilter
    userProcess?: UserProcessListRelationFilter
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    createdJobPostings?: CreatedJobPostingListRelationFilter
    userPipelineStepComments?: UserPipelineStepCommentListRelationFilter
    processSteps?: ProcessStepListRelationFilter
    processes?: ProcessListRelationFilter
    todos?: TodoListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    companyId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ProviderWhereInput = {
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    id?: StringFilter<"Provider"> | string
    userId?: StringFilter<"Provider"> | string
    provider?: EnumProviderEnumFilter<"Provider"> | $Enums.ProviderEnum
    providerAccountId?: StringFilter<"Provider"> | string
    token?: XOR<TokenNullableScalarRelationFilter, TokenWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProviderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    token?: TokenOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: ProviderProviderProviderAccountIdCompoundUniqueInput
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    userId?: StringFilter<"Provider"> | string
    provider?: EnumProviderEnumFilter<"Provider"> | $Enums.ProviderEnum
    providerAccountId?: StringFilter<"Provider"> | string
    token?: XOR<TokenNullableScalarRelationFilter, TokenWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type ProviderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    _count?: ProviderCountOrderByAggregateInput
    _max?: ProviderMaxOrderByAggregateInput
    _min?: ProviderMinOrderByAggregateInput
  }

  export type ProviderScalarWhereWithAggregatesInput = {
    AND?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    OR?: ProviderScalarWhereWithAggregatesInput[]
    NOT?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Provider"> | string
    userId?: StringWithAggregatesFilter<"Provider"> | string
    provider?: EnumProviderEnumWithAggregatesFilter<"Provider"> | $Enums.ProviderEnum
    providerAccountId?: StringWithAggregatesFilter<"Provider"> | string
  }

  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    id?: StringFilter<"Token"> | string
    providerId?: StringFilter<"Token"> | string
    refresh_token?: StringNullableFilter<"Token"> | string | null
    access_token?: StringNullableFilter<"Token"> | string | null
    expires_at?: IntNullableFilter<"Token"> | number | null
    token_type?: StringNullableFilter<"Token"> | string | null
    scope?: StringNullableFilter<"Token"> | string | null
    id_token?: StringNullableFilter<"Token"> | string | null
    session_state?: StringNullableFilter<"Token"> | string | null
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    provider?: ProviderOrderByWithRelationInput
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId?: string
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    refresh_token?: StringNullableFilter<"Token"> | string | null
    access_token?: StringNullableFilter<"Token"> | string | null
    expires_at?: IntNullableFilter<"Token"> | number | null
    token_type?: StringNullableFilter<"Token"> | string | null
    scope?: StringNullableFilter<"Token"> | string | null
    id_token?: StringNullableFilter<"Token"> | string | null
    session_state?: StringNullableFilter<"Token"> | string | null
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }, "id" | "providerId">

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: TokenCountOrderByAggregateInput
    _avg?: TokenAvgOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
    _sum?: TokenSumOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Token"> | string
    providerId?: StringWithAggregatesFilter<"Token"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Token"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Token"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Token"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Token"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Token"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Token"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Token"> | string | null
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    logo?: StringNullableFilter<"Company"> | string | null
    users?: UserListRelationFilter
    jobPostings?: JobPostingListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    users?: UserOrderByRelationAggregateInput
    jobPostings?: JobPostingOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    logo?: StringNullableFilter<"Company"> | string | null
    users?: UserListRelationFilter
    jobPostings?: JobPostingListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    logo?: StringNullableWithAggregatesFilter<"Company"> | string | null
  }

  export type JobPostingWhereInput = {
    AND?: JobPostingWhereInput | JobPostingWhereInput[]
    OR?: JobPostingWhereInput[]
    NOT?: JobPostingWhereInput | JobPostingWhereInput[]
    id?: StringFilter<"JobPosting"> | string
    title?: StringFilter<"JobPosting"> | string
    companyName?: StringFilter<"JobPosting"> | string
    companyLogo?: StringNullableFilter<"JobPosting"> | string | null
    jobPostingUrl?: StringFilter<"JobPosting"> | string
    jobDescription?: StringFilter<"JobPosting"> | string
    markdownText?: StringFilter<"JobPosting"> | string
    status?: StringFilter<"JobPosting"> | string
    endsAt?: StringNullableFilter<"JobPosting"> | string | null
    createdAt?: StringFilter<"JobPosting"> | string
    updatedAt?: StringFilter<"JobPosting"> | string
    companyId?: StringNullableFilter<"JobPosting"> | string | null
    language?: JobPostingLanguageListRelationFilter
    jobRequirements?: JobPostingRequirementListRelationFilter
    merits?: JobPostingMeritListRelationFilter
    applicantQualities?: JobPostingApplicantQualityListRelationFilter
    location?: XOR<JobPostingLocationNullableScalarRelationFilter, JobPostingLocationWhereInput> | null
    workArrengment?: XOR<JobPostingWorkArrengmentNullableScalarRelationFilter, JobPostingWorkArrengmentWhereInput> | null
    employmentType?: XOR<JobPostingEmploymentTypeNullableScalarRelationFilter, JobPostingEmploymentTypeWhereInput> | null
    salary?: XOR<JobPostingSalaryNullableScalarRelationFilter, JobPostingSalaryWhereInput> | null
    createdJobPosting?: XOR<CreatedJobPostingNullableScalarRelationFilter, CreatedJobPostingWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    userJobApplications?: JobApplicantsListRelationFilter
    userProcesses?: UserProcessListRelationFilter
  }

  export type JobPostingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    companyName?: SortOrder
    companyLogo?: SortOrderInput | SortOrder
    jobPostingUrl?: SortOrder
    jobDescription?: SortOrder
    markdownText?: SortOrder
    status?: SortOrder
    endsAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    language?: JobPostingLanguageOrderByRelationAggregateInput
    jobRequirements?: JobPostingRequirementOrderByRelationAggregateInput
    merits?: JobPostingMeritOrderByRelationAggregateInput
    applicantQualities?: JobPostingApplicantQualityOrderByRelationAggregateInput
    location?: JobPostingLocationOrderByWithRelationInput
    workArrengment?: JobPostingWorkArrengmentOrderByWithRelationInput
    employmentType?: JobPostingEmploymentTypeOrderByWithRelationInput
    salary?: JobPostingSalaryOrderByWithRelationInput
    createdJobPosting?: CreatedJobPostingOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    userJobApplications?: JobApplicantsOrderByRelationAggregateInput
    userProcesses?: UserProcessOrderByRelationAggregateInput
  }

  export type JobPostingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobPostingUrl?: string
    AND?: JobPostingWhereInput | JobPostingWhereInput[]
    OR?: JobPostingWhereInput[]
    NOT?: JobPostingWhereInput | JobPostingWhereInput[]
    title?: StringFilter<"JobPosting"> | string
    companyName?: StringFilter<"JobPosting"> | string
    companyLogo?: StringNullableFilter<"JobPosting"> | string | null
    jobDescription?: StringFilter<"JobPosting"> | string
    markdownText?: StringFilter<"JobPosting"> | string
    status?: StringFilter<"JobPosting"> | string
    endsAt?: StringNullableFilter<"JobPosting"> | string | null
    createdAt?: StringFilter<"JobPosting"> | string
    updatedAt?: StringFilter<"JobPosting"> | string
    companyId?: StringNullableFilter<"JobPosting"> | string | null
    language?: JobPostingLanguageListRelationFilter
    jobRequirements?: JobPostingRequirementListRelationFilter
    merits?: JobPostingMeritListRelationFilter
    applicantQualities?: JobPostingApplicantQualityListRelationFilter
    location?: XOR<JobPostingLocationNullableScalarRelationFilter, JobPostingLocationWhereInput> | null
    workArrengment?: XOR<JobPostingWorkArrengmentNullableScalarRelationFilter, JobPostingWorkArrengmentWhereInput> | null
    employmentType?: XOR<JobPostingEmploymentTypeNullableScalarRelationFilter, JobPostingEmploymentTypeWhereInput> | null
    salary?: XOR<JobPostingSalaryNullableScalarRelationFilter, JobPostingSalaryWhereInput> | null
    createdJobPosting?: XOR<CreatedJobPostingNullableScalarRelationFilter, CreatedJobPostingWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    userJobApplications?: JobApplicantsListRelationFilter
    userProcesses?: UserProcessListRelationFilter
  }, "id" | "jobPostingUrl">

  export type JobPostingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    companyName?: SortOrder
    companyLogo?: SortOrderInput | SortOrder
    jobPostingUrl?: SortOrder
    jobDescription?: SortOrder
    markdownText?: SortOrder
    status?: SortOrder
    endsAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: JobPostingCountOrderByAggregateInput
    _max?: JobPostingMaxOrderByAggregateInput
    _min?: JobPostingMinOrderByAggregateInput
  }

  export type JobPostingScalarWhereWithAggregatesInput = {
    AND?: JobPostingScalarWhereWithAggregatesInput | JobPostingScalarWhereWithAggregatesInput[]
    OR?: JobPostingScalarWhereWithAggregatesInput[]
    NOT?: JobPostingScalarWhereWithAggregatesInput | JobPostingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobPosting"> | string
    title?: StringWithAggregatesFilter<"JobPosting"> | string
    companyName?: StringWithAggregatesFilter<"JobPosting"> | string
    companyLogo?: StringNullableWithAggregatesFilter<"JobPosting"> | string | null
    jobPostingUrl?: StringWithAggregatesFilter<"JobPosting"> | string
    jobDescription?: StringWithAggregatesFilter<"JobPosting"> | string
    markdownText?: StringWithAggregatesFilter<"JobPosting"> | string
    status?: StringWithAggregatesFilter<"JobPosting"> | string
    endsAt?: StringNullableWithAggregatesFilter<"JobPosting"> | string | null
    createdAt?: StringWithAggregatesFilter<"JobPosting"> | string
    updatedAt?: StringWithAggregatesFilter<"JobPosting"> | string
    companyId?: StringNullableWithAggregatesFilter<"JobPosting"> | string | null
  }

  export type JobPostingLanguageWhereInput = {
    AND?: JobPostingLanguageWhereInput | JobPostingLanguageWhereInput[]
    OR?: JobPostingLanguageWhereInput[]
    NOT?: JobPostingLanguageWhereInput | JobPostingLanguageWhereInput[]
    id?: StringFilter<"JobPostingLanguage"> | string
    jobPostingId?: StringFilter<"JobPostingLanguage"> | string
    language?: StringFilter<"JobPostingLanguage"> | string
    level?: StringNullableFilter<"JobPostingLanguage"> | string | null
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }

  export type JobPostingLanguageOrderByWithRelationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    language?: SortOrder
    level?: SortOrderInput | SortOrder
    jobPosting?: JobPostingOrderByWithRelationInput
  }

  export type JobPostingLanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobPostingLanguageWhereInput | JobPostingLanguageWhereInput[]
    OR?: JobPostingLanguageWhereInput[]
    NOT?: JobPostingLanguageWhereInput | JobPostingLanguageWhereInput[]
    jobPostingId?: StringFilter<"JobPostingLanguage"> | string
    language?: StringFilter<"JobPostingLanguage"> | string
    level?: StringNullableFilter<"JobPostingLanguage"> | string | null
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }, "id">

  export type JobPostingLanguageOrderByWithAggregationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    language?: SortOrder
    level?: SortOrderInput | SortOrder
    _count?: JobPostingLanguageCountOrderByAggregateInput
    _max?: JobPostingLanguageMaxOrderByAggregateInput
    _min?: JobPostingLanguageMinOrderByAggregateInput
  }

  export type JobPostingLanguageScalarWhereWithAggregatesInput = {
    AND?: JobPostingLanguageScalarWhereWithAggregatesInput | JobPostingLanguageScalarWhereWithAggregatesInput[]
    OR?: JobPostingLanguageScalarWhereWithAggregatesInput[]
    NOT?: JobPostingLanguageScalarWhereWithAggregatesInput | JobPostingLanguageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobPostingLanguage"> | string
    jobPostingId?: StringWithAggregatesFilter<"JobPostingLanguage"> | string
    language?: StringWithAggregatesFilter<"JobPostingLanguage"> | string
    level?: StringNullableWithAggregatesFilter<"JobPostingLanguage"> | string | null
  }

  export type JobPostingRequirementWhereInput = {
    AND?: JobPostingRequirementWhereInput | JobPostingRequirementWhereInput[]
    OR?: JobPostingRequirementWhereInput[]
    NOT?: JobPostingRequirementWhereInput | JobPostingRequirementWhereInput[]
    id?: StringFilter<"JobPostingRequirement"> | string
    jobPostingId?: StringFilter<"JobPostingRequirement"> | string
    requirement?: StringFilter<"JobPostingRequirement"> | string
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }

  export type JobPostingRequirementOrderByWithRelationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    requirement?: SortOrder
    jobPosting?: JobPostingOrderByWithRelationInput
  }

  export type JobPostingRequirementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobPostingRequirementWhereInput | JobPostingRequirementWhereInput[]
    OR?: JobPostingRequirementWhereInput[]
    NOT?: JobPostingRequirementWhereInput | JobPostingRequirementWhereInput[]
    jobPostingId?: StringFilter<"JobPostingRequirement"> | string
    requirement?: StringFilter<"JobPostingRequirement"> | string
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }, "id">

  export type JobPostingRequirementOrderByWithAggregationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    requirement?: SortOrder
    _count?: JobPostingRequirementCountOrderByAggregateInput
    _max?: JobPostingRequirementMaxOrderByAggregateInput
    _min?: JobPostingRequirementMinOrderByAggregateInput
  }

  export type JobPostingRequirementScalarWhereWithAggregatesInput = {
    AND?: JobPostingRequirementScalarWhereWithAggregatesInput | JobPostingRequirementScalarWhereWithAggregatesInput[]
    OR?: JobPostingRequirementScalarWhereWithAggregatesInput[]
    NOT?: JobPostingRequirementScalarWhereWithAggregatesInput | JobPostingRequirementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobPostingRequirement"> | string
    jobPostingId?: StringWithAggregatesFilter<"JobPostingRequirement"> | string
    requirement?: StringWithAggregatesFilter<"JobPostingRequirement"> | string
  }

  export type JobPostingMeritWhereInput = {
    AND?: JobPostingMeritWhereInput | JobPostingMeritWhereInput[]
    OR?: JobPostingMeritWhereInput[]
    NOT?: JobPostingMeritWhereInput | JobPostingMeritWhereInput[]
    id?: StringFilter<"JobPostingMerit"> | string
    jobPostingId?: StringFilter<"JobPostingMerit"> | string
    merit?: StringFilter<"JobPostingMerit"> | string
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }

  export type JobPostingMeritOrderByWithRelationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    merit?: SortOrder
    jobPosting?: JobPostingOrderByWithRelationInput
  }

  export type JobPostingMeritWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobPostingMeritWhereInput | JobPostingMeritWhereInput[]
    OR?: JobPostingMeritWhereInput[]
    NOT?: JobPostingMeritWhereInput | JobPostingMeritWhereInput[]
    jobPostingId?: StringFilter<"JobPostingMerit"> | string
    merit?: StringFilter<"JobPostingMerit"> | string
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }, "id">

  export type JobPostingMeritOrderByWithAggregationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    merit?: SortOrder
    _count?: JobPostingMeritCountOrderByAggregateInput
    _max?: JobPostingMeritMaxOrderByAggregateInput
    _min?: JobPostingMeritMinOrderByAggregateInput
  }

  export type JobPostingMeritScalarWhereWithAggregatesInput = {
    AND?: JobPostingMeritScalarWhereWithAggregatesInput | JobPostingMeritScalarWhereWithAggregatesInput[]
    OR?: JobPostingMeritScalarWhereWithAggregatesInput[]
    NOT?: JobPostingMeritScalarWhereWithAggregatesInput | JobPostingMeritScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobPostingMerit"> | string
    jobPostingId?: StringWithAggregatesFilter<"JobPostingMerit"> | string
    merit?: StringWithAggregatesFilter<"JobPostingMerit"> | string
  }

  export type JobPostingApplicantQualityWhereInput = {
    AND?: JobPostingApplicantQualityWhereInput | JobPostingApplicantQualityWhereInput[]
    OR?: JobPostingApplicantQualityWhereInput[]
    NOT?: JobPostingApplicantQualityWhereInput | JobPostingApplicantQualityWhereInput[]
    id?: StringFilter<"JobPostingApplicantQuality"> | string
    jobPostingId?: StringFilter<"JobPostingApplicantQuality"> | string
    quality?: StringFilter<"JobPostingApplicantQuality"> | string
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }

  export type JobPostingApplicantQualityOrderByWithRelationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    quality?: SortOrder
    jobPosting?: JobPostingOrderByWithRelationInput
  }

  export type JobPostingApplicantQualityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobPostingApplicantQualityWhereInput | JobPostingApplicantQualityWhereInput[]
    OR?: JobPostingApplicantQualityWhereInput[]
    NOT?: JobPostingApplicantQualityWhereInput | JobPostingApplicantQualityWhereInput[]
    jobPostingId?: StringFilter<"JobPostingApplicantQuality"> | string
    quality?: StringFilter<"JobPostingApplicantQuality"> | string
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }, "id">

  export type JobPostingApplicantQualityOrderByWithAggregationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    quality?: SortOrder
    _count?: JobPostingApplicantQualityCountOrderByAggregateInput
    _max?: JobPostingApplicantQualityMaxOrderByAggregateInput
    _min?: JobPostingApplicantQualityMinOrderByAggregateInput
  }

  export type JobPostingApplicantQualityScalarWhereWithAggregatesInput = {
    AND?: JobPostingApplicantQualityScalarWhereWithAggregatesInput | JobPostingApplicantQualityScalarWhereWithAggregatesInput[]
    OR?: JobPostingApplicantQualityScalarWhereWithAggregatesInput[]
    NOT?: JobPostingApplicantQualityScalarWhereWithAggregatesInput | JobPostingApplicantQualityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobPostingApplicantQuality"> | string
    jobPostingId?: StringWithAggregatesFilter<"JobPostingApplicantQuality"> | string
    quality?: StringWithAggregatesFilter<"JobPostingApplicantQuality"> | string
  }

  export type JobPostingLocationWhereInput = {
    AND?: JobPostingLocationWhereInput | JobPostingLocationWhereInput[]
    OR?: JobPostingLocationWhereInput[]
    NOT?: JobPostingLocationWhereInput | JobPostingLocationWhereInput[]
    id?: StringFilter<"JobPostingLocation"> | string
    jobPostingId?: StringFilter<"JobPostingLocation"> | string
    city?: StringNullableFilter<"JobPostingLocation"> | string | null
    region?: StringNullableFilter<"JobPostingLocation"> | string | null
    country?: StringFilter<"JobPostingLocation"> | string
    isRemote?: BoolFilter<"JobPostingLocation"> | boolean
    lat?: FloatNullableFilter<"JobPostingLocation"> | number | null
    lng?: FloatNullableFilter<"JobPostingLocation"> | number | null
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }

  export type JobPostingLocationOrderByWithRelationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    city?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrder
    isRemote?: SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    jobPosting?: JobPostingOrderByWithRelationInput
  }

  export type JobPostingLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobPostingId?: string
    AND?: JobPostingLocationWhereInput | JobPostingLocationWhereInput[]
    OR?: JobPostingLocationWhereInput[]
    NOT?: JobPostingLocationWhereInput | JobPostingLocationWhereInput[]
    city?: StringNullableFilter<"JobPostingLocation"> | string | null
    region?: StringNullableFilter<"JobPostingLocation"> | string | null
    country?: StringFilter<"JobPostingLocation"> | string
    isRemote?: BoolFilter<"JobPostingLocation"> | boolean
    lat?: FloatNullableFilter<"JobPostingLocation"> | number | null
    lng?: FloatNullableFilter<"JobPostingLocation"> | number | null
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }, "id" | "jobPostingId">

  export type JobPostingLocationOrderByWithAggregationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    city?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrder
    isRemote?: SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    _count?: JobPostingLocationCountOrderByAggregateInput
    _avg?: JobPostingLocationAvgOrderByAggregateInput
    _max?: JobPostingLocationMaxOrderByAggregateInput
    _min?: JobPostingLocationMinOrderByAggregateInput
    _sum?: JobPostingLocationSumOrderByAggregateInput
  }

  export type JobPostingLocationScalarWhereWithAggregatesInput = {
    AND?: JobPostingLocationScalarWhereWithAggregatesInput | JobPostingLocationScalarWhereWithAggregatesInput[]
    OR?: JobPostingLocationScalarWhereWithAggregatesInput[]
    NOT?: JobPostingLocationScalarWhereWithAggregatesInput | JobPostingLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobPostingLocation"> | string
    jobPostingId?: StringWithAggregatesFilter<"JobPostingLocation"> | string
    city?: StringNullableWithAggregatesFilter<"JobPostingLocation"> | string | null
    region?: StringNullableWithAggregatesFilter<"JobPostingLocation"> | string | null
    country?: StringWithAggregatesFilter<"JobPostingLocation"> | string
    isRemote?: BoolWithAggregatesFilter<"JobPostingLocation"> | boolean
    lat?: FloatNullableWithAggregatesFilter<"JobPostingLocation"> | number | null
    lng?: FloatNullableWithAggregatesFilter<"JobPostingLocation"> | number | null
  }

  export type JobPostingWorkArrengmentWhereInput = {
    AND?: JobPostingWorkArrengmentWhereInput | JobPostingWorkArrengmentWhereInput[]
    OR?: JobPostingWorkArrengmentWhereInput[]
    NOT?: JobPostingWorkArrengmentWhereInput | JobPostingWorkArrengmentWhereInput[]
    id?: StringFilter<"JobPostingWorkArrengment"> | string
    jobPostingId?: StringFilter<"JobPostingWorkArrengment"> | string
    mode?: StringFilter<"JobPostingWorkArrengment"> | string
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }

  export type JobPostingWorkArrengmentOrderByWithRelationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    mode?: SortOrder
    jobPosting?: JobPostingOrderByWithRelationInput
  }

  export type JobPostingWorkArrengmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobPostingId?: string
    AND?: JobPostingWorkArrengmentWhereInput | JobPostingWorkArrengmentWhereInput[]
    OR?: JobPostingWorkArrengmentWhereInput[]
    NOT?: JobPostingWorkArrengmentWhereInput | JobPostingWorkArrengmentWhereInput[]
    mode?: StringFilter<"JobPostingWorkArrengment"> | string
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }, "id" | "jobPostingId">

  export type JobPostingWorkArrengmentOrderByWithAggregationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    mode?: SortOrder
    _count?: JobPostingWorkArrengmentCountOrderByAggregateInput
    _max?: JobPostingWorkArrengmentMaxOrderByAggregateInput
    _min?: JobPostingWorkArrengmentMinOrderByAggregateInput
  }

  export type JobPostingWorkArrengmentScalarWhereWithAggregatesInput = {
    AND?: JobPostingWorkArrengmentScalarWhereWithAggregatesInput | JobPostingWorkArrengmentScalarWhereWithAggregatesInput[]
    OR?: JobPostingWorkArrengmentScalarWhereWithAggregatesInput[]
    NOT?: JobPostingWorkArrengmentScalarWhereWithAggregatesInput | JobPostingWorkArrengmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobPostingWorkArrengment"> | string
    jobPostingId?: StringWithAggregatesFilter<"JobPostingWorkArrengment"> | string
    mode?: StringWithAggregatesFilter<"JobPostingWorkArrengment"> | string
  }

  export type JobPostingEmploymentTypeWhereInput = {
    AND?: JobPostingEmploymentTypeWhereInput | JobPostingEmploymentTypeWhereInput[]
    OR?: JobPostingEmploymentTypeWhereInput[]
    NOT?: JobPostingEmploymentTypeWhereInput | JobPostingEmploymentTypeWhereInput[]
    id?: StringFilter<"JobPostingEmploymentType"> | string
    jobPostingId?: StringFilter<"JobPostingEmploymentType"> | string
    type?: StringFilter<"JobPostingEmploymentType"> | string
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }

  export type JobPostingEmploymentTypeOrderByWithRelationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    type?: SortOrder
    jobPosting?: JobPostingOrderByWithRelationInput
  }

  export type JobPostingEmploymentTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobPostingId?: string
    AND?: JobPostingEmploymentTypeWhereInput | JobPostingEmploymentTypeWhereInput[]
    OR?: JobPostingEmploymentTypeWhereInput[]
    NOT?: JobPostingEmploymentTypeWhereInput | JobPostingEmploymentTypeWhereInput[]
    type?: StringFilter<"JobPostingEmploymentType"> | string
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }, "id" | "jobPostingId">

  export type JobPostingEmploymentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    type?: SortOrder
    _count?: JobPostingEmploymentTypeCountOrderByAggregateInput
    _max?: JobPostingEmploymentTypeMaxOrderByAggregateInput
    _min?: JobPostingEmploymentTypeMinOrderByAggregateInput
  }

  export type JobPostingEmploymentTypeScalarWhereWithAggregatesInput = {
    AND?: JobPostingEmploymentTypeScalarWhereWithAggregatesInput | JobPostingEmploymentTypeScalarWhereWithAggregatesInput[]
    OR?: JobPostingEmploymentTypeScalarWhereWithAggregatesInput[]
    NOT?: JobPostingEmploymentTypeScalarWhereWithAggregatesInput | JobPostingEmploymentTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobPostingEmploymentType"> | string
    jobPostingId?: StringWithAggregatesFilter<"JobPostingEmploymentType"> | string
    type?: StringWithAggregatesFilter<"JobPostingEmploymentType"> | string
  }

  export type JobPostingSalaryWhereInput = {
    AND?: JobPostingSalaryWhereInput | JobPostingSalaryWhereInput[]
    OR?: JobPostingSalaryWhereInput[]
    NOT?: JobPostingSalaryWhereInput | JobPostingSalaryWhereInput[]
    id?: StringFilter<"JobPostingSalary"> | string
    jobPostingId?: StringFilter<"JobPostingSalary"> | string
    type?: StringFilter<"JobPostingSalary"> | string
    amount?: StringNullableFilter<"JobPostingSalary"> | string | null
    currency?: StringFilter<"JobPostingSalary"> | string
    period?: StringFilter<"JobPostingSalary"> | string
    benefits?: StringNullableListFilter<"JobPostingSalary">
    notes?: StringNullableFilter<"JobPostingSalary"> | string | null
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }

  export type JobPostingSalaryOrderByWithRelationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    type?: SortOrder
    amount?: SortOrderInput | SortOrder
    currency?: SortOrder
    period?: SortOrder
    benefits?: SortOrder
    notes?: SortOrderInput | SortOrder
    jobPosting?: JobPostingOrderByWithRelationInput
  }

  export type JobPostingSalaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobPostingId?: string
    AND?: JobPostingSalaryWhereInput | JobPostingSalaryWhereInput[]
    OR?: JobPostingSalaryWhereInput[]
    NOT?: JobPostingSalaryWhereInput | JobPostingSalaryWhereInput[]
    type?: StringFilter<"JobPostingSalary"> | string
    amount?: StringNullableFilter<"JobPostingSalary"> | string | null
    currency?: StringFilter<"JobPostingSalary"> | string
    period?: StringFilter<"JobPostingSalary"> | string
    benefits?: StringNullableListFilter<"JobPostingSalary">
    notes?: StringNullableFilter<"JobPostingSalary"> | string | null
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }, "id" | "jobPostingId">

  export type JobPostingSalaryOrderByWithAggregationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    type?: SortOrder
    amount?: SortOrderInput | SortOrder
    currency?: SortOrder
    period?: SortOrder
    benefits?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: JobPostingSalaryCountOrderByAggregateInput
    _max?: JobPostingSalaryMaxOrderByAggregateInput
    _min?: JobPostingSalaryMinOrderByAggregateInput
  }

  export type JobPostingSalaryScalarWhereWithAggregatesInput = {
    AND?: JobPostingSalaryScalarWhereWithAggregatesInput | JobPostingSalaryScalarWhereWithAggregatesInput[]
    OR?: JobPostingSalaryScalarWhereWithAggregatesInput[]
    NOT?: JobPostingSalaryScalarWhereWithAggregatesInput | JobPostingSalaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobPostingSalary"> | string
    jobPostingId?: StringWithAggregatesFilter<"JobPostingSalary"> | string
    type?: StringWithAggregatesFilter<"JobPostingSalary"> | string
    amount?: StringNullableWithAggregatesFilter<"JobPostingSalary"> | string | null
    currency?: StringWithAggregatesFilter<"JobPostingSalary"> | string
    period?: StringWithAggregatesFilter<"JobPostingSalary"> | string
    benefits?: StringNullableListFilter<"JobPostingSalary">
    notes?: StringNullableWithAggregatesFilter<"JobPostingSalary"> | string | null
  }

  export type CreatedJobPostingWhereInput = {
    AND?: CreatedJobPostingWhereInput | CreatedJobPostingWhereInput[]
    OR?: CreatedJobPostingWhereInput[]
    NOT?: CreatedJobPostingWhereInput | CreatedJobPostingWhereInput[]
    id?: StringFilter<"CreatedJobPosting"> | string
    jobPostingId?: StringFilter<"CreatedJobPosting"> | string
    createdByType?: EnumCreatedByEnumFilter<"CreatedJobPosting"> | $Enums.CreatedByEnum
    createdById?: StringNullableFilter<"CreatedJobPosting"> | string | null
    source?: EnumJobSourceEnumNullableFilter<"CreatedJobPosting"> | $Enums.JobSourceEnum | null
    importedAt?: DateTimeNullableFilter<"CreatedJobPosting"> | Date | string | null
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CreatedJobPostingOrderByWithRelationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    createdByType?: SortOrder
    createdById?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    importedAt?: SortOrderInput | SortOrder
    jobPosting?: JobPostingOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type CreatedJobPostingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobPostingId?: string
    AND?: CreatedJobPostingWhereInput | CreatedJobPostingWhereInput[]
    OR?: CreatedJobPostingWhereInput[]
    NOT?: CreatedJobPostingWhereInput | CreatedJobPostingWhereInput[]
    createdByType?: EnumCreatedByEnumFilter<"CreatedJobPosting"> | $Enums.CreatedByEnum
    createdById?: StringNullableFilter<"CreatedJobPosting"> | string | null
    source?: EnumJobSourceEnumNullableFilter<"CreatedJobPosting"> | $Enums.JobSourceEnum | null
    importedAt?: DateTimeNullableFilter<"CreatedJobPosting"> | Date | string | null
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "jobPostingId">

  export type CreatedJobPostingOrderByWithAggregationInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    createdByType?: SortOrder
    createdById?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    importedAt?: SortOrderInput | SortOrder
    _count?: CreatedJobPostingCountOrderByAggregateInput
    _max?: CreatedJobPostingMaxOrderByAggregateInput
    _min?: CreatedJobPostingMinOrderByAggregateInput
  }

  export type CreatedJobPostingScalarWhereWithAggregatesInput = {
    AND?: CreatedJobPostingScalarWhereWithAggregatesInput | CreatedJobPostingScalarWhereWithAggregatesInput[]
    OR?: CreatedJobPostingScalarWhereWithAggregatesInput[]
    NOT?: CreatedJobPostingScalarWhereWithAggregatesInput | CreatedJobPostingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreatedJobPosting"> | string
    jobPostingId?: StringWithAggregatesFilter<"CreatedJobPosting"> | string
    createdByType?: EnumCreatedByEnumWithAggregatesFilter<"CreatedJobPosting"> | $Enums.CreatedByEnum
    createdById?: StringNullableWithAggregatesFilter<"CreatedJobPosting"> | string | null
    source?: EnumJobSourceEnumNullableWithAggregatesFilter<"CreatedJobPosting"> | $Enums.JobSourceEnum | null
    importedAt?: DateTimeNullableWithAggregatesFilter<"CreatedJobPosting"> | Date | string | null
  }

  export type JobApplicantsWhereInput = {
    AND?: JobApplicantsWhereInput | JobApplicantsWhereInput[]
    OR?: JobApplicantsWhereInput[]
    NOT?: JobApplicantsWhereInput | JobApplicantsWhereInput[]
    id?: StringFilter<"JobApplicants"> | string
    userId?: StringFilter<"JobApplicants"> | string
    jobPostingId?: StringFilter<"JobApplicants"> | string
    status?: StringFilter<"JobApplicants"> | string
    appliedAt?: StringFilter<"JobApplicants"> | string
    gotJob?: BoolFilter<"JobApplicants"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }

  export type JobApplicantsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    jobPostingId?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    gotJob?: SortOrder
    user?: UserOrderByWithRelationInput
    jobPosting?: JobPostingOrderByWithRelationInput
  }

  export type JobApplicantsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_jobPostingId?: JobApplicantsUserIdJobPostingIdCompoundUniqueInput
    AND?: JobApplicantsWhereInput | JobApplicantsWhereInput[]
    OR?: JobApplicantsWhereInput[]
    NOT?: JobApplicantsWhereInput | JobApplicantsWhereInput[]
    userId?: StringFilter<"JobApplicants"> | string
    jobPostingId?: StringFilter<"JobApplicants"> | string
    status?: StringFilter<"JobApplicants"> | string
    appliedAt?: StringFilter<"JobApplicants"> | string
    gotJob?: BoolFilter<"JobApplicants"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    jobPosting?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
  }, "id" | "userId_jobPostingId">

  export type JobApplicantsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    jobPostingId?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    gotJob?: SortOrder
    _count?: JobApplicantsCountOrderByAggregateInput
    _max?: JobApplicantsMaxOrderByAggregateInput
    _min?: JobApplicantsMinOrderByAggregateInput
  }

  export type JobApplicantsScalarWhereWithAggregatesInput = {
    AND?: JobApplicantsScalarWhereWithAggregatesInput | JobApplicantsScalarWhereWithAggregatesInput[]
    OR?: JobApplicantsScalarWhereWithAggregatesInput[]
    NOT?: JobApplicantsScalarWhereWithAggregatesInput | JobApplicantsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobApplicants"> | string
    userId?: StringWithAggregatesFilter<"JobApplicants"> | string
    jobPostingId?: StringWithAggregatesFilter<"JobApplicants"> | string
    status?: StringWithAggregatesFilter<"JobApplicants"> | string
    appliedAt?: StringWithAggregatesFilter<"JobApplicants"> | string
    gotJob?: BoolWithAggregatesFilter<"JobApplicants"> | boolean
  }

  export type UserProcessWhereInput = {
    AND?: UserProcessWhereInput | UserProcessWhereInput[]
    OR?: UserProcessWhereInput[]
    NOT?: UserProcessWhereInput | UserProcessWhereInput[]
    id?: StringFilter<"UserProcess"> | string
    userId?: StringFilter<"UserProcess"> | string
    status?: EnumStatusUserJobProcessesFilter<"UserProcess"> | $Enums.StatusUserJobProcesses
    startedAt?: StringNullableFilter<"UserProcess"> | string | null
    createdAt?: DateTimeFilter<"UserProcess"> | Date | string
    updatedAt?: DateTimeFilter<"UserProcess"> | Date | string
    completedAt?: StringNullableFilter<"UserProcess"> | string | null
    jobPostingId?: StringFilter<"UserProcess"> | string
    processId?: StringNullableFilter<"UserProcess"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    steps?: UserProcessStepListRelationFilter
    jobPosting?: XOR<JobPostingNullableScalarRelationFilter, JobPostingWhereInput> | null
    process?: XOR<ProcessNullableScalarRelationFilter, ProcessWhereInput> | null
    todos?: TodoUserProcessListRelationFilter
  }

  export type UserProcessOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    jobPostingId?: SortOrder
    processId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    steps?: UserProcessStepOrderByRelationAggregateInput
    jobPosting?: JobPostingOrderByWithRelationInput
    process?: ProcessOrderByWithRelationInput
    todos?: TodoUserProcessOrderByRelationAggregateInput
  }

  export type UserProcessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_jobPostingId?: UserProcessUserIdJobPostingIdCompoundUniqueInput
    AND?: UserProcessWhereInput | UserProcessWhereInput[]
    OR?: UserProcessWhereInput[]
    NOT?: UserProcessWhereInput | UserProcessWhereInput[]
    userId?: StringFilter<"UserProcess"> | string
    status?: EnumStatusUserJobProcessesFilter<"UserProcess"> | $Enums.StatusUserJobProcesses
    startedAt?: StringNullableFilter<"UserProcess"> | string | null
    createdAt?: DateTimeFilter<"UserProcess"> | Date | string
    updatedAt?: DateTimeFilter<"UserProcess"> | Date | string
    completedAt?: StringNullableFilter<"UserProcess"> | string | null
    jobPostingId?: StringFilter<"UserProcess"> | string
    processId?: StringNullableFilter<"UserProcess"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    steps?: UserProcessStepListRelationFilter
    jobPosting?: XOR<JobPostingNullableScalarRelationFilter, JobPostingWhereInput> | null
    process?: XOR<ProcessNullableScalarRelationFilter, ProcessWhereInput> | null
    todos?: TodoUserProcessListRelationFilter
  }, "id" | "userId_jobPostingId">

  export type UserProcessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    jobPostingId?: SortOrder
    processId?: SortOrderInput | SortOrder
    _count?: UserProcessCountOrderByAggregateInput
    _max?: UserProcessMaxOrderByAggregateInput
    _min?: UserProcessMinOrderByAggregateInput
  }

  export type UserProcessScalarWhereWithAggregatesInput = {
    AND?: UserProcessScalarWhereWithAggregatesInput | UserProcessScalarWhereWithAggregatesInput[]
    OR?: UserProcessScalarWhereWithAggregatesInput[]
    NOT?: UserProcessScalarWhereWithAggregatesInput | UserProcessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProcess"> | string
    userId?: StringWithAggregatesFilter<"UserProcess"> | string
    status?: EnumStatusUserJobProcessesWithAggregatesFilter<"UserProcess"> | $Enums.StatusUserJobProcesses
    startedAt?: StringNullableWithAggregatesFilter<"UserProcess"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserProcess"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProcess"> | Date | string
    completedAt?: StringNullableWithAggregatesFilter<"UserProcess"> | string | null
    jobPostingId?: StringWithAggregatesFilter<"UserProcess"> | string
    processId?: StringNullableWithAggregatesFilter<"UserProcess"> | string | null
  }

  export type UserProcessStepWhereInput = {
    AND?: UserProcessStepWhereInput | UserProcessStepWhereInput[]
    OR?: UserProcessStepWhereInput[]
    NOT?: UserProcessStepWhereInput | UserProcessStepWhereInput[]
    id?: StringFilter<"UserProcessStep"> | string
    userProcessId?: StringFilter<"UserProcessStep"> | string
    stepId?: StringNullableFilter<"UserProcessStep"> | string | null
    isExecuted?: BoolFilter<"UserProcessStep"> | boolean
    executedAt?: StringNullableFilter<"UserProcessStep"> | string | null
    comments?: UserPipelineStepCommentListRelationFilter
    process?: XOR<UserProcessScalarRelationFilter, UserProcessWhereInput>
    step?: XOR<ProcessStepNullableScalarRelationFilter, ProcessStepWhereInput> | null
  }

  export type UserProcessStepOrderByWithRelationInput = {
    id?: SortOrder
    userProcessId?: SortOrder
    stepId?: SortOrderInput | SortOrder
    isExecuted?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    comments?: UserPipelineStepCommentOrderByRelationAggregateInput
    process?: UserProcessOrderByWithRelationInput
    step?: ProcessStepOrderByWithRelationInput
  }

  export type UserProcessStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stepId?: string
    userProcessId_stepId?: UserProcessStepUserProcessIdStepIdCompoundUniqueInput
    AND?: UserProcessStepWhereInput | UserProcessStepWhereInput[]
    OR?: UserProcessStepWhereInput[]
    NOT?: UserProcessStepWhereInput | UserProcessStepWhereInput[]
    userProcessId?: StringFilter<"UserProcessStep"> | string
    isExecuted?: BoolFilter<"UserProcessStep"> | boolean
    executedAt?: StringNullableFilter<"UserProcessStep"> | string | null
    comments?: UserPipelineStepCommentListRelationFilter
    process?: XOR<UserProcessScalarRelationFilter, UserProcessWhereInput>
    step?: XOR<ProcessStepNullableScalarRelationFilter, ProcessStepWhereInput> | null
  }, "id" | "stepId" | "userProcessId_stepId">

  export type UserProcessStepOrderByWithAggregationInput = {
    id?: SortOrder
    userProcessId?: SortOrder
    stepId?: SortOrderInput | SortOrder
    isExecuted?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    _count?: UserProcessStepCountOrderByAggregateInput
    _max?: UserProcessStepMaxOrderByAggregateInput
    _min?: UserProcessStepMinOrderByAggregateInput
  }

  export type UserProcessStepScalarWhereWithAggregatesInput = {
    AND?: UserProcessStepScalarWhereWithAggregatesInput | UserProcessStepScalarWhereWithAggregatesInput[]
    OR?: UserProcessStepScalarWhereWithAggregatesInput[]
    NOT?: UserProcessStepScalarWhereWithAggregatesInput | UserProcessStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProcessStep"> | string
    userProcessId?: StringWithAggregatesFilter<"UserProcessStep"> | string
    stepId?: StringNullableWithAggregatesFilter<"UserProcessStep"> | string | null
    isExecuted?: BoolWithAggregatesFilter<"UserProcessStep"> | boolean
    executedAt?: StringNullableWithAggregatesFilter<"UserProcessStep"> | string | null
  }

  export type UserPipelineStepCommentWhereInput = {
    AND?: UserPipelineStepCommentWhereInput | UserPipelineStepCommentWhereInput[]
    OR?: UserPipelineStepCommentWhereInput[]
    NOT?: UserPipelineStepCommentWhereInput | UserPipelineStepCommentWhereInput[]
    id?: StringFilter<"UserPipelineStepComment"> | string
    userPipelineStepId?: StringFilter<"UserPipelineStepComment"> | string
    userId?: StringFilter<"UserPipelineStepComment"> | string
    comment?: StringFilter<"UserPipelineStepComment"> | string
    createdAt?: StringFilter<"UserPipelineStepComment"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    step?: XOR<UserProcessStepScalarRelationFilter, UserProcessStepWhereInput>
  }

  export type UserPipelineStepCommentOrderByWithRelationInput = {
    id?: SortOrder
    userPipelineStepId?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    step?: UserProcessStepOrderByWithRelationInput
  }

  export type UserPipelineStepCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserPipelineStepCommentWhereInput | UserPipelineStepCommentWhereInput[]
    OR?: UserPipelineStepCommentWhereInput[]
    NOT?: UserPipelineStepCommentWhereInput | UserPipelineStepCommentWhereInput[]
    userPipelineStepId?: StringFilter<"UserPipelineStepComment"> | string
    userId?: StringFilter<"UserPipelineStepComment"> | string
    comment?: StringFilter<"UserPipelineStepComment"> | string
    createdAt?: StringFilter<"UserPipelineStepComment"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    step?: XOR<UserProcessStepScalarRelationFilter, UserProcessStepWhereInput>
  }, "id">

  export type UserPipelineStepCommentOrderByWithAggregationInput = {
    id?: SortOrder
    userPipelineStepId?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    _count?: UserPipelineStepCommentCountOrderByAggregateInput
    _max?: UserPipelineStepCommentMaxOrderByAggregateInput
    _min?: UserPipelineStepCommentMinOrderByAggregateInput
  }

  export type UserPipelineStepCommentScalarWhereWithAggregatesInput = {
    AND?: UserPipelineStepCommentScalarWhereWithAggregatesInput | UserPipelineStepCommentScalarWhereWithAggregatesInput[]
    OR?: UserPipelineStepCommentScalarWhereWithAggregatesInput[]
    NOT?: UserPipelineStepCommentScalarWhereWithAggregatesInput | UserPipelineStepCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPipelineStepComment"> | string
    userPipelineStepId?: StringWithAggregatesFilter<"UserPipelineStepComment"> | string
    userId?: StringWithAggregatesFilter<"UserPipelineStepComment"> | string
    comment?: StringWithAggregatesFilter<"UserPipelineStepComment"> | string
    createdAt?: StringWithAggregatesFilter<"UserPipelineStepComment"> | string
  }

  export type ProcessWhereInput = {
    AND?: ProcessWhereInput | ProcessWhereInput[]
    OR?: ProcessWhereInput[]
    NOT?: ProcessWhereInput | ProcessWhereInput[]
    id?: StringFilter<"Process"> | string
    name?: StringFilter<"Process"> | string
    description?: StringNullableFilter<"Process"> | string | null
    icon?: StringNullableFilter<"Process"> | string | null
    ownerId?: StringNullableFilter<"Process"> | string | null
    isTemplate?: BoolFilter<"Process"> | boolean
    isPublic?: BoolFilter<"Process"> | boolean
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    steps?: ProcessStepListRelationFilter
    processes?: UserProcessListRelationFilter
  }

  export type ProcessOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    isTemplate?: SortOrder
    isPublic?: SortOrder
    user?: UserOrderByWithRelationInput
    steps?: ProcessStepOrderByRelationAggregateInput
    processes?: UserProcessOrderByRelationAggregateInput
  }

  export type ProcessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_ownerId?: ProcessIdOwnerIdCompoundUniqueInput
    AND?: ProcessWhereInput | ProcessWhereInput[]
    OR?: ProcessWhereInput[]
    NOT?: ProcessWhereInput | ProcessWhereInput[]
    name?: StringFilter<"Process"> | string
    description?: StringNullableFilter<"Process"> | string | null
    icon?: StringNullableFilter<"Process"> | string | null
    ownerId?: StringNullableFilter<"Process"> | string | null
    isTemplate?: BoolFilter<"Process"> | boolean
    isPublic?: BoolFilter<"Process"> | boolean
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    steps?: ProcessStepListRelationFilter
    processes?: UserProcessListRelationFilter
  }, "id" | "id_ownerId">

  export type ProcessOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    isTemplate?: SortOrder
    isPublic?: SortOrder
    _count?: ProcessCountOrderByAggregateInput
    _max?: ProcessMaxOrderByAggregateInput
    _min?: ProcessMinOrderByAggregateInput
  }

  export type ProcessScalarWhereWithAggregatesInput = {
    AND?: ProcessScalarWhereWithAggregatesInput | ProcessScalarWhereWithAggregatesInput[]
    OR?: ProcessScalarWhereWithAggregatesInput[]
    NOT?: ProcessScalarWhereWithAggregatesInput | ProcessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Process"> | string
    name?: StringWithAggregatesFilter<"Process"> | string
    description?: StringNullableWithAggregatesFilter<"Process"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Process"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"Process"> | string | null
    isTemplate?: BoolWithAggregatesFilter<"Process"> | boolean
    isPublic?: BoolWithAggregatesFilter<"Process"> | boolean
  }

  export type ProcessStepWhereInput = {
    AND?: ProcessStepWhereInput | ProcessStepWhereInput[]
    OR?: ProcessStepWhereInput[]
    NOT?: ProcessStepWhereInput | ProcessStepWhereInput[]
    id?: StringFilter<"ProcessStep"> | string
    processId?: StringFilter<"ProcessStep"> | string
    title?: StringFilter<"ProcessStep"> | string
    description?: StringFilter<"ProcessStep"> | string
    icon?: StringNullableFilter<"ProcessStep"> | string | null
    order?: IntFilter<"ProcessStep"> | number
    userId?: StringNullableFilter<"ProcessStep"> | string | null
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
    triggers?: TriggerDefinitionListRelationFilter
    actions?: ActionDefinitionListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    userProcessSteps?: UserProcessStepListRelationFilter
  }

  export type ProcessStepOrderByWithRelationInput = {
    id?: SortOrder
    processId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    userId?: SortOrderInput | SortOrder
    process?: ProcessOrderByWithRelationInput
    triggers?: TriggerDefinitionOrderByRelationAggregateInput
    actions?: ActionDefinitionOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    userProcessSteps?: UserProcessStepOrderByRelationAggregateInput
  }

  export type ProcessStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessStepWhereInput | ProcessStepWhereInput[]
    OR?: ProcessStepWhereInput[]
    NOT?: ProcessStepWhereInput | ProcessStepWhereInput[]
    processId?: StringFilter<"ProcessStep"> | string
    title?: StringFilter<"ProcessStep"> | string
    description?: StringFilter<"ProcessStep"> | string
    icon?: StringNullableFilter<"ProcessStep"> | string | null
    order?: IntFilter<"ProcessStep"> | number
    userId?: StringNullableFilter<"ProcessStep"> | string | null
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
    triggers?: TriggerDefinitionListRelationFilter
    actions?: ActionDefinitionListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    userProcessSteps?: UserProcessStepListRelationFilter
  }, "id">

  export type ProcessStepOrderByWithAggregationInput = {
    id?: SortOrder
    processId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: ProcessStepCountOrderByAggregateInput
    _avg?: ProcessStepAvgOrderByAggregateInput
    _max?: ProcessStepMaxOrderByAggregateInput
    _min?: ProcessStepMinOrderByAggregateInput
    _sum?: ProcessStepSumOrderByAggregateInput
  }

  export type ProcessStepScalarWhereWithAggregatesInput = {
    AND?: ProcessStepScalarWhereWithAggregatesInput | ProcessStepScalarWhereWithAggregatesInput[]
    OR?: ProcessStepScalarWhereWithAggregatesInput[]
    NOT?: ProcessStepScalarWhereWithAggregatesInput | ProcessStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProcessStep"> | string
    processId?: StringWithAggregatesFilter<"ProcessStep"> | string
    title?: StringWithAggregatesFilter<"ProcessStep"> | string
    description?: StringWithAggregatesFilter<"ProcessStep"> | string
    icon?: StringNullableWithAggregatesFilter<"ProcessStep"> | string | null
    order?: IntWithAggregatesFilter<"ProcessStep"> | number
    userId?: StringNullableWithAggregatesFilter<"ProcessStep"> | string | null
  }

  export type ActionDefinitionWhereInput = {
    AND?: ActionDefinitionWhereInput | ActionDefinitionWhereInput[]
    OR?: ActionDefinitionWhereInput[]
    NOT?: ActionDefinitionWhereInput | ActionDefinitionWhereInput[]
    id?: StringFilter<"ActionDefinition"> | string
    name?: StringFilter<"ActionDefinition"> | string
    isPublic?: BoolFilter<"ActionDefinition"> | boolean
    order?: IntFilter<"ActionDefinition"> | number
    config?: JsonFilter<"ActionDefinition">
    stepId?: StringNullableFilter<"ActionDefinition"> | string | null
    step?: XOR<ProcessStepNullableScalarRelationFilter, ProcessStepWhereInput> | null
  }

  export type ActionDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isPublic?: SortOrder
    order?: SortOrder
    config?: SortOrder
    stepId?: SortOrderInput | SortOrder
    step?: ProcessStepOrderByWithRelationInput
  }

  export type ActionDefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActionDefinitionWhereInput | ActionDefinitionWhereInput[]
    OR?: ActionDefinitionWhereInput[]
    NOT?: ActionDefinitionWhereInput | ActionDefinitionWhereInput[]
    name?: StringFilter<"ActionDefinition"> | string
    isPublic?: BoolFilter<"ActionDefinition"> | boolean
    order?: IntFilter<"ActionDefinition"> | number
    config?: JsonFilter<"ActionDefinition">
    stepId?: StringNullableFilter<"ActionDefinition"> | string | null
    step?: XOR<ProcessStepNullableScalarRelationFilter, ProcessStepWhereInput> | null
  }, "id">

  export type ActionDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isPublic?: SortOrder
    order?: SortOrder
    config?: SortOrder
    stepId?: SortOrderInput | SortOrder
    _count?: ActionDefinitionCountOrderByAggregateInput
    _avg?: ActionDefinitionAvgOrderByAggregateInput
    _max?: ActionDefinitionMaxOrderByAggregateInput
    _min?: ActionDefinitionMinOrderByAggregateInput
    _sum?: ActionDefinitionSumOrderByAggregateInput
  }

  export type ActionDefinitionScalarWhereWithAggregatesInput = {
    AND?: ActionDefinitionScalarWhereWithAggregatesInput | ActionDefinitionScalarWhereWithAggregatesInput[]
    OR?: ActionDefinitionScalarWhereWithAggregatesInput[]
    NOT?: ActionDefinitionScalarWhereWithAggregatesInput | ActionDefinitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActionDefinition"> | string
    name?: StringWithAggregatesFilter<"ActionDefinition"> | string
    isPublic?: BoolWithAggregatesFilter<"ActionDefinition"> | boolean
    order?: IntWithAggregatesFilter<"ActionDefinition"> | number
    config?: JsonWithAggregatesFilter<"ActionDefinition">
    stepId?: StringNullableWithAggregatesFilter<"ActionDefinition"> | string | null
  }

  export type TriggerDefinitionWhereInput = {
    AND?: TriggerDefinitionWhereInput | TriggerDefinitionWhereInput[]
    OR?: TriggerDefinitionWhereInput[]
    NOT?: TriggerDefinitionWhereInput | TriggerDefinitionWhereInput[]
    id?: StringFilter<"TriggerDefinition"> | string
    order?: IntFilter<"TriggerDefinition"> | number
    isPublic?: BoolFilter<"TriggerDefinition"> | boolean
    createdBy?: StringFilter<"TriggerDefinition"> | string
    triggerCode?: StringFilter<"TriggerDefinition"> | string
    executeWhen?: EnumTriggerEventCodeNullableFilter<"TriggerDefinition"> | $Enums.TriggerEventCode | null
    executeAt?: StringNullableFilter<"TriggerDefinition"> | string | null
    combinator?: EnumCombinatorEnumNullableFilter<"TriggerDefinition"> | $Enums.CombinatorEnum | null
    config?: JsonFilter<"TriggerDefinition">
    expiration?: StringNullableFilter<"TriggerDefinition"> | string | null
    stepId?: StringNullableFilter<"TriggerDefinition"> | string | null
    conditions?: ConditionalListRelationFilter
    step?: XOR<ProcessStepNullableScalarRelationFilter, ProcessStepWhereInput> | null
  }

  export type TriggerDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    order?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    triggerCode?: SortOrder
    executeWhen?: SortOrderInput | SortOrder
    executeAt?: SortOrderInput | SortOrder
    combinator?: SortOrderInput | SortOrder
    config?: SortOrder
    expiration?: SortOrderInput | SortOrder
    stepId?: SortOrderInput | SortOrder
    conditions?: ConditionalOrderByRelationAggregateInput
    step?: ProcessStepOrderByWithRelationInput
  }

  export type TriggerDefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TriggerDefinitionWhereInput | TriggerDefinitionWhereInput[]
    OR?: TriggerDefinitionWhereInput[]
    NOT?: TriggerDefinitionWhereInput | TriggerDefinitionWhereInput[]
    order?: IntFilter<"TriggerDefinition"> | number
    isPublic?: BoolFilter<"TriggerDefinition"> | boolean
    createdBy?: StringFilter<"TriggerDefinition"> | string
    triggerCode?: StringFilter<"TriggerDefinition"> | string
    executeWhen?: EnumTriggerEventCodeNullableFilter<"TriggerDefinition"> | $Enums.TriggerEventCode | null
    executeAt?: StringNullableFilter<"TriggerDefinition"> | string | null
    combinator?: EnumCombinatorEnumNullableFilter<"TriggerDefinition"> | $Enums.CombinatorEnum | null
    config?: JsonFilter<"TriggerDefinition">
    expiration?: StringNullableFilter<"TriggerDefinition"> | string | null
    stepId?: StringNullableFilter<"TriggerDefinition"> | string | null
    conditions?: ConditionalListRelationFilter
    step?: XOR<ProcessStepNullableScalarRelationFilter, ProcessStepWhereInput> | null
  }, "id">

  export type TriggerDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    order?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    triggerCode?: SortOrder
    executeWhen?: SortOrderInput | SortOrder
    executeAt?: SortOrderInput | SortOrder
    combinator?: SortOrderInput | SortOrder
    config?: SortOrder
    expiration?: SortOrderInput | SortOrder
    stepId?: SortOrderInput | SortOrder
    _count?: TriggerDefinitionCountOrderByAggregateInput
    _avg?: TriggerDefinitionAvgOrderByAggregateInput
    _max?: TriggerDefinitionMaxOrderByAggregateInput
    _min?: TriggerDefinitionMinOrderByAggregateInput
    _sum?: TriggerDefinitionSumOrderByAggregateInput
  }

  export type TriggerDefinitionScalarWhereWithAggregatesInput = {
    AND?: TriggerDefinitionScalarWhereWithAggregatesInput | TriggerDefinitionScalarWhereWithAggregatesInput[]
    OR?: TriggerDefinitionScalarWhereWithAggregatesInput[]
    NOT?: TriggerDefinitionScalarWhereWithAggregatesInput | TriggerDefinitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TriggerDefinition"> | string
    order?: IntWithAggregatesFilter<"TriggerDefinition"> | number
    isPublic?: BoolWithAggregatesFilter<"TriggerDefinition"> | boolean
    createdBy?: StringWithAggregatesFilter<"TriggerDefinition"> | string
    triggerCode?: StringWithAggregatesFilter<"TriggerDefinition"> | string
    executeWhen?: EnumTriggerEventCodeNullableWithAggregatesFilter<"TriggerDefinition"> | $Enums.TriggerEventCode | null
    executeAt?: StringNullableWithAggregatesFilter<"TriggerDefinition"> | string | null
    combinator?: EnumCombinatorEnumNullableWithAggregatesFilter<"TriggerDefinition"> | $Enums.CombinatorEnum | null
    config?: JsonWithAggregatesFilter<"TriggerDefinition">
    expiration?: StringNullableWithAggregatesFilter<"TriggerDefinition"> | string | null
    stepId?: StringNullableWithAggregatesFilter<"TriggerDefinition"> | string | null
  }

  export type ConditionalWhereInput = {
    AND?: ConditionalWhereInput | ConditionalWhereInput[]
    OR?: ConditionalWhereInput[]
    NOT?: ConditionalWhereInput | ConditionalWhereInput[]
    id?: StringFilter<"Conditional"> | string
    triggerId?: StringFilter<"Conditional"> | string
    fieldKey?: StringFilter<"Conditional"> | string
    fieldKeyLabel?: StringFilter<"Conditional"> | string
    operator?: EnumComparisonOperatorEnumFilter<"Conditional"> | $Enums.ComparisonOperatorEnum
    comparisonValue?: StringFilter<"Conditional"> | string
    combinator?: EnumCombinatorEnumNullableFilter<"Conditional"> | $Enums.CombinatorEnum | null
    trigger?: XOR<TriggerDefinitionScalarRelationFilter, TriggerDefinitionWhereInput>
  }

  export type ConditionalOrderByWithRelationInput = {
    id?: SortOrder
    triggerId?: SortOrder
    fieldKey?: SortOrder
    fieldKeyLabel?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    combinator?: SortOrderInput | SortOrder
    trigger?: TriggerDefinitionOrderByWithRelationInput
  }

  export type ConditionalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConditionalWhereInput | ConditionalWhereInput[]
    OR?: ConditionalWhereInput[]
    NOT?: ConditionalWhereInput | ConditionalWhereInput[]
    triggerId?: StringFilter<"Conditional"> | string
    fieldKey?: StringFilter<"Conditional"> | string
    fieldKeyLabel?: StringFilter<"Conditional"> | string
    operator?: EnumComparisonOperatorEnumFilter<"Conditional"> | $Enums.ComparisonOperatorEnum
    comparisonValue?: StringFilter<"Conditional"> | string
    combinator?: EnumCombinatorEnumNullableFilter<"Conditional"> | $Enums.CombinatorEnum | null
    trigger?: XOR<TriggerDefinitionScalarRelationFilter, TriggerDefinitionWhereInput>
  }, "id">

  export type ConditionalOrderByWithAggregationInput = {
    id?: SortOrder
    triggerId?: SortOrder
    fieldKey?: SortOrder
    fieldKeyLabel?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    combinator?: SortOrderInput | SortOrder
    _count?: ConditionalCountOrderByAggregateInput
    _max?: ConditionalMaxOrderByAggregateInput
    _min?: ConditionalMinOrderByAggregateInput
  }

  export type ConditionalScalarWhereWithAggregatesInput = {
    AND?: ConditionalScalarWhereWithAggregatesInput | ConditionalScalarWhereWithAggregatesInput[]
    OR?: ConditionalScalarWhereWithAggregatesInput[]
    NOT?: ConditionalScalarWhereWithAggregatesInput | ConditionalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conditional"> | string
    triggerId?: StringWithAggregatesFilter<"Conditional"> | string
    fieldKey?: StringWithAggregatesFilter<"Conditional"> | string
    fieldKeyLabel?: StringWithAggregatesFilter<"Conditional"> | string
    operator?: EnumComparisonOperatorEnumWithAggregatesFilter<"Conditional"> | $Enums.ComparisonOperatorEnum
    comparisonValue?: StringWithAggregatesFilter<"Conditional"> | string
    combinator?: EnumCombinatorEnumNullableWithAggregatesFilter<"Conditional"> | $Enums.CombinatorEnum | null
  }

  export type TodoWhereInput = {
    AND?: TodoWhereInput | TodoWhereInput[]
    OR?: TodoWhereInput[]
    NOT?: TodoWhereInput | TodoWhereInput[]
    id?: StringFilter<"Todo"> | string
    userId?: StringFilter<"Todo"> | string
    title?: StringFilter<"Todo"> | string
    dueDate?: DateTimeFilter<"Todo"> | Date | string
    completed?: BoolFilter<"Todo"> | boolean
    completedAt?: DateTimeNullableFilter<"Todo"> | Date | string | null
    createdAt?: DateTimeFilter<"Todo"> | Date | string
    updatedAt?: DateTimeFilter<"Todo"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: TodoItemListRelationFilter
    userProcesses?: TodoUserProcessListRelationFilter
  }

  export type TodoOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    items?: TodoItemOrderByRelationAggregateInput
    userProcesses?: TodoUserProcessOrderByRelationAggregateInput
  }

  export type TodoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TodoWhereInput | TodoWhereInput[]
    OR?: TodoWhereInput[]
    NOT?: TodoWhereInput | TodoWhereInput[]
    userId?: StringFilter<"Todo"> | string
    title?: StringFilter<"Todo"> | string
    dueDate?: DateTimeFilter<"Todo"> | Date | string
    completed?: BoolFilter<"Todo"> | boolean
    completedAt?: DateTimeNullableFilter<"Todo"> | Date | string | null
    createdAt?: DateTimeFilter<"Todo"> | Date | string
    updatedAt?: DateTimeFilter<"Todo"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: TodoItemListRelationFilter
    userProcesses?: TodoUserProcessListRelationFilter
  }, "id">

  export type TodoOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TodoCountOrderByAggregateInput
    _max?: TodoMaxOrderByAggregateInput
    _min?: TodoMinOrderByAggregateInput
  }

  export type TodoScalarWhereWithAggregatesInput = {
    AND?: TodoScalarWhereWithAggregatesInput | TodoScalarWhereWithAggregatesInput[]
    OR?: TodoScalarWhereWithAggregatesInput[]
    NOT?: TodoScalarWhereWithAggregatesInput | TodoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Todo"> | string
    userId?: StringWithAggregatesFilter<"Todo"> | string
    title?: StringWithAggregatesFilter<"Todo"> | string
    dueDate?: DateTimeWithAggregatesFilter<"Todo"> | Date | string
    completed?: BoolWithAggregatesFilter<"Todo"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"Todo"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Todo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Todo"> | Date | string
  }

  export type TodoItemWhereInput = {
    AND?: TodoItemWhereInput | TodoItemWhereInput[]
    OR?: TodoItemWhereInput[]
    NOT?: TodoItemWhereInput | TodoItemWhereInput[]
    id?: StringFilter<"TodoItem"> | string
    todoId?: StringFilter<"TodoItem"> | string
    type?: EnumTodoItemTypeEnumFilter<"TodoItem"> | $Enums.TodoItemTypeEnum
    content?: StringFilter<"TodoItem"> | string
    order?: IntFilter<"TodoItem"> | number
    todo?: XOR<TodoScalarRelationFilter, TodoWhereInput>
  }

  export type TodoItemOrderByWithRelationInput = {
    id?: SortOrder
    todoId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    todo?: TodoOrderByWithRelationInput
  }

  export type TodoItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TodoItemWhereInput | TodoItemWhereInput[]
    OR?: TodoItemWhereInput[]
    NOT?: TodoItemWhereInput | TodoItemWhereInput[]
    todoId?: StringFilter<"TodoItem"> | string
    type?: EnumTodoItemTypeEnumFilter<"TodoItem"> | $Enums.TodoItemTypeEnum
    content?: StringFilter<"TodoItem"> | string
    order?: IntFilter<"TodoItem"> | number
    todo?: XOR<TodoScalarRelationFilter, TodoWhereInput>
  }, "id">

  export type TodoItemOrderByWithAggregationInput = {
    id?: SortOrder
    todoId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    _count?: TodoItemCountOrderByAggregateInput
    _avg?: TodoItemAvgOrderByAggregateInput
    _max?: TodoItemMaxOrderByAggregateInput
    _min?: TodoItemMinOrderByAggregateInput
    _sum?: TodoItemSumOrderByAggregateInput
  }

  export type TodoItemScalarWhereWithAggregatesInput = {
    AND?: TodoItemScalarWhereWithAggregatesInput | TodoItemScalarWhereWithAggregatesInput[]
    OR?: TodoItemScalarWhereWithAggregatesInput[]
    NOT?: TodoItemScalarWhereWithAggregatesInput | TodoItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TodoItem"> | string
    todoId?: StringWithAggregatesFilter<"TodoItem"> | string
    type?: EnumTodoItemTypeEnumWithAggregatesFilter<"TodoItem"> | $Enums.TodoItemTypeEnum
    content?: StringWithAggregatesFilter<"TodoItem"> | string
    order?: IntWithAggregatesFilter<"TodoItem"> | number
  }

  export type TodoUserProcessWhereInput = {
    AND?: TodoUserProcessWhereInput | TodoUserProcessWhereInput[]
    OR?: TodoUserProcessWhereInput[]
    NOT?: TodoUserProcessWhereInput | TodoUserProcessWhereInput[]
    id?: StringFilter<"TodoUserProcess"> | string
    todoId?: StringFilter<"TodoUserProcess"> | string
    userProcessId?: StringFilter<"TodoUserProcess"> | string
    todo?: XOR<TodoScalarRelationFilter, TodoWhereInput>
    userProcess?: XOR<UserProcessScalarRelationFilter, UserProcessWhereInput>
  }

  export type TodoUserProcessOrderByWithRelationInput = {
    id?: SortOrder
    todoId?: SortOrder
    userProcessId?: SortOrder
    todo?: TodoOrderByWithRelationInput
    userProcess?: UserProcessOrderByWithRelationInput
  }

  export type TodoUserProcessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    todoId_userProcessId?: TodoUserProcessTodoIdUserProcessIdCompoundUniqueInput
    AND?: TodoUserProcessWhereInput | TodoUserProcessWhereInput[]
    OR?: TodoUserProcessWhereInput[]
    NOT?: TodoUserProcessWhereInput | TodoUserProcessWhereInput[]
    todoId?: StringFilter<"TodoUserProcess"> | string
    userProcessId?: StringFilter<"TodoUserProcess"> | string
    todo?: XOR<TodoScalarRelationFilter, TodoWhereInput>
    userProcess?: XOR<UserProcessScalarRelationFilter, UserProcessWhereInput>
  }, "id" | "todoId_userProcessId">

  export type TodoUserProcessOrderByWithAggregationInput = {
    id?: SortOrder
    todoId?: SortOrder
    userProcessId?: SortOrder
    _count?: TodoUserProcessCountOrderByAggregateInput
    _max?: TodoUserProcessMaxOrderByAggregateInput
    _min?: TodoUserProcessMinOrderByAggregateInput
  }

  export type TodoUserProcessScalarWhereWithAggregatesInput = {
    AND?: TodoUserProcessScalarWhereWithAggregatesInput | TodoUserProcessScalarWhereWithAggregatesInput[]
    OR?: TodoUserProcessScalarWhereWithAggregatesInput[]
    NOT?: TodoUserProcessScalarWhereWithAggregatesInput | TodoUserProcessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TodoUserProcess"> | string
    todoId?: StringWithAggregatesFilter<"TodoUserProcess"> | string
    userProcessId?: StringWithAggregatesFilter<"TodoUserProcess"> | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    providers?: ProviderCreateNestedManyWithoutUserInput
    applications?: JobApplicantsCreateNestedManyWithoutUserInput
    userProcess?: UserProcessCreateNestedManyWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    createdJobPostings?: CreatedJobPostingCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepCreateNestedManyWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    companyId?: string | null
    providers?: ProviderUncheckedCreateNestedManyWithoutUserInput
    applications?: JobApplicantsUncheckedCreateNestedManyWithoutUserInput
    userProcess?: UserProcessUncheckedCreateNestedManyWithoutUserInput
    createdJobPostings?: CreatedJobPostingUncheckedCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutUserInput
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    createdJobPostings?: CreatedJobPostingUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUpdateManyWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUncheckedUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUncheckedUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUncheckedUpdateManyWithoutUserNestedInput
    createdJobPostings?: CreatedJobPostingUncheckedUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutUserNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    companyId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProviderCreateInput = {
    id?: string
    provider: $Enums.ProviderEnum
    providerAccountId: string
    token?: TokenCreateNestedOneWithoutProviderInput
    user: UserCreateNestedOneWithoutProvidersInput
  }

  export type ProviderUncheckedCreateInput = {
    id?: string
    userId: string
    provider: $Enums.ProviderEnum
    providerAccountId: string
    token?: TokenUncheckedCreateNestedOneWithoutProviderInput
  }

  export type ProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderEnumFieldUpdateOperationsInput | $Enums.ProviderEnum
    providerAccountId?: StringFieldUpdateOperationsInput | string
    token?: TokenUpdateOneWithoutProviderNestedInput
    user?: UserUpdateOneRequiredWithoutProvidersNestedInput
  }

  export type ProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderEnumFieldUpdateOperationsInput | $Enums.ProviderEnum
    providerAccountId?: StringFieldUpdateOperationsInput | string
    token?: TokenUncheckedUpdateOneWithoutProviderNestedInput
  }

  export type ProviderCreateManyInput = {
    id?: string
    userId: string
    provider: $Enums.ProviderEnum
    providerAccountId: string
  }

  export type ProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderEnumFieldUpdateOperationsInput | $Enums.ProviderEnum
    providerAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderEnumFieldUpdateOperationsInput | $Enums.ProviderEnum
    providerAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenCreateInput = {
    id?: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    provider: ProviderCreateNestedOneWithoutTokenInput
  }

  export type TokenUncheckedCreateInput = {
    id?: string
    providerId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type TokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: ProviderUpdateOneRequiredWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TokenCreateManyInput = {
    id?: string
    providerId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type TokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    logo?: string | null
    users?: UserCreateNestedManyWithoutCompanyInput
    jobPostings?: JobPostingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    logo?: string | null
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    jobPostings?: JobPostingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutCompanyNestedInput
    jobPostings?: JobPostingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    jobPostings?: JobPostingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    logo?: string | null
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobPostingCreateInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    language?: JobPostingLanguageCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingCreateNestedOneWithoutJobPostingInput
    company?: CompanyCreateNestedOneWithoutJobPostingsInput
    userJobApplications?: JobApplicantsCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingUncheckedCreateInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    companyId?: string | null
    language?: JobPostingLanguageUncheckedCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementUncheckedCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritUncheckedCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityUncheckedCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationUncheckedCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentUncheckedCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeUncheckedCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryUncheckedCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingUncheckedCreateNestedOneWithoutJobPostingInput
    userJobApplications?: JobApplicantsUncheckedCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessUncheckedCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    language?: JobPostingLanguageUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUpdateOneWithoutJobPostingNestedInput
    company?: CompanyUpdateOneWithoutJobPostingsNestedInput
    userJobApplications?: JobApplicantsUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    language?: JobPostingLanguageUncheckedUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUncheckedUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUncheckedUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUncheckedUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUncheckedUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUncheckedUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUncheckedUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUncheckedUpdateOneWithoutJobPostingNestedInput
    userJobApplications?: JobApplicantsUncheckedUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUncheckedUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingCreateManyInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    companyId?: string | null
  }

  export type JobPostingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobPostingLanguageCreateInput = {
    id?: string
    language: string
    level?: string | null
    jobPosting: JobPostingCreateNestedOneWithoutLanguageInput
  }

  export type JobPostingLanguageUncheckedCreateInput = {
    id?: string
    jobPostingId: string
    language: string
    level?: string | null
  }

  export type JobPostingLanguageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosting?: JobPostingUpdateOneRequiredWithoutLanguageNestedInput
  }

  export type JobPostingLanguageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobPostingLanguageCreateManyInput = {
    id?: string
    jobPostingId: string
    language: string
    level?: string | null
  }

  export type JobPostingLanguageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobPostingLanguageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobPostingRequirementCreateInput = {
    id?: string
    requirement: string
    jobPosting: JobPostingCreateNestedOneWithoutJobRequirementsInput
  }

  export type JobPostingRequirementUncheckedCreateInput = {
    id?: string
    jobPostingId: string
    requirement: string
  }

  export type JobPostingRequirementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirement?: StringFieldUpdateOperationsInput | string
    jobPosting?: JobPostingUpdateOneRequiredWithoutJobRequirementsNestedInput
  }

  export type JobPostingRequirementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    requirement?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingRequirementCreateManyInput = {
    id?: string
    jobPostingId: string
    requirement: string
  }

  export type JobPostingRequirementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirement?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingRequirementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    requirement?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingMeritCreateInput = {
    id?: string
    merit: string
    jobPosting: JobPostingCreateNestedOneWithoutMeritsInput
  }

  export type JobPostingMeritUncheckedCreateInput = {
    id?: string
    jobPostingId: string
    merit: string
  }

  export type JobPostingMeritUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merit?: StringFieldUpdateOperationsInput | string
    jobPosting?: JobPostingUpdateOneRequiredWithoutMeritsNestedInput
  }

  export type JobPostingMeritUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    merit?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingMeritCreateManyInput = {
    id?: string
    jobPostingId: string
    merit: string
  }

  export type JobPostingMeritUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    merit?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingMeritUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    merit?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingApplicantQualityCreateInput = {
    id?: string
    quality: string
    jobPosting: JobPostingCreateNestedOneWithoutApplicantQualitiesInput
  }

  export type JobPostingApplicantQualityUncheckedCreateInput = {
    id?: string
    jobPostingId: string
    quality: string
  }

  export type JobPostingApplicantQualityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    jobPosting?: JobPostingUpdateOneRequiredWithoutApplicantQualitiesNestedInput
  }

  export type JobPostingApplicantQualityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingApplicantQualityCreateManyInput = {
    id?: string
    jobPostingId: string
    quality: string
  }

  export type JobPostingApplicantQualityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingApplicantQualityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingLocationCreateInput = {
    id?: string
    city?: string | null
    region?: string | null
    country?: string
    isRemote?: boolean
    lat?: number | null
    lng?: number | null
    jobPosting: JobPostingCreateNestedOneWithoutLocationInput
  }

  export type JobPostingLocationUncheckedCreateInput = {
    id?: string
    jobPostingId: string
    city?: string | null
    region?: string | null
    country?: string
    isRemote?: boolean
    lat?: number | null
    lng?: number | null
  }

  export type JobPostingLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    jobPosting?: JobPostingUpdateOneRequiredWithoutLocationNestedInput
  }

  export type JobPostingLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type JobPostingLocationCreateManyInput = {
    id?: string
    jobPostingId: string
    city?: string | null
    region?: string | null
    country?: string
    isRemote?: boolean
    lat?: number | null
    lng?: number | null
  }

  export type JobPostingLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type JobPostingLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type JobPostingWorkArrengmentCreateInput = {
    id?: string
    mode: string
    jobPosting: JobPostingCreateNestedOneWithoutWorkArrengmentInput
  }

  export type JobPostingWorkArrengmentUncheckedCreateInput = {
    id?: string
    jobPostingId: string
    mode: string
  }

  export type JobPostingWorkArrengmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    jobPosting?: JobPostingUpdateOneRequiredWithoutWorkArrengmentNestedInput
  }

  export type JobPostingWorkArrengmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingWorkArrengmentCreateManyInput = {
    id?: string
    jobPostingId: string
    mode: string
  }

  export type JobPostingWorkArrengmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingWorkArrengmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingEmploymentTypeCreateInput = {
    id?: string
    type: string
    jobPosting: JobPostingCreateNestedOneWithoutEmploymentTypeInput
  }

  export type JobPostingEmploymentTypeUncheckedCreateInput = {
    id?: string
    jobPostingId: string
    type: string
  }

  export type JobPostingEmploymentTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    jobPosting?: JobPostingUpdateOneRequiredWithoutEmploymentTypeNestedInput
  }

  export type JobPostingEmploymentTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingEmploymentTypeCreateManyInput = {
    id?: string
    jobPostingId: string
    type: string
  }

  export type JobPostingEmploymentTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingEmploymentTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingSalaryCreateInput = {
    id?: string
    type: string
    amount?: string | null
    currency?: string
    period?: string
    benefits?: JobPostingSalaryCreatebenefitsInput | string[]
    notes?: string | null
    jobPosting: JobPostingCreateNestedOneWithoutSalaryInput
  }

  export type JobPostingSalaryUncheckedCreateInput = {
    id?: string
    jobPostingId: string
    type: string
    amount?: string | null
    currency?: string
    period?: string
    benefits?: JobPostingSalaryCreatebenefitsInput | string[]
    notes?: string | null
  }

  export type JobPostingSalaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    benefits?: JobPostingSalaryUpdatebenefitsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosting?: JobPostingUpdateOneRequiredWithoutSalaryNestedInput
  }

  export type JobPostingSalaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    benefits?: JobPostingSalaryUpdatebenefitsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobPostingSalaryCreateManyInput = {
    id?: string
    jobPostingId: string
    type: string
    amount?: string | null
    currency?: string
    period?: string
    benefits?: JobPostingSalaryCreatebenefitsInput | string[]
    notes?: string | null
  }

  export type JobPostingSalaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    benefits?: JobPostingSalaryUpdatebenefitsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobPostingSalaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    benefits?: JobPostingSalaryUpdatebenefitsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatedJobPostingCreateInput = {
    id?: string
    createdByType: $Enums.CreatedByEnum
    source?: $Enums.JobSourceEnum | null
    importedAt?: Date | string | null
    jobPosting: JobPostingCreateNestedOneWithoutCreatedJobPostingInput
    createdBy?: UserCreateNestedOneWithoutCreatedJobPostingsInput
  }

  export type CreatedJobPostingUncheckedCreateInput = {
    id?: string
    jobPostingId: string
    createdByType: $Enums.CreatedByEnum
    createdById?: string | null
    source?: $Enums.JobSourceEnum | null
    importedAt?: Date | string | null
  }

  export type CreatedJobPostingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByType?: EnumCreatedByEnumFieldUpdateOperationsInput | $Enums.CreatedByEnum
    source?: NullableEnumJobSourceEnumFieldUpdateOperationsInput | $Enums.JobSourceEnum | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobPosting?: JobPostingUpdateOneRequiredWithoutCreatedJobPostingNestedInput
    createdBy?: UserUpdateOneWithoutCreatedJobPostingsNestedInput
  }

  export type CreatedJobPostingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    createdByType?: EnumCreatedByEnumFieldUpdateOperationsInput | $Enums.CreatedByEnum
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableEnumJobSourceEnumFieldUpdateOperationsInput | $Enums.JobSourceEnum | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CreatedJobPostingCreateManyInput = {
    id?: string
    jobPostingId: string
    createdByType: $Enums.CreatedByEnum
    createdById?: string | null
    source?: $Enums.JobSourceEnum | null
    importedAt?: Date | string | null
  }

  export type CreatedJobPostingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByType?: EnumCreatedByEnumFieldUpdateOperationsInput | $Enums.CreatedByEnum
    source?: NullableEnumJobSourceEnumFieldUpdateOperationsInput | $Enums.JobSourceEnum | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CreatedJobPostingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    createdByType?: EnumCreatedByEnumFieldUpdateOperationsInput | $Enums.CreatedByEnum
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableEnumJobSourceEnumFieldUpdateOperationsInput | $Enums.JobSourceEnum | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobApplicantsCreateInput = {
    id?: string
    status?: string
    appliedAt: string
    gotJob?: boolean
    user: UserCreateNestedOneWithoutApplicationsInput
    jobPosting: JobPostingCreateNestedOneWithoutUserJobApplicationsInput
  }

  export type JobApplicantsUncheckedCreateInput = {
    id?: string
    userId: string
    jobPostingId: string
    status?: string
    appliedAt: string
    gotJob?: boolean
  }

  export type JobApplicantsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    appliedAt?: StringFieldUpdateOperationsInput | string
    gotJob?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutApplicationsNestedInput
    jobPosting?: JobPostingUpdateOneRequiredWithoutUserJobApplicationsNestedInput
  }

  export type JobApplicantsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    appliedAt?: StringFieldUpdateOperationsInput | string
    gotJob?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobApplicantsCreateManyInput = {
    id?: string
    userId: string
    jobPostingId: string
    status?: string
    appliedAt: string
    gotJob?: boolean
  }

  export type JobApplicantsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    appliedAt?: StringFieldUpdateOperationsInput | string
    gotJob?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobApplicantsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    appliedAt?: StringFieldUpdateOperationsInput | string
    gotJob?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserProcessCreateInput = {
    id?: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    user: UserCreateNestedOneWithoutUserProcessInput
    steps?: UserProcessStepCreateNestedManyWithoutProcessInput
    jobPosting?: JobPostingCreateNestedOneWithoutUserProcessesInput
    process?: ProcessCreateNestedOneWithoutProcessesInput
    todos?: TodoUserProcessCreateNestedManyWithoutUserProcessInput
  }

  export type UserProcessUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    jobPostingId: string
    processId?: string | null
    steps?: UserProcessStepUncheckedCreateNestedManyWithoutProcessInput
    todos?: TodoUserProcessUncheckedCreateNestedManyWithoutUserProcessInput
  }

  export type UserProcessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserProcessNestedInput
    steps?: UserProcessStepUpdateManyWithoutProcessNestedInput
    jobPosting?: JobPostingUpdateOneWithoutUserProcessesNestedInput
    process?: ProcessUpdateOneWithoutProcessesNestedInput
    todos?: TodoUserProcessUpdateManyWithoutUserProcessNestedInput
  }

  export type UserProcessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingId?: StringFieldUpdateOperationsInput | string
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: UserProcessStepUncheckedUpdateManyWithoutProcessNestedInput
    todos?: TodoUserProcessUncheckedUpdateManyWithoutUserProcessNestedInput
  }

  export type UserProcessCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    jobPostingId: string
    processId?: string | null
  }

  export type UserProcessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProcessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingId?: StringFieldUpdateOperationsInput | string
    processId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProcessStepCreateInput = {
    id?: string
    isExecuted?: boolean
    executedAt?: string | null
    comments?: UserPipelineStepCommentCreateNestedManyWithoutStepInput
    process: UserProcessCreateNestedOneWithoutStepsInput
    step?: ProcessStepCreateNestedOneWithoutUserProcessStepsInput
  }

  export type UserProcessStepUncheckedCreateInput = {
    id?: string
    userProcessId: string
    stepId?: string | null
    isExecuted?: boolean
    executedAt?: string | null
    comments?: UserPipelineStepCommentUncheckedCreateNestedManyWithoutStepInput
  }

  export type UserProcessStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    executedAt?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: UserPipelineStepCommentUpdateManyWithoutStepNestedInput
    process?: UserProcessUpdateOneRequiredWithoutStepsNestedInput
    step?: ProcessStepUpdateOneWithoutUserProcessStepsNestedInput
  }

  export type UserProcessStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProcessId?: StringFieldUpdateOperationsInput | string
    stepId?: NullableStringFieldUpdateOperationsInput | string | null
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    executedAt?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: UserPipelineStepCommentUncheckedUpdateManyWithoutStepNestedInput
  }

  export type UserProcessStepCreateManyInput = {
    id?: string
    userProcessId: string
    stepId?: string | null
    isExecuted?: boolean
    executedAt?: string | null
  }

  export type UserProcessStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    executedAt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProcessStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProcessId?: StringFieldUpdateOperationsInput | string
    stepId?: NullableStringFieldUpdateOperationsInput | string | null
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    executedAt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPipelineStepCommentCreateInput = {
    id?: string
    comment: string
    createdAt: string
    user: UserCreateNestedOneWithoutUserPipelineStepCommentsInput
    step: UserProcessStepCreateNestedOneWithoutCommentsInput
  }

  export type UserPipelineStepCommentUncheckedCreateInput = {
    id?: string
    userPipelineStepId: string
    userId: string
    comment: string
    createdAt: string
  }

  export type UserPipelineStepCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserPipelineStepCommentsNestedInput
    step?: UserProcessStepUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type UserPipelineStepCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userPipelineStepId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
  }

  export type UserPipelineStepCommentCreateManyInput = {
    id?: string
    userPipelineStepId: string
    userId: string
    comment: string
    createdAt: string
  }

  export type UserPipelineStepCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
  }

  export type UserPipelineStepCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userPipelineStepId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessCreateInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    isTemplate: boolean
    isPublic?: boolean
    user?: UserCreateNestedOneWithoutProcessesInput
    steps?: ProcessStepCreateNestedManyWithoutProcessInput
    processes?: UserProcessCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    ownerId?: string | null
    isTemplate: boolean
    isPublic?: boolean
    steps?: ProcessStepUncheckedCreateNestedManyWithoutProcessInput
    processes?: UserProcessUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutProcessesNestedInput
    steps?: ProcessStepUpdateManyWithoutProcessNestedInput
    processes?: UserProcessUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    steps?: ProcessStepUncheckedUpdateManyWithoutProcessNestedInput
    processes?: UserProcessUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProcessCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    ownerId?: string | null
    isTemplate: boolean
    isPublic?: boolean
  }

  export type ProcessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProcessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProcessStepCreateInput = {
    id?: string
    title: string
    description: string
    icon?: string | null
    order: number
    process: ProcessCreateNestedOneWithoutStepsInput
    triggers?: TriggerDefinitionCreateNestedManyWithoutStepInput
    actions?: ActionDefinitionCreateNestedManyWithoutStepInput
    user?: UserCreateNestedOneWithoutProcessStepsInput
    userProcessSteps?: UserProcessStepCreateNestedManyWithoutStepInput
  }

  export type ProcessStepUncheckedCreateInput = {
    id?: string
    processId: string
    title: string
    description: string
    icon?: string | null
    order: number
    userId?: string | null
    triggers?: TriggerDefinitionUncheckedCreateNestedManyWithoutStepInput
    actions?: ActionDefinitionUncheckedCreateNestedManyWithoutStepInput
    userProcessSteps?: UserProcessStepUncheckedCreateNestedManyWithoutStepInput
  }

  export type ProcessStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    process?: ProcessUpdateOneRequiredWithoutStepsNestedInput
    triggers?: TriggerDefinitionUpdateManyWithoutStepNestedInput
    actions?: ActionDefinitionUpdateManyWithoutStepNestedInput
    user?: UserUpdateOneWithoutProcessStepsNestedInput
    userProcessSteps?: UserProcessStepUpdateManyWithoutStepNestedInput
  }

  export type ProcessStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: TriggerDefinitionUncheckedUpdateManyWithoutStepNestedInput
    actions?: ActionDefinitionUncheckedUpdateManyWithoutStepNestedInput
    userProcessSteps?: UserProcessStepUncheckedUpdateManyWithoutStepNestedInput
  }

  export type ProcessStepCreateManyInput = {
    id?: string
    processId: string
    title: string
    description: string
    icon?: string | null
    order: number
    userId?: string | null
  }

  export type ProcessStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActionDefinitionCreateInput = {
    id?: string
    name: string
    isPublic?: boolean
    order: number
    config: JsonNullValueInput | InputJsonValue
    step?: ProcessStepCreateNestedOneWithoutActionsInput
  }

  export type ActionDefinitionUncheckedCreateInput = {
    id?: string
    name: string
    isPublic?: boolean
    order: number
    config: JsonNullValueInput | InputJsonValue
    stepId?: string | null
  }

  export type ActionDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    config?: JsonNullValueInput | InputJsonValue
    step?: ProcessStepUpdateOneWithoutActionsNestedInput
  }

  export type ActionDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    config?: JsonNullValueInput | InputJsonValue
    stepId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActionDefinitionCreateManyInput = {
    id?: string
    name: string
    isPublic?: boolean
    order: number
    config: JsonNullValueInput | InputJsonValue
    stepId?: string | null
  }

  export type ActionDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    config?: JsonNullValueInput | InputJsonValue
  }

  export type ActionDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    config?: JsonNullValueInput | InputJsonValue
    stepId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TriggerDefinitionCreateInput = {
    id?: string
    order: number
    isPublic?: boolean
    createdBy: string
    triggerCode: string
    executeWhen?: $Enums.TriggerEventCode | null
    executeAt?: string | null
    combinator?: $Enums.CombinatorEnum | null
    config: JsonNullValueInput | InputJsonValue
    expiration?: string | null
    conditions?: ConditionalCreateNestedManyWithoutTriggerInput
    step?: ProcessStepCreateNestedOneWithoutTriggersInput
  }

  export type TriggerDefinitionUncheckedCreateInput = {
    id?: string
    order: number
    isPublic?: boolean
    createdBy: string
    triggerCode: string
    executeWhen?: $Enums.TriggerEventCode | null
    executeAt?: string | null
    combinator?: $Enums.CombinatorEnum | null
    config: JsonNullValueInput | InputJsonValue
    expiration?: string | null
    stepId?: string | null
    conditions?: ConditionalUncheckedCreateNestedManyWithoutTriggerInput
  }

  export type TriggerDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    triggerCode?: StringFieldUpdateOperationsInput | string
    executeWhen?: NullableEnumTriggerEventCodeFieldUpdateOperationsInput | $Enums.TriggerEventCode | null
    executeAt?: NullableStringFieldUpdateOperationsInput | string | null
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
    config?: JsonNullValueInput | InputJsonValue
    expiration?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: ConditionalUpdateManyWithoutTriggerNestedInput
    step?: ProcessStepUpdateOneWithoutTriggersNestedInput
  }

  export type TriggerDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    triggerCode?: StringFieldUpdateOperationsInput | string
    executeWhen?: NullableEnumTriggerEventCodeFieldUpdateOperationsInput | $Enums.TriggerEventCode | null
    executeAt?: NullableStringFieldUpdateOperationsInput | string | null
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
    config?: JsonNullValueInput | InputJsonValue
    expiration?: NullableStringFieldUpdateOperationsInput | string | null
    stepId?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: ConditionalUncheckedUpdateManyWithoutTriggerNestedInput
  }

  export type TriggerDefinitionCreateManyInput = {
    id?: string
    order: number
    isPublic?: boolean
    createdBy: string
    triggerCode: string
    executeWhen?: $Enums.TriggerEventCode | null
    executeAt?: string | null
    combinator?: $Enums.CombinatorEnum | null
    config: JsonNullValueInput | InputJsonValue
    expiration?: string | null
    stepId?: string | null
  }

  export type TriggerDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    triggerCode?: StringFieldUpdateOperationsInput | string
    executeWhen?: NullableEnumTriggerEventCodeFieldUpdateOperationsInput | $Enums.TriggerEventCode | null
    executeAt?: NullableStringFieldUpdateOperationsInput | string | null
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
    config?: JsonNullValueInput | InputJsonValue
    expiration?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TriggerDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    triggerCode?: StringFieldUpdateOperationsInput | string
    executeWhen?: NullableEnumTriggerEventCodeFieldUpdateOperationsInput | $Enums.TriggerEventCode | null
    executeAt?: NullableStringFieldUpdateOperationsInput | string | null
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
    config?: JsonNullValueInput | InputJsonValue
    expiration?: NullableStringFieldUpdateOperationsInput | string | null
    stepId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConditionalCreateInput = {
    id?: string
    fieldKey: string
    fieldKeyLabel: string
    operator: $Enums.ComparisonOperatorEnum
    comparisonValue: string
    combinator?: $Enums.CombinatorEnum | null
    trigger: TriggerDefinitionCreateNestedOneWithoutConditionsInput
  }

  export type ConditionalUncheckedCreateInput = {
    id?: string
    triggerId: string
    fieldKey: string
    fieldKeyLabel: string
    operator: $Enums.ComparisonOperatorEnum
    comparisonValue: string
    combinator?: $Enums.CombinatorEnum | null
  }

  export type ConditionalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldKeyLabel?: StringFieldUpdateOperationsInput | string
    operator?: EnumComparisonOperatorEnumFieldUpdateOperationsInput | $Enums.ComparisonOperatorEnum
    comparisonValue?: StringFieldUpdateOperationsInput | string
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
    trigger?: TriggerDefinitionUpdateOneRequiredWithoutConditionsNestedInput
  }

  export type ConditionalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggerId?: StringFieldUpdateOperationsInput | string
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldKeyLabel?: StringFieldUpdateOperationsInput | string
    operator?: EnumComparisonOperatorEnumFieldUpdateOperationsInput | $Enums.ComparisonOperatorEnum
    comparisonValue?: StringFieldUpdateOperationsInput | string
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
  }

  export type ConditionalCreateManyInput = {
    id?: string
    triggerId: string
    fieldKey: string
    fieldKeyLabel: string
    operator: $Enums.ComparisonOperatorEnum
    comparisonValue: string
    combinator?: $Enums.CombinatorEnum | null
  }

  export type ConditionalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldKeyLabel?: StringFieldUpdateOperationsInput | string
    operator?: EnumComparisonOperatorEnumFieldUpdateOperationsInput | $Enums.ComparisonOperatorEnum
    comparisonValue?: StringFieldUpdateOperationsInput | string
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
  }

  export type ConditionalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    triggerId?: StringFieldUpdateOperationsInput | string
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldKeyLabel?: StringFieldUpdateOperationsInput | string
    operator?: EnumComparisonOperatorEnumFieldUpdateOperationsInput | $Enums.ComparisonOperatorEnum
    comparisonValue?: StringFieldUpdateOperationsInput | string
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
  }

  export type TodoCreateInput = {
    id?: string
    title: string
    dueDate: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTodosInput
    items?: TodoItemCreateNestedManyWithoutTodoInput
    userProcesses?: TodoUserProcessCreateNestedManyWithoutTodoInput
  }

  export type TodoUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    dueDate: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TodoItemUncheckedCreateNestedManyWithoutTodoInput
    userProcesses?: TodoUserProcessUncheckedCreateNestedManyWithoutTodoInput
  }

  export type TodoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTodosNestedInput
    items?: TodoItemUpdateManyWithoutTodoNestedInput
    userProcesses?: TodoUserProcessUpdateManyWithoutTodoNestedInput
  }

  export type TodoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TodoItemUncheckedUpdateManyWithoutTodoNestedInput
    userProcesses?: TodoUserProcessUncheckedUpdateManyWithoutTodoNestedInput
  }

  export type TodoCreateManyInput = {
    id?: string
    userId: string
    title: string
    dueDate: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoItemCreateInput = {
    id?: string
    type: $Enums.TodoItemTypeEnum
    content: string
    order: number
    todo: TodoCreateNestedOneWithoutItemsInput
  }

  export type TodoItemUncheckedCreateInput = {
    id?: string
    todoId: string
    type: $Enums.TodoItemTypeEnum
    content: string
    order: number
  }

  export type TodoItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTodoItemTypeEnumFieldUpdateOperationsInput | $Enums.TodoItemTypeEnum
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    todo?: TodoUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TodoItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    todoId?: StringFieldUpdateOperationsInput | string
    type?: EnumTodoItemTypeEnumFieldUpdateOperationsInput | $Enums.TodoItemTypeEnum
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TodoItemCreateManyInput = {
    id?: string
    todoId: string
    type: $Enums.TodoItemTypeEnum
    content: string
    order: number
  }

  export type TodoItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTodoItemTypeEnumFieldUpdateOperationsInput | $Enums.TodoItemTypeEnum
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TodoItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    todoId?: StringFieldUpdateOperationsInput | string
    type?: EnumTodoItemTypeEnumFieldUpdateOperationsInput | $Enums.TodoItemTypeEnum
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TodoUserProcessCreateInput = {
    id?: string
    todo: TodoCreateNestedOneWithoutUserProcessesInput
    userProcess: UserProcessCreateNestedOneWithoutTodosInput
  }

  export type TodoUserProcessUncheckedCreateInput = {
    id?: string
    todoId: string
    userProcessId: string
  }

  export type TodoUserProcessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    todo?: TodoUpdateOneRequiredWithoutUserProcessesNestedInput
    userProcess?: UserProcessUpdateOneRequiredWithoutTodosNestedInput
  }

  export type TodoUserProcessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    todoId?: StringFieldUpdateOperationsInput | string
    userProcessId?: StringFieldUpdateOperationsInput | string
  }

  export type TodoUserProcessCreateManyInput = {
    id?: string
    todoId: string
    userProcessId: string
  }

  export type TodoUserProcessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TodoUserProcessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    todoId?: StringFieldUpdateOperationsInput | string
    userProcessId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ProviderListRelationFilter = {
    every?: ProviderWhereInput
    some?: ProviderWhereInput
    none?: ProviderWhereInput
  }

  export type JobApplicantsListRelationFilter = {
    every?: JobApplicantsWhereInput
    some?: JobApplicantsWhereInput
    none?: JobApplicantsWhereInput
  }

  export type UserProcessListRelationFilter = {
    every?: UserProcessWhereInput
    some?: UserProcessWhereInput
    none?: UserProcessWhereInput
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type CreatedJobPostingListRelationFilter = {
    every?: CreatedJobPostingWhereInput
    some?: CreatedJobPostingWhereInput
    none?: CreatedJobPostingWhereInput
  }

  export type UserPipelineStepCommentListRelationFilter = {
    every?: UserPipelineStepCommentWhereInput
    some?: UserPipelineStepCommentWhereInput
    none?: UserPipelineStepCommentWhereInput
  }

  export type ProcessStepListRelationFilter = {
    every?: ProcessStepWhereInput
    some?: ProcessStepWhereInput
    none?: ProcessStepWhereInput
  }

  export type ProcessListRelationFilter = {
    every?: ProcessWhereInput
    some?: ProcessWhereInput
    none?: ProcessWhereInput
  }

  export type TodoListRelationFilter = {
    every?: TodoWhereInput
    some?: TodoWhereInput
    none?: TodoWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProviderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobApplicantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProcessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreatedJobPostingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPipelineStepCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TodoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    companyId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    companyId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    companyId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumProviderEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderEnum | EnumProviderEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderEnum[] | ListEnumProviderEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderEnum[] | ListEnumProviderEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderEnumFilter<$PrismaModel> | $Enums.ProviderEnum
  }

  export type TokenNullableScalarRelationFilter = {
    is?: TokenWhereInput | null
    isNot?: TokenWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProviderProviderProviderAccountIdCompoundUniqueInput = {
    provider: $Enums.ProviderEnum
    providerAccountId: string
  }

  export type ProviderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
  }

  export type ProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
  }

  export type ProviderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
  }

  export type EnumProviderEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderEnum | EnumProviderEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderEnum[] | ListEnumProviderEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderEnum[] | ListEnumProviderEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderEnumWithAggregatesFilter<$PrismaModel> | $Enums.ProviderEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderEnumFilter<$PrismaModel>
    _max?: NestedEnumProviderEnumFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProviderScalarRelationFilter = {
    is?: ProviderWhereInput
    isNot?: ProviderWhereInput
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type TokenAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type TokenSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type JobPostingListRelationFilter = {
    every?: JobPostingWhereInput
    some?: JobPostingWhereInput
    none?: JobPostingWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobPostingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
  }

  export type JobPostingLanguageListRelationFilter = {
    every?: JobPostingLanguageWhereInput
    some?: JobPostingLanguageWhereInput
    none?: JobPostingLanguageWhereInput
  }

  export type JobPostingRequirementListRelationFilter = {
    every?: JobPostingRequirementWhereInput
    some?: JobPostingRequirementWhereInput
    none?: JobPostingRequirementWhereInput
  }

  export type JobPostingMeritListRelationFilter = {
    every?: JobPostingMeritWhereInput
    some?: JobPostingMeritWhereInput
    none?: JobPostingMeritWhereInput
  }

  export type JobPostingApplicantQualityListRelationFilter = {
    every?: JobPostingApplicantQualityWhereInput
    some?: JobPostingApplicantQualityWhereInput
    none?: JobPostingApplicantQualityWhereInput
  }

  export type JobPostingLocationNullableScalarRelationFilter = {
    is?: JobPostingLocationWhereInput | null
    isNot?: JobPostingLocationWhereInput | null
  }

  export type JobPostingWorkArrengmentNullableScalarRelationFilter = {
    is?: JobPostingWorkArrengmentWhereInput | null
    isNot?: JobPostingWorkArrengmentWhereInput | null
  }

  export type JobPostingEmploymentTypeNullableScalarRelationFilter = {
    is?: JobPostingEmploymentTypeWhereInput | null
    isNot?: JobPostingEmploymentTypeWhereInput | null
  }

  export type JobPostingSalaryNullableScalarRelationFilter = {
    is?: JobPostingSalaryWhereInput | null
    isNot?: JobPostingSalaryWhereInput | null
  }

  export type CreatedJobPostingNullableScalarRelationFilter = {
    is?: CreatedJobPostingWhereInput | null
    isNot?: CreatedJobPostingWhereInput | null
  }

  export type JobPostingLanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobPostingRequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobPostingMeritOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobPostingApplicantQualityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobPostingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    companyName?: SortOrder
    companyLogo?: SortOrder
    jobPostingUrl?: SortOrder
    jobDescription?: SortOrder
    markdownText?: SortOrder
    status?: SortOrder
    endsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type JobPostingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    companyName?: SortOrder
    companyLogo?: SortOrder
    jobPostingUrl?: SortOrder
    jobDescription?: SortOrder
    markdownText?: SortOrder
    status?: SortOrder
    endsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type JobPostingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    companyName?: SortOrder
    companyLogo?: SortOrder
    jobPostingUrl?: SortOrder
    jobDescription?: SortOrder
    markdownText?: SortOrder
    status?: SortOrder
    endsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type JobPostingScalarRelationFilter = {
    is?: JobPostingWhereInput
    isNot?: JobPostingWhereInput
  }

  export type JobPostingLanguageCountOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    language?: SortOrder
    level?: SortOrder
  }

  export type JobPostingLanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    language?: SortOrder
    level?: SortOrder
  }

  export type JobPostingLanguageMinOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    language?: SortOrder
    level?: SortOrder
  }

  export type JobPostingRequirementCountOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    requirement?: SortOrder
  }

  export type JobPostingRequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    requirement?: SortOrder
  }

  export type JobPostingRequirementMinOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    requirement?: SortOrder
  }

  export type JobPostingMeritCountOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    merit?: SortOrder
  }

  export type JobPostingMeritMaxOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    merit?: SortOrder
  }

  export type JobPostingMeritMinOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    merit?: SortOrder
  }

  export type JobPostingApplicantQualityCountOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    quality?: SortOrder
  }

  export type JobPostingApplicantQualityMaxOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    quality?: SortOrder
  }

  export type JobPostingApplicantQualityMinOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    quality?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type JobPostingLocationCountOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    isRemote?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type JobPostingLocationAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type JobPostingLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    isRemote?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type JobPostingLocationMinOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    isRemote?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type JobPostingLocationSumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type JobPostingWorkArrengmentCountOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    mode?: SortOrder
  }

  export type JobPostingWorkArrengmentMaxOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    mode?: SortOrder
  }

  export type JobPostingWorkArrengmentMinOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    mode?: SortOrder
  }

  export type JobPostingEmploymentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    type?: SortOrder
  }

  export type JobPostingEmploymentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    type?: SortOrder
  }

  export type JobPostingEmploymentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    type?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type JobPostingSalaryCountOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    period?: SortOrder
    benefits?: SortOrder
    notes?: SortOrder
  }

  export type JobPostingSalaryMaxOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    period?: SortOrder
    notes?: SortOrder
  }

  export type JobPostingSalaryMinOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    period?: SortOrder
    notes?: SortOrder
  }

  export type EnumCreatedByEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatedByEnum | EnumCreatedByEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CreatedByEnum[] | ListEnumCreatedByEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatedByEnum[] | ListEnumCreatedByEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatedByEnumFilter<$PrismaModel> | $Enums.CreatedByEnum
  }

  export type EnumJobSourceEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.JobSourceEnum | EnumJobSourceEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.JobSourceEnum[] | ListEnumJobSourceEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.JobSourceEnum[] | ListEnumJobSourceEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumJobSourceEnumNullableFilter<$PrismaModel> | $Enums.JobSourceEnum | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CreatedJobPostingCountOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    createdByType?: SortOrder
    createdById?: SortOrder
    source?: SortOrder
    importedAt?: SortOrder
  }

  export type CreatedJobPostingMaxOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    createdByType?: SortOrder
    createdById?: SortOrder
    source?: SortOrder
    importedAt?: SortOrder
  }

  export type CreatedJobPostingMinOrderByAggregateInput = {
    id?: SortOrder
    jobPostingId?: SortOrder
    createdByType?: SortOrder
    createdById?: SortOrder
    source?: SortOrder
    importedAt?: SortOrder
  }

  export type EnumCreatedByEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatedByEnum | EnumCreatedByEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CreatedByEnum[] | ListEnumCreatedByEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatedByEnum[] | ListEnumCreatedByEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatedByEnumWithAggregatesFilter<$PrismaModel> | $Enums.CreatedByEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreatedByEnumFilter<$PrismaModel>
    _max?: NestedEnumCreatedByEnumFilter<$PrismaModel>
  }

  export type EnumJobSourceEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobSourceEnum | EnumJobSourceEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.JobSourceEnum[] | ListEnumJobSourceEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.JobSourceEnum[] | ListEnumJobSourceEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumJobSourceEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.JobSourceEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumJobSourceEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumJobSourceEnumNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type JobApplicantsUserIdJobPostingIdCompoundUniqueInput = {
    userId: string
    jobPostingId: string
  }

  export type JobApplicantsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobPostingId?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    gotJob?: SortOrder
  }

  export type JobApplicantsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobPostingId?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    gotJob?: SortOrder
  }

  export type JobApplicantsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobPostingId?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    gotJob?: SortOrder
  }

  export type EnumStatusUserJobProcessesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusUserJobProcesses | EnumStatusUserJobProcessesFieldRefInput<$PrismaModel>
    in?: $Enums.StatusUserJobProcesses[] | ListEnumStatusUserJobProcessesFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusUserJobProcesses[] | ListEnumStatusUserJobProcessesFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusUserJobProcessesFilter<$PrismaModel> | $Enums.StatusUserJobProcesses
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserProcessStepListRelationFilter = {
    every?: UserProcessStepWhereInput
    some?: UserProcessStepWhereInput
    none?: UserProcessStepWhereInput
  }

  export type JobPostingNullableScalarRelationFilter = {
    is?: JobPostingWhereInput | null
    isNot?: JobPostingWhereInput | null
  }

  export type ProcessNullableScalarRelationFilter = {
    is?: ProcessWhereInput | null
    isNot?: ProcessWhereInput | null
  }

  export type TodoUserProcessListRelationFilter = {
    every?: TodoUserProcessWhereInput
    some?: TodoUserProcessWhereInput
    none?: TodoUserProcessWhereInput
  }

  export type UserProcessStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TodoUserProcessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProcessUserIdJobPostingIdCompoundUniqueInput = {
    userId: string
    jobPostingId: string
  }

  export type UserProcessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    jobPostingId?: SortOrder
    processId?: SortOrder
  }

  export type UserProcessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    jobPostingId?: SortOrder
    processId?: SortOrder
  }

  export type UserProcessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    jobPostingId?: SortOrder
    processId?: SortOrder
  }

  export type EnumStatusUserJobProcessesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusUserJobProcesses | EnumStatusUserJobProcessesFieldRefInput<$PrismaModel>
    in?: $Enums.StatusUserJobProcesses[] | ListEnumStatusUserJobProcessesFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusUserJobProcesses[] | ListEnumStatusUserJobProcessesFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusUserJobProcessesWithAggregatesFilter<$PrismaModel> | $Enums.StatusUserJobProcesses
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusUserJobProcessesFilter<$PrismaModel>
    _max?: NestedEnumStatusUserJobProcessesFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserProcessScalarRelationFilter = {
    is?: UserProcessWhereInput
    isNot?: UserProcessWhereInput
  }

  export type ProcessStepNullableScalarRelationFilter = {
    is?: ProcessStepWhereInput | null
    isNot?: ProcessStepWhereInput | null
  }

  export type UserProcessStepUserProcessIdStepIdCompoundUniqueInput = {
    userProcessId: string
    stepId: string
  }

  export type UserProcessStepCountOrderByAggregateInput = {
    id?: SortOrder
    userProcessId?: SortOrder
    stepId?: SortOrder
    isExecuted?: SortOrder
    executedAt?: SortOrder
  }

  export type UserProcessStepMaxOrderByAggregateInput = {
    id?: SortOrder
    userProcessId?: SortOrder
    stepId?: SortOrder
    isExecuted?: SortOrder
    executedAt?: SortOrder
  }

  export type UserProcessStepMinOrderByAggregateInput = {
    id?: SortOrder
    userProcessId?: SortOrder
    stepId?: SortOrder
    isExecuted?: SortOrder
    executedAt?: SortOrder
  }

  export type UserProcessStepScalarRelationFilter = {
    is?: UserProcessStepWhereInput
    isNot?: UserProcessStepWhereInput
  }

  export type UserPipelineStepCommentCountOrderByAggregateInput = {
    id?: SortOrder
    userPipelineStepId?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPipelineStepCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    userPipelineStepId?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPipelineStepCommentMinOrderByAggregateInput = {
    id?: SortOrder
    userPipelineStepId?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ProcessIdOwnerIdCompoundUniqueInput = {
    id: string
    ownerId: string
  }

  export type ProcessCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    ownerId?: SortOrder
    isTemplate?: SortOrder
    isPublic?: SortOrder
  }

  export type ProcessMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    ownerId?: SortOrder
    isTemplate?: SortOrder
    isPublic?: SortOrder
  }

  export type ProcessMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    ownerId?: SortOrder
    isTemplate?: SortOrder
    isPublic?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProcessScalarRelationFilter = {
    is?: ProcessWhereInput
    isNot?: ProcessWhereInput
  }

  export type TriggerDefinitionListRelationFilter = {
    every?: TriggerDefinitionWhereInput
    some?: TriggerDefinitionWhereInput
    none?: TriggerDefinitionWhereInput
  }

  export type ActionDefinitionListRelationFilter = {
    every?: ActionDefinitionWhereInput
    some?: ActionDefinitionWhereInput
    none?: ActionDefinitionWhereInput
  }

  export type TriggerDefinitionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActionDefinitionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessStepCountOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    userId?: SortOrder
  }

  export type ProcessStepAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProcessStepMaxOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    userId?: SortOrder
  }

  export type ProcessStepMinOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    userId?: SortOrder
  }

  export type ProcessStepSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ActionDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isPublic?: SortOrder
    order?: SortOrder
    config?: SortOrder
    stepId?: SortOrder
  }

  export type ActionDefinitionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ActionDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isPublic?: SortOrder
    order?: SortOrder
    stepId?: SortOrder
  }

  export type ActionDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isPublic?: SortOrder
    order?: SortOrder
    stepId?: SortOrder
  }

  export type ActionDefinitionSumOrderByAggregateInput = {
    order?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumTriggerEventCodeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerEventCode | EnumTriggerEventCodeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriggerEventCode[] | ListEnumTriggerEventCodeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TriggerEventCode[] | ListEnumTriggerEventCodeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTriggerEventCodeNullableFilter<$PrismaModel> | $Enums.TriggerEventCode | null
  }

  export type EnumCombinatorEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CombinatorEnum | EnumCombinatorEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.CombinatorEnum[] | ListEnumCombinatorEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CombinatorEnum[] | ListEnumCombinatorEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCombinatorEnumNullableFilter<$PrismaModel> | $Enums.CombinatorEnum | null
  }

  export type ConditionalListRelationFilter = {
    every?: ConditionalWhereInput
    some?: ConditionalWhereInput
    none?: ConditionalWhereInput
  }

  export type ConditionalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TriggerDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    triggerCode?: SortOrder
    executeWhen?: SortOrder
    executeAt?: SortOrder
    combinator?: SortOrder
    config?: SortOrder
    expiration?: SortOrder
    stepId?: SortOrder
  }

  export type TriggerDefinitionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type TriggerDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    triggerCode?: SortOrder
    executeWhen?: SortOrder
    executeAt?: SortOrder
    combinator?: SortOrder
    expiration?: SortOrder
    stepId?: SortOrder
  }

  export type TriggerDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    triggerCode?: SortOrder
    executeWhen?: SortOrder
    executeAt?: SortOrder
    combinator?: SortOrder
    expiration?: SortOrder
    stepId?: SortOrder
  }

  export type TriggerDefinitionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumTriggerEventCodeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerEventCode | EnumTriggerEventCodeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriggerEventCode[] | ListEnumTriggerEventCodeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TriggerEventCode[] | ListEnumTriggerEventCodeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTriggerEventCodeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TriggerEventCode | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTriggerEventCodeNullableFilter<$PrismaModel>
    _max?: NestedEnumTriggerEventCodeNullableFilter<$PrismaModel>
  }

  export type EnumCombinatorEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CombinatorEnum | EnumCombinatorEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.CombinatorEnum[] | ListEnumCombinatorEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CombinatorEnum[] | ListEnumCombinatorEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCombinatorEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.CombinatorEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCombinatorEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumCombinatorEnumNullableFilter<$PrismaModel>
  }

  export type EnumComparisonOperatorEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ComparisonOperatorEnum | EnumComparisonOperatorEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ComparisonOperatorEnum[] | ListEnumComparisonOperatorEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComparisonOperatorEnum[] | ListEnumComparisonOperatorEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumComparisonOperatorEnumFilter<$PrismaModel> | $Enums.ComparisonOperatorEnum
  }

  export type TriggerDefinitionScalarRelationFilter = {
    is?: TriggerDefinitionWhereInput
    isNot?: TriggerDefinitionWhereInput
  }

  export type ConditionalCountOrderByAggregateInput = {
    id?: SortOrder
    triggerId?: SortOrder
    fieldKey?: SortOrder
    fieldKeyLabel?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    combinator?: SortOrder
  }

  export type ConditionalMaxOrderByAggregateInput = {
    id?: SortOrder
    triggerId?: SortOrder
    fieldKey?: SortOrder
    fieldKeyLabel?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    combinator?: SortOrder
  }

  export type ConditionalMinOrderByAggregateInput = {
    id?: SortOrder
    triggerId?: SortOrder
    fieldKey?: SortOrder
    fieldKeyLabel?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    combinator?: SortOrder
  }

  export type EnumComparisonOperatorEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComparisonOperatorEnum | EnumComparisonOperatorEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ComparisonOperatorEnum[] | ListEnumComparisonOperatorEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComparisonOperatorEnum[] | ListEnumComparisonOperatorEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumComparisonOperatorEnumWithAggregatesFilter<$PrismaModel> | $Enums.ComparisonOperatorEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComparisonOperatorEnumFilter<$PrismaModel>
    _max?: NestedEnumComparisonOperatorEnumFilter<$PrismaModel>
  }

  export type TodoItemListRelationFilter = {
    every?: TodoItemWhereInput
    some?: TodoItemWhereInput
    none?: TodoItemWhereInput
  }

  export type TodoItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TodoCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTodoItemTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.TodoItemTypeEnum | EnumTodoItemTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TodoItemTypeEnum[] | ListEnumTodoItemTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.TodoItemTypeEnum[] | ListEnumTodoItemTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumTodoItemTypeEnumFilter<$PrismaModel> | $Enums.TodoItemTypeEnum
  }

  export type TodoScalarRelationFilter = {
    is?: TodoWhereInput
    isNot?: TodoWhereInput
  }

  export type TodoItemCountOrderByAggregateInput = {
    id?: SortOrder
    todoId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
  }

  export type TodoItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type TodoItemMaxOrderByAggregateInput = {
    id?: SortOrder
    todoId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
  }

  export type TodoItemMinOrderByAggregateInput = {
    id?: SortOrder
    todoId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
  }

  export type TodoItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumTodoItemTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TodoItemTypeEnum | EnumTodoItemTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TodoItemTypeEnum[] | ListEnumTodoItemTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.TodoItemTypeEnum[] | ListEnumTodoItemTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumTodoItemTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.TodoItemTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTodoItemTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumTodoItemTypeEnumFilter<$PrismaModel>
  }

  export type TodoUserProcessTodoIdUserProcessIdCompoundUniqueInput = {
    todoId: string
    userProcessId: string
  }

  export type TodoUserProcessCountOrderByAggregateInput = {
    id?: SortOrder
    todoId?: SortOrder
    userProcessId?: SortOrder
  }

  export type TodoUserProcessMaxOrderByAggregateInput = {
    id?: SortOrder
    todoId?: SortOrder
    userProcessId?: SortOrder
  }

  export type TodoUserProcessMinOrderByAggregateInput = {
    id?: SortOrder
    todoId?: SortOrder
    userProcessId?: SortOrder
  }

  export type ProviderCreateNestedManyWithoutUserInput = {
    create?: XOR<ProviderCreateWithoutUserInput, ProviderUncheckedCreateWithoutUserInput> | ProviderCreateWithoutUserInput[] | ProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProviderCreateOrConnectWithoutUserInput | ProviderCreateOrConnectWithoutUserInput[]
    createMany?: ProviderCreateManyUserInputEnvelope
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
  }

  export type JobApplicantsCreateNestedManyWithoutUserInput = {
    create?: XOR<JobApplicantsCreateWithoutUserInput, JobApplicantsUncheckedCreateWithoutUserInput> | JobApplicantsCreateWithoutUserInput[] | JobApplicantsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobApplicantsCreateOrConnectWithoutUserInput | JobApplicantsCreateOrConnectWithoutUserInput[]
    createMany?: JobApplicantsCreateManyUserInputEnvelope
    connect?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
  }

  export type UserProcessCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProcessCreateWithoutUserInput, UserProcessUncheckedCreateWithoutUserInput> | UserProcessCreateWithoutUserInput[] | UserProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProcessCreateOrConnectWithoutUserInput | UserProcessCreateOrConnectWithoutUserInput[]
    createMany?: UserProcessCreateManyUserInputEnvelope
    connect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type CreatedJobPostingCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CreatedJobPostingCreateWithoutCreatedByInput, CreatedJobPostingUncheckedCreateWithoutCreatedByInput> | CreatedJobPostingCreateWithoutCreatedByInput[] | CreatedJobPostingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CreatedJobPostingCreateOrConnectWithoutCreatedByInput | CreatedJobPostingCreateOrConnectWithoutCreatedByInput[]
    createMany?: CreatedJobPostingCreateManyCreatedByInputEnvelope
    connect?: CreatedJobPostingWhereUniqueInput | CreatedJobPostingWhereUniqueInput[]
  }

  export type UserPipelineStepCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPipelineStepCommentCreateWithoutUserInput, UserPipelineStepCommentUncheckedCreateWithoutUserInput> | UserPipelineStepCommentCreateWithoutUserInput[] | UserPipelineStepCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPipelineStepCommentCreateOrConnectWithoutUserInput | UserPipelineStepCommentCreateOrConnectWithoutUserInput[]
    createMany?: UserPipelineStepCommentCreateManyUserInputEnvelope
    connect?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
  }

  export type ProcessStepCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessStepCreateWithoutUserInput, ProcessStepUncheckedCreateWithoutUserInput> | ProcessStepCreateWithoutUserInput[] | ProcessStepUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutUserInput | ProcessStepCreateOrConnectWithoutUserInput[]
    createMany?: ProcessStepCreateManyUserInputEnvelope
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
  }

  export type ProcessCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type TodoCreateNestedManyWithoutUserInput = {
    create?: XOR<TodoCreateWithoutUserInput, TodoUncheckedCreateWithoutUserInput> | TodoCreateWithoutUserInput[] | TodoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TodoCreateOrConnectWithoutUserInput | TodoCreateOrConnectWithoutUserInput[]
    createMany?: TodoCreateManyUserInputEnvelope
    connect?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
  }

  export type ProviderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProviderCreateWithoutUserInput, ProviderUncheckedCreateWithoutUserInput> | ProviderCreateWithoutUserInput[] | ProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProviderCreateOrConnectWithoutUserInput | ProviderCreateOrConnectWithoutUserInput[]
    createMany?: ProviderCreateManyUserInputEnvelope
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
  }

  export type JobApplicantsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JobApplicantsCreateWithoutUserInput, JobApplicantsUncheckedCreateWithoutUserInput> | JobApplicantsCreateWithoutUserInput[] | JobApplicantsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobApplicantsCreateOrConnectWithoutUserInput | JobApplicantsCreateOrConnectWithoutUserInput[]
    createMany?: JobApplicantsCreateManyUserInputEnvelope
    connect?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
  }

  export type UserProcessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProcessCreateWithoutUserInput, UserProcessUncheckedCreateWithoutUserInput> | UserProcessCreateWithoutUserInput[] | UserProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProcessCreateOrConnectWithoutUserInput | UserProcessCreateOrConnectWithoutUserInput[]
    createMany?: UserProcessCreateManyUserInputEnvelope
    connect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
  }

  export type CreatedJobPostingUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CreatedJobPostingCreateWithoutCreatedByInput, CreatedJobPostingUncheckedCreateWithoutCreatedByInput> | CreatedJobPostingCreateWithoutCreatedByInput[] | CreatedJobPostingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CreatedJobPostingCreateOrConnectWithoutCreatedByInput | CreatedJobPostingCreateOrConnectWithoutCreatedByInput[]
    createMany?: CreatedJobPostingCreateManyCreatedByInputEnvelope
    connect?: CreatedJobPostingWhereUniqueInput | CreatedJobPostingWhereUniqueInput[]
  }

  export type UserPipelineStepCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPipelineStepCommentCreateWithoutUserInput, UserPipelineStepCommentUncheckedCreateWithoutUserInput> | UserPipelineStepCommentCreateWithoutUserInput[] | UserPipelineStepCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPipelineStepCommentCreateOrConnectWithoutUserInput | UserPipelineStepCommentCreateOrConnectWithoutUserInput[]
    createMany?: UserPipelineStepCommentCreateManyUserInputEnvelope
    connect?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
  }

  export type ProcessStepUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessStepCreateWithoutUserInput, ProcessStepUncheckedCreateWithoutUserInput> | ProcessStepCreateWithoutUserInput[] | ProcessStepUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutUserInput | ProcessStepCreateOrConnectWithoutUserInput[]
    createMany?: ProcessStepCreateManyUserInputEnvelope
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
  }

  export type ProcessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type TodoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TodoCreateWithoutUserInput, TodoUncheckedCreateWithoutUserInput> | TodoCreateWithoutUserInput[] | TodoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TodoCreateOrConnectWithoutUserInput | TodoCreateOrConnectWithoutUserInput[]
    createMany?: TodoCreateManyUserInputEnvelope
    connect?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ProviderUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProviderCreateWithoutUserInput, ProviderUncheckedCreateWithoutUserInput> | ProviderCreateWithoutUserInput[] | ProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProviderCreateOrConnectWithoutUserInput | ProviderCreateOrConnectWithoutUserInput[]
    upsert?: ProviderUpsertWithWhereUniqueWithoutUserInput | ProviderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProviderCreateManyUserInputEnvelope
    set?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    disconnect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    delete?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    update?: ProviderUpdateWithWhereUniqueWithoutUserInput | ProviderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProviderUpdateManyWithWhereWithoutUserInput | ProviderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProviderScalarWhereInput | ProviderScalarWhereInput[]
  }

  export type JobApplicantsUpdateManyWithoutUserNestedInput = {
    create?: XOR<JobApplicantsCreateWithoutUserInput, JobApplicantsUncheckedCreateWithoutUserInput> | JobApplicantsCreateWithoutUserInput[] | JobApplicantsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobApplicantsCreateOrConnectWithoutUserInput | JobApplicantsCreateOrConnectWithoutUserInput[]
    upsert?: JobApplicantsUpsertWithWhereUniqueWithoutUserInput | JobApplicantsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JobApplicantsCreateManyUserInputEnvelope
    set?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    disconnect?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    delete?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    connect?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    update?: JobApplicantsUpdateWithWhereUniqueWithoutUserInput | JobApplicantsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JobApplicantsUpdateManyWithWhereWithoutUserInput | JobApplicantsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JobApplicantsScalarWhereInput | JobApplicantsScalarWhereInput[]
  }

  export type UserProcessUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProcessCreateWithoutUserInput, UserProcessUncheckedCreateWithoutUserInput> | UserProcessCreateWithoutUserInput[] | UserProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProcessCreateOrConnectWithoutUserInput | UserProcessCreateOrConnectWithoutUserInput[]
    upsert?: UserProcessUpsertWithWhereUniqueWithoutUserInput | UserProcessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProcessCreateManyUserInputEnvelope
    set?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    disconnect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    delete?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    connect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    update?: UserProcessUpdateWithWhereUniqueWithoutUserInput | UserProcessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProcessUpdateManyWithWhereWithoutUserInput | UserProcessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProcessScalarWhereInput | UserProcessScalarWhereInput[]
  }

  export type CompanyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CreatedJobPostingUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CreatedJobPostingCreateWithoutCreatedByInput, CreatedJobPostingUncheckedCreateWithoutCreatedByInput> | CreatedJobPostingCreateWithoutCreatedByInput[] | CreatedJobPostingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CreatedJobPostingCreateOrConnectWithoutCreatedByInput | CreatedJobPostingCreateOrConnectWithoutCreatedByInput[]
    upsert?: CreatedJobPostingUpsertWithWhereUniqueWithoutCreatedByInput | CreatedJobPostingUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CreatedJobPostingCreateManyCreatedByInputEnvelope
    set?: CreatedJobPostingWhereUniqueInput | CreatedJobPostingWhereUniqueInput[]
    disconnect?: CreatedJobPostingWhereUniqueInput | CreatedJobPostingWhereUniqueInput[]
    delete?: CreatedJobPostingWhereUniqueInput | CreatedJobPostingWhereUniqueInput[]
    connect?: CreatedJobPostingWhereUniqueInput | CreatedJobPostingWhereUniqueInput[]
    update?: CreatedJobPostingUpdateWithWhereUniqueWithoutCreatedByInput | CreatedJobPostingUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CreatedJobPostingUpdateManyWithWhereWithoutCreatedByInput | CreatedJobPostingUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CreatedJobPostingScalarWhereInput | CreatedJobPostingScalarWhereInput[]
  }

  export type UserPipelineStepCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPipelineStepCommentCreateWithoutUserInput, UserPipelineStepCommentUncheckedCreateWithoutUserInput> | UserPipelineStepCommentCreateWithoutUserInput[] | UserPipelineStepCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPipelineStepCommentCreateOrConnectWithoutUserInput | UserPipelineStepCommentCreateOrConnectWithoutUserInput[]
    upsert?: UserPipelineStepCommentUpsertWithWhereUniqueWithoutUserInput | UserPipelineStepCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPipelineStepCommentCreateManyUserInputEnvelope
    set?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    disconnect?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    delete?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    connect?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    update?: UserPipelineStepCommentUpdateWithWhereUniqueWithoutUserInput | UserPipelineStepCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPipelineStepCommentUpdateManyWithWhereWithoutUserInput | UserPipelineStepCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPipelineStepCommentScalarWhereInput | UserPipelineStepCommentScalarWhereInput[]
  }

  export type ProcessStepUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessStepCreateWithoutUserInput, ProcessStepUncheckedCreateWithoutUserInput> | ProcessStepCreateWithoutUserInput[] | ProcessStepUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutUserInput | ProcessStepCreateOrConnectWithoutUserInput[]
    upsert?: ProcessStepUpsertWithWhereUniqueWithoutUserInput | ProcessStepUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessStepCreateManyUserInputEnvelope
    set?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    disconnect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    delete?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    update?: ProcessStepUpdateWithWhereUniqueWithoutUserInput | ProcessStepUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessStepUpdateManyWithWhereWithoutUserInput | ProcessStepUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
  }

  export type ProcessUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutUserInput | ProcessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutUserInput | ProcessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutUserInput | ProcessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type TodoUpdateManyWithoutUserNestedInput = {
    create?: XOR<TodoCreateWithoutUserInput, TodoUncheckedCreateWithoutUserInput> | TodoCreateWithoutUserInput[] | TodoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TodoCreateOrConnectWithoutUserInput | TodoCreateOrConnectWithoutUserInput[]
    upsert?: TodoUpsertWithWhereUniqueWithoutUserInput | TodoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TodoCreateManyUserInputEnvelope
    set?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    disconnect?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    delete?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    connect?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    update?: TodoUpdateWithWhereUniqueWithoutUserInput | TodoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TodoUpdateManyWithWhereWithoutUserInput | TodoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TodoScalarWhereInput | TodoScalarWhereInput[]
  }

  export type ProviderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProviderCreateWithoutUserInput, ProviderUncheckedCreateWithoutUserInput> | ProviderCreateWithoutUserInput[] | ProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProviderCreateOrConnectWithoutUserInput | ProviderCreateOrConnectWithoutUserInput[]
    upsert?: ProviderUpsertWithWhereUniqueWithoutUserInput | ProviderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProviderCreateManyUserInputEnvelope
    set?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    disconnect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    delete?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    update?: ProviderUpdateWithWhereUniqueWithoutUserInput | ProviderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProviderUpdateManyWithWhereWithoutUserInput | ProviderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProviderScalarWhereInput | ProviderScalarWhereInput[]
  }

  export type JobApplicantsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JobApplicantsCreateWithoutUserInput, JobApplicantsUncheckedCreateWithoutUserInput> | JobApplicantsCreateWithoutUserInput[] | JobApplicantsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobApplicantsCreateOrConnectWithoutUserInput | JobApplicantsCreateOrConnectWithoutUserInput[]
    upsert?: JobApplicantsUpsertWithWhereUniqueWithoutUserInput | JobApplicantsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JobApplicantsCreateManyUserInputEnvelope
    set?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    disconnect?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    delete?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    connect?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    update?: JobApplicantsUpdateWithWhereUniqueWithoutUserInput | JobApplicantsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JobApplicantsUpdateManyWithWhereWithoutUserInput | JobApplicantsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JobApplicantsScalarWhereInput | JobApplicantsScalarWhereInput[]
  }

  export type UserProcessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProcessCreateWithoutUserInput, UserProcessUncheckedCreateWithoutUserInput> | UserProcessCreateWithoutUserInput[] | UserProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProcessCreateOrConnectWithoutUserInput | UserProcessCreateOrConnectWithoutUserInput[]
    upsert?: UserProcessUpsertWithWhereUniqueWithoutUserInput | UserProcessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProcessCreateManyUserInputEnvelope
    set?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    disconnect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    delete?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    connect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    update?: UserProcessUpdateWithWhereUniqueWithoutUserInput | UserProcessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProcessUpdateManyWithWhereWithoutUserInput | UserProcessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProcessScalarWhereInput | UserProcessScalarWhereInput[]
  }

  export type CreatedJobPostingUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CreatedJobPostingCreateWithoutCreatedByInput, CreatedJobPostingUncheckedCreateWithoutCreatedByInput> | CreatedJobPostingCreateWithoutCreatedByInput[] | CreatedJobPostingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CreatedJobPostingCreateOrConnectWithoutCreatedByInput | CreatedJobPostingCreateOrConnectWithoutCreatedByInput[]
    upsert?: CreatedJobPostingUpsertWithWhereUniqueWithoutCreatedByInput | CreatedJobPostingUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CreatedJobPostingCreateManyCreatedByInputEnvelope
    set?: CreatedJobPostingWhereUniqueInput | CreatedJobPostingWhereUniqueInput[]
    disconnect?: CreatedJobPostingWhereUniqueInput | CreatedJobPostingWhereUniqueInput[]
    delete?: CreatedJobPostingWhereUniqueInput | CreatedJobPostingWhereUniqueInput[]
    connect?: CreatedJobPostingWhereUniqueInput | CreatedJobPostingWhereUniqueInput[]
    update?: CreatedJobPostingUpdateWithWhereUniqueWithoutCreatedByInput | CreatedJobPostingUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CreatedJobPostingUpdateManyWithWhereWithoutCreatedByInput | CreatedJobPostingUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CreatedJobPostingScalarWhereInput | CreatedJobPostingScalarWhereInput[]
  }

  export type UserPipelineStepCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPipelineStepCommentCreateWithoutUserInput, UserPipelineStepCommentUncheckedCreateWithoutUserInput> | UserPipelineStepCommentCreateWithoutUserInput[] | UserPipelineStepCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPipelineStepCommentCreateOrConnectWithoutUserInput | UserPipelineStepCommentCreateOrConnectWithoutUserInput[]
    upsert?: UserPipelineStepCommentUpsertWithWhereUniqueWithoutUserInput | UserPipelineStepCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPipelineStepCommentCreateManyUserInputEnvelope
    set?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    disconnect?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    delete?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    connect?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    update?: UserPipelineStepCommentUpdateWithWhereUniqueWithoutUserInput | UserPipelineStepCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPipelineStepCommentUpdateManyWithWhereWithoutUserInput | UserPipelineStepCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPipelineStepCommentScalarWhereInput | UserPipelineStepCommentScalarWhereInput[]
  }

  export type ProcessStepUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessStepCreateWithoutUserInput, ProcessStepUncheckedCreateWithoutUserInput> | ProcessStepCreateWithoutUserInput[] | ProcessStepUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutUserInput | ProcessStepCreateOrConnectWithoutUserInput[]
    upsert?: ProcessStepUpsertWithWhereUniqueWithoutUserInput | ProcessStepUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessStepCreateManyUserInputEnvelope
    set?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    disconnect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    delete?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    update?: ProcessStepUpdateWithWhereUniqueWithoutUserInput | ProcessStepUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessStepUpdateManyWithWhereWithoutUserInput | ProcessStepUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
  }

  export type ProcessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput> | ProcessCreateWithoutUserInput[] | ProcessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutUserInput | ProcessCreateOrConnectWithoutUserInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutUserInput | ProcessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessCreateManyUserInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutUserInput | ProcessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutUserInput | ProcessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type TodoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TodoCreateWithoutUserInput, TodoUncheckedCreateWithoutUserInput> | TodoCreateWithoutUserInput[] | TodoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TodoCreateOrConnectWithoutUserInput | TodoCreateOrConnectWithoutUserInput[]
    upsert?: TodoUpsertWithWhereUniqueWithoutUserInput | TodoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TodoCreateManyUserInputEnvelope
    set?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    disconnect?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    delete?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    connect?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    update?: TodoUpdateWithWhereUniqueWithoutUserInput | TodoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TodoUpdateManyWithWhereWithoutUserInput | TodoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TodoScalarWhereInput | TodoScalarWhereInput[]
  }

  export type TokenCreateNestedOneWithoutProviderInput = {
    create?: XOR<TokenCreateWithoutProviderInput, TokenUncheckedCreateWithoutProviderInput>
    connectOrCreate?: TokenCreateOrConnectWithoutProviderInput
    connect?: TokenWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProvidersInput = {
    create?: XOR<UserCreateWithoutProvidersInput, UserUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProvidersInput
    connect?: UserWhereUniqueInput
  }

  export type TokenUncheckedCreateNestedOneWithoutProviderInput = {
    create?: XOR<TokenCreateWithoutProviderInput, TokenUncheckedCreateWithoutProviderInput>
    connectOrCreate?: TokenCreateOrConnectWithoutProviderInput
    connect?: TokenWhereUniqueInput
  }

  export type EnumProviderEnumFieldUpdateOperationsInput = {
    set?: $Enums.ProviderEnum
  }

  export type TokenUpdateOneWithoutProviderNestedInput = {
    create?: XOR<TokenCreateWithoutProviderInput, TokenUncheckedCreateWithoutProviderInput>
    connectOrCreate?: TokenCreateOrConnectWithoutProviderInput
    upsert?: TokenUpsertWithoutProviderInput
    disconnect?: TokenWhereInput | boolean
    delete?: TokenWhereInput | boolean
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutProviderInput, TokenUpdateWithoutProviderInput>, TokenUncheckedUpdateWithoutProviderInput>
  }

  export type UserUpdateOneRequiredWithoutProvidersNestedInput = {
    create?: XOR<UserCreateWithoutProvidersInput, UserUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProvidersInput
    upsert?: UserUpsertWithoutProvidersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProvidersInput, UserUpdateWithoutProvidersInput>, UserUncheckedUpdateWithoutProvidersInput>
  }

  export type TokenUncheckedUpdateOneWithoutProviderNestedInput = {
    create?: XOR<TokenCreateWithoutProviderInput, TokenUncheckedCreateWithoutProviderInput>
    connectOrCreate?: TokenCreateOrConnectWithoutProviderInput
    upsert?: TokenUpsertWithoutProviderInput
    disconnect?: TokenWhereInput | boolean
    delete?: TokenWhereInput | boolean
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutProviderInput, TokenUpdateWithoutProviderInput>, TokenUncheckedUpdateWithoutProviderInput>
  }

  export type ProviderCreateNestedOneWithoutTokenInput = {
    create?: XOR<ProviderCreateWithoutTokenInput, ProviderUncheckedCreateWithoutTokenInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutTokenInput
    connect?: ProviderWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProviderUpdateOneRequiredWithoutTokenNestedInput = {
    create?: XOR<ProviderCreateWithoutTokenInput, ProviderUncheckedCreateWithoutTokenInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutTokenInput
    upsert?: ProviderUpsertWithoutTokenInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutTokenInput, ProviderUpdateWithoutTokenInput>, ProviderUncheckedUpdateWithoutTokenInput>
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type JobPostingCreateNestedManyWithoutCompanyInput = {
    create?: XOR<JobPostingCreateWithoutCompanyInput, JobPostingUncheckedCreateWithoutCompanyInput> | JobPostingCreateWithoutCompanyInput[] | JobPostingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobPostingCreateOrConnectWithoutCompanyInput | JobPostingCreateOrConnectWithoutCompanyInput[]
    createMany?: JobPostingCreateManyCompanyInputEnvelope
    connect?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type JobPostingUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<JobPostingCreateWithoutCompanyInput, JobPostingUncheckedCreateWithoutCompanyInput> | JobPostingCreateWithoutCompanyInput[] | JobPostingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobPostingCreateOrConnectWithoutCompanyInput | JobPostingCreateOrConnectWithoutCompanyInput[]
    createMany?: JobPostingCreateManyCompanyInputEnvelope
    connect?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type JobPostingUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<JobPostingCreateWithoutCompanyInput, JobPostingUncheckedCreateWithoutCompanyInput> | JobPostingCreateWithoutCompanyInput[] | JobPostingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobPostingCreateOrConnectWithoutCompanyInput | JobPostingCreateOrConnectWithoutCompanyInput[]
    upsert?: JobPostingUpsertWithWhereUniqueWithoutCompanyInput | JobPostingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: JobPostingCreateManyCompanyInputEnvelope
    set?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    disconnect?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    delete?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    connect?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    update?: JobPostingUpdateWithWhereUniqueWithoutCompanyInput | JobPostingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: JobPostingUpdateManyWithWhereWithoutCompanyInput | JobPostingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: JobPostingScalarWhereInput | JobPostingScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type JobPostingUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<JobPostingCreateWithoutCompanyInput, JobPostingUncheckedCreateWithoutCompanyInput> | JobPostingCreateWithoutCompanyInput[] | JobPostingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobPostingCreateOrConnectWithoutCompanyInput | JobPostingCreateOrConnectWithoutCompanyInput[]
    upsert?: JobPostingUpsertWithWhereUniqueWithoutCompanyInput | JobPostingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: JobPostingCreateManyCompanyInputEnvelope
    set?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    disconnect?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    delete?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    connect?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    update?: JobPostingUpdateWithWhereUniqueWithoutCompanyInput | JobPostingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: JobPostingUpdateManyWithWhereWithoutCompanyInput | JobPostingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: JobPostingScalarWhereInput | JobPostingScalarWhereInput[]
  }

  export type JobPostingLanguageCreateNestedManyWithoutJobPostingInput = {
    create?: XOR<JobPostingLanguageCreateWithoutJobPostingInput, JobPostingLanguageUncheckedCreateWithoutJobPostingInput> | JobPostingLanguageCreateWithoutJobPostingInput[] | JobPostingLanguageUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingLanguageCreateOrConnectWithoutJobPostingInput | JobPostingLanguageCreateOrConnectWithoutJobPostingInput[]
    createMany?: JobPostingLanguageCreateManyJobPostingInputEnvelope
    connect?: JobPostingLanguageWhereUniqueInput | JobPostingLanguageWhereUniqueInput[]
  }

  export type JobPostingRequirementCreateNestedManyWithoutJobPostingInput = {
    create?: XOR<JobPostingRequirementCreateWithoutJobPostingInput, JobPostingRequirementUncheckedCreateWithoutJobPostingInput> | JobPostingRequirementCreateWithoutJobPostingInput[] | JobPostingRequirementUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingRequirementCreateOrConnectWithoutJobPostingInput | JobPostingRequirementCreateOrConnectWithoutJobPostingInput[]
    createMany?: JobPostingRequirementCreateManyJobPostingInputEnvelope
    connect?: JobPostingRequirementWhereUniqueInput | JobPostingRequirementWhereUniqueInput[]
  }

  export type JobPostingMeritCreateNestedManyWithoutJobPostingInput = {
    create?: XOR<JobPostingMeritCreateWithoutJobPostingInput, JobPostingMeritUncheckedCreateWithoutJobPostingInput> | JobPostingMeritCreateWithoutJobPostingInput[] | JobPostingMeritUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingMeritCreateOrConnectWithoutJobPostingInput | JobPostingMeritCreateOrConnectWithoutJobPostingInput[]
    createMany?: JobPostingMeritCreateManyJobPostingInputEnvelope
    connect?: JobPostingMeritWhereUniqueInput | JobPostingMeritWhereUniqueInput[]
  }

  export type JobPostingApplicantQualityCreateNestedManyWithoutJobPostingInput = {
    create?: XOR<JobPostingApplicantQualityCreateWithoutJobPostingInput, JobPostingApplicantQualityUncheckedCreateWithoutJobPostingInput> | JobPostingApplicantQualityCreateWithoutJobPostingInput[] | JobPostingApplicantQualityUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingApplicantQualityCreateOrConnectWithoutJobPostingInput | JobPostingApplicantQualityCreateOrConnectWithoutJobPostingInput[]
    createMany?: JobPostingApplicantQualityCreateManyJobPostingInputEnvelope
    connect?: JobPostingApplicantQualityWhereUniqueInput | JobPostingApplicantQualityWhereUniqueInput[]
  }

  export type JobPostingLocationCreateNestedOneWithoutJobPostingInput = {
    create?: XOR<JobPostingLocationCreateWithoutJobPostingInput, JobPostingLocationUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingLocationCreateOrConnectWithoutJobPostingInput
    connect?: JobPostingLocationWhereUniqueInput
  }

  export type JobPostingWorkArrengmentCreateNestedOneWithoutJobPostingInput = {
    create?: XOR<JobPostingWorkArrengmentCreateWithoutJobPostingInput, JobPostingWorkArrengmentUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingWorkArrengmentCreateOrConnectWithoutJobPostingInput
    connect?: JobPostingWorkArrengmentWhereUniqueInput
  }

  export type JobPostingEmploymentTypeCreateNestedOneWithoutJobPostingInput = {
    create?: XOR<JobPostingEmploymentTypeCreateWithoutJobPostingInput, JobPostingEmploymentTypeUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingEmploymentTypeCreateOrConnectWithoutJobPostingInput
    connect?: JobPostingEmploymentTypeWhereUniqueInput
  }

  export type JobPostingSalaryCreateNestedOneWithoutJobPostingInput = {
    create?: XOR<JobPostingSalaryCreateWithoutJobPostingInput, JobPostingSalaryUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingSalaryCreateOrConnectWithoutJobPostingInput
    connect?: JobPostingSalaryWhereUniqueInput
  }

  export type CreatedJobPostingCreateNestedOneWithoutJobPostingInput = {
    create?: XOR<CreatedJobPostingCreateWithoutJobPostingInput, CreatedJobPostingUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: CreatedJobPostingCreateOrConnectWithoutJobPostingInput
    connect?: CreatedJobPostingWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutJobPostingsInput = {
    create?: XOR<CompanyCreateWithoutJobPostingsInput, CompanyUncheckedCreateWithoutJobPostingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJobPostingsInput
    connect?: CompanyWhereUniqueInput
  }

  export type JobApplicantsCreateNestedManyWithoutJobPostingInput = {
    create?: XOR<JobApplicantsCreateWithoutJobPostingInput, JobApplicantsUncheckedCreateWithoutJobPostingInput> | JobApplicantsCreateWithoutJobPostingInput[] | JobApplicantsUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobApplicantsCreateOrConnectWithoutJobPostingInput | JobApplicantsCreateOrConnectWithoutJobPostingInput[]
    createMany?: JobApplicantsCreateManyJobPostingInputEnvelope
    connect?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
  }

  export type UserProcessCreateNestedManyWithoutJobPostingInput = {
    create?: XOR<UserProcessCreateWithoutJobPostingInput, UserProcessUncheckedCreateWithoutJobPostingInput> | UserProcessCreateWithoutJobPostingInput[] | UserProcessUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: UserProcessCreateOrConnectWithoutJobPostingInput | UserProcessCreateOrConnectWithoutJobPostingInput[]
    createMany?: UserProcessCreateManyJobPostingInputEnvelope
    connect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
  }

  export type JobPostingLanguageUncheckedCreateNestedManyWithoutJobPostingInput = {
    create?: XOR<JobPostingLanguageCreateWithoutJobPostingInput, JobPostingLanguageUncheckedCreateWithoutJobPostingInput> | JobPostingLanguageCreateWithoutJobPostingInput[] | JobPostingLanguageUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingLanguageCreateOrConnectWithoutJobPostingInput | JobPostingLanguageCreateOrConnectWithoutJobPostingInput[]
    createMany?: JobPostingLanguageCreateManyJobPostingInputEnvelope
    connect?: JobPostingLanguageWhereUniqueInput | JobPostingLanguageWhereUniqueInput[]
  }

  export type JobPostingRequirementUncheckedCreateNestedManyWithoutJobPostingInput = {
    create?: XOR<JobPostingRequirementCreateWithoutJobPostingInput, JobPostingRequirementUncheckedCreateWithoutJobPostingInput> | JobPostingRequirementCreateWithoutJobPostingInput[] | JobPostingRequirementUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingRequirementCreateOrConnectWithoutJobPostingInput | JobPostingRequirementCreateOrConnectWithoutJobPostingInput[]
    createMany?: JobPostingRequirementCreateManyJobPostingInputEnvelope
    connect?: JobPostingRequirementWhereUniqueInput | JobPostingRequirementWhereUniqueInput[]
  }

  export type JobPostingMeritUncheckedCreateNestedManyWithoutJobPostingInput = {
    create?: XOR<JobPostingMeritCreateWithoutJobPostingInput, JobPostingMeritUncheckedCreateWithoutJobPostingInput> | JobPostingMeritCreateWithoutJobPostingInput[] | JobPostingMeritUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingMeritCreateOrConnectWithoutJobPostingInput | JobPostingMeritCreateOrConnectWithoutJobPostingInput[]
    createMany?: JobPostingMeritCreateManyJobPostingInputEnvelope
    connect?: JobPostingMeritWhereUniqueInput | JobPostingMeritWhereUniqueInput[]
  }

  export type JobPostingApplicantQualityUncheckedCreateNestedManyWithoutJobPostingInput = {
    create?: XOR<JobPostingApplicantQualityCreateWithoutJobPostingInput, JobPostingApplicantQualityUncheckedCreateWithoutJobPostingInput> | JobPostingApplicantQualityCreateWithoutJobPostingInput[] | JobPostingApplicantQualityUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingApplicantQualityCreateOrConnectWithoutJobPostingInput | JobPostingApplicantQualityCreateOrConnectWithoutJobPostingInput[]
    createMany?: JobPostingApplicantQualityCreateManyJobPostingInputEnvelope
    connect?: JobPostingApplicantQualityWhereUniqueInput | JobPostingApplicantQualityWhereUniqueInput[]
  }

  export type JobPostingLocationUncheckedCreateNestedOneWithoutJobPostingInput = {
    create?: XOR<JobPostingLocationCreateWithoutJobPostingInput, JobPostingLocationUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingLocationCreateOrConnectWithoutJobPostingInput
    connect?: JobPostingLocationWhereUniqueInput
  }

  export type JobPostingWorkArrengmentUncheckedCreateNestedOneWithoutJobPostingInput = {
    create?: XOR<JobPostingWorkArrengmentCreateWithoutJobPostingInput, JobPostingWorkArrengmentUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingWorkArrengmentCreateOrConnectWithoutJobPostingInput
    connect?: JobPostingWorkArrengmentWhereUniqueInput
  }

  export type JobPostingEmploymentTypeUncheckedCreateNestedOneWithoutJobPostingInput = {
    create?: XOR<JobPostingEmploymentTypeCreateWithoutJobPostingInput, JobPostingEmploymentTypeUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingEmploymentTypeCreateOrConnectWithoutJobPostingInput
    connect?: JobPostingEmploymentTypeWhereUniqueInput
  }

  export type JobPostingSalaryUncheckedCreateNestedOneWithoutJobPostingInput = {
    create?: XOR<JobPostingSalaryCreateWithoutJobPostingInput, JobPostingSalaryUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingSalaryCreateOrConnectWithoutJobPostingInput
    connect?: JobPostingSalaryWhereUniqueInput
  }

  export type CreatedJobPostingUncheckedCreateNestedOneWithoutJobPostingInput = {
    create?: XOR<CreatedJobPostingCreateWithoutJobPostingInput, CreatedJobPostingUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: CreatedJobPostingCreateOrConnectWithoutJobPostingInput
    connect?: CreatedJobPostingWhereUniqueInput
  }

  export type JobApplicantsUncheckedCreateNestedManyWithoutJobPostingInput = {
    create?: XOR<JobApplicantsCreateWithoutJobPostingInput, JobApplicantsUncheckedCreateWithoutJobPostingInput> | JobApplicantsCreateWithoutJobPostingInput[] | JobApplicantsUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobApplicantsCreateOrConnectWithoutJobPostingInput | JobApplicantsCreateOrConnectWithoutJobPostingInput[]
    createMany?: JobApplicantsCreateManyJobPostingInputEnvelope
    connect?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
  }

  export type UserProcessUncheckedCreateNestedManyWithoutJobPostingInput = {
    create?: XOR<UserProcessCreateWithoutJobPostingInput, UserProcessUncheckedCreateWithoutJobPostingInput> | UserProcessCreateWithoutJobPostingInput[] | UserProcessUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: UserProcessCreateOrConnectWithoutJobPostingInput | UserProcessCreateOrConnectWithoutJobPostingInput[]
    createMany?: UserProcessCreateManyJobPostingInputEnvelope
    connect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
  }

  export type JobPostingLanguageUpdateManyWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingLanguageCreateWithoutJobPostingInput, JobPostingLanguageUncheckedCreateWithoutJobPostingInput> | JobPostingLanguageCreateWithoutJobPostingInput[] | JobPostingLanguageUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingLanguageCreateOrConnectWithoutJobPostingInput | JobPostingLanguageCreateOrConnectWithoutJobPostingInput[]
    upsert?: JobPostingLanguageUpsertWithWhereUniqueWithoutJobPostingInput | JobPostingLanguageUpsertWithWhereUniqueWithoutJobPostingInput[]
    createMany?: JobPostingLanguageCreateManyJobPostingInputEnvelope
    set?: JobPostingLanguageWhereUniqueInput | JobPostingLanguageWhereUniqueInput[]
    disconnect?: JobPostingLanguageWhereUniqueInput | JobPostingLanguageWhereUniqueInput[]
    delete?: JobPostingLanguageWhereUniqueInput | JobPostingLanguageWhereUniqueInput[]
    connect?: JobPostingLanguageWhereUniqueInput | JobPostingLanguageWhereUniqueInput[]
    update?: JobPostingLanguageUpdateWithWhereUniqueWithoutJobPostingInput | JobPostingLanguageUpdateWithWhereUniqueWithoutJobPostingInput[]
    updateMany?: JobPostingLanguageUpdateManyWithWhereWithoutJobPostingInput | JobPostingLanguageUpdateManyWithWhereWithoutJobPostingInput[]
    deleteMany?: JobPostingLanguageScalarWhereInput | JobPostingLanguageScalarWhereInput[]
  }

  export type JobPostingRequirementUpdateManyWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingRequirementCreateWithoutJobPostingInput, JobPostingRequirementUncheckedCreateWithoutJobPostingInput> | JobPostingRequirementCreateWithoutJobPostingInput[] | JobPostingRequirementUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingRequirementCreateOrConnectWithoutJobPostingInput | JobPostingRequirementCreateOrConnectWithoutJobPostingInput[]
    upsert?: JobPostingRequirementUpsertWithWhereUniqueWithoutJobPostingInput | JobPostingRequirementUpsertWithWhereUniqueWithoutJobPostingInput[]
    createMany?: JobPostingRequirementCreateManyJobPostingInputEnvelope
    set?: JobPostingRequirementWhereUniqueInput | JobPostingRequirementWhereUniqueInput[]
    disconnect?: JobPostingRequirementWhereUniqueInput | JobPostingRequirementWhereUniqueInput[]
    delete?: JobPostingRequirementWhereUniqueInput | JobPostingRequirementWhereUniqueInput[]
    connect?: JobPostingRequirementWhereUniqueInput | JobPostingRequirementWhereUniqueInput[]
    update?: JobPostingRequirementUpdateWithWhereUniqueWithoutJobPostingInput | JobPostingRequirementUpdateWithWhereUniqueWithoutJobPostingInput[]
    updateMany?: JobPostingRequirementUpdateManyWithWhereWithoutJobPostingInput | JobPostingRequirementUpdateManyWithWhereWithoutJobPostingInput[]
    deleteMany?: JobPostingRequirementScalarWhereInput | JobPostingRequirementScalarWhereInput[]
  }

  export type JobPostingMeritUpdateManyWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingMeritCreateWithoutJobPostingInput, JobPostingMeritUncheckedCreateWithoutJobPostingInput> | JobPostingMeritCreateWithoutJobPostingInput[] | JobPostingMeritUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingMeritCreateOrConnectWithoutJobPostingInput | JobPostingMeritCreateOrConnectWithoutJobPostingInput[]
    upsert?: JobPostingMeritUpsertWithWhereUniqueWithoutJobPostingInput | JobPostingMeritUpsertWithWhereUniqueWithoutJobPostingInput[]
    createMany?: JobPostingMeritCreateManyJobPostingInputEnvelope
    set?: JobPostingMeritWhereUniqueInput | JobPostingMeritWhereUniqueInput[]
    disconnect?: JobPostingMeritWhereUniqueInput | JobPostingMeritWhereUniqueInput[]
    delete?: JobPostingMeritWhereUniqueInput | JobPostingMeritWhereUniqueInput[]
    connect?: JobPostingMeritWhereUniqueInput | JobPostingMeritWhereUniqueInput[]
    update?: JobPostingMeritUpdateWithWhereUniqueWithoutJobPostingInput | JobPostingMeritUpdateWithWhereUniqueWithoutJobPostingInput[]
    updateMany?: JobPostingMeritUpdateManyWithWhereWithoutJobPostingInput | JobPostingMeritUpdateManyWithWhereWithoutJobPostingInput[]
    deleteMany?: JobPostingMeritScalarWhereInput | JobPostingMeritScalarWhereInput[]
  }

  export type JobPostingApplicantQualityUpdateManyWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingApplicantQualityCreateWithoutJobPostingInput, JobPostingApplicantQualityUncheckedCreateWithoutJobPostingInput> | JobPostingApplicantQualityCreateWithoutJobPostingInput[] | JobPostingApplicantQualityUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingApplicantQualityCreateOrConnectWithoutJobPostingInput | JobPostingApplicantQualityCreateOrConnectWithoutJobPostingInput[]
    upsert?: JobPostingApplicantQualityUpsertWithWhereUniqueWithoutJobPostingInput | JobPostingApplicantQualityUpsertWithWhereUniqueWithoutJobPostingInput[]
    createMany?: JobPostingApplicantQualityCreateManyJobPostingInputEnvelope
    set?: JobPostingApplicantQualityWhereUniqueInput | JobPostingApplicantQualityWhereUniqueInput[]
    disconnect?: JobPostingApplicantQualityWhereUniqueInput | JobPostingApplicantQualityWhereUniqueInput[]
    delete?: JobPostingApplicantQualityWhereUniqueInput | JobPostingApplicantQualityWhereUniqueInput[]
    connect?: JobPostingApplicantQualityWhereUniqueInput | JobPostingApplicantQualityWhereUniqueInput[]
    update?: JobPostingApplicantQualityUpdateWithWhereUniqueWithoutJobPostingInput | JobPostingApplicantQualityUpdateWithWhereUniqueWithoutJobPostingInput[]
    updateMany?: JobPostingApplicantQualityUpdateManyWithWhereWithoutJobPostingInput | JobPostingApplicantQualityUpdateManyWithWhereWithoutJobPostingInput[]
    deleteMany?: JobPostingApplicantQualityScalarWhereInput | JobPostingApplicantQualityScalarWhereInput[]
  }

  export type JobPostingLocationUpdateOneWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingLocationCreateWithoutJobPostingInput, JobPostingLocationUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingLocationCreateOrConnectWithoutJobPostingInput
    upsert?: JobPostingLocationUpsertWithoutJobPostingInput
    disconnect?: JobPostingLocationWhereInput | boolean
    delete?: JobPostingLocationWhereInput | boolean
    connect?: JobPostingLocationWhereUniqueInput
    update?: XOR<XOR<JobPostingLocationUpdateToOneWithWhereWithoutJobPostingInput, JobPostingLocationUpdateWithoutJobPostingInput>, JobPostingLocationUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobPostingWorkArrengmentUpdateOneWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingWorkArrengmentCreateWithoutJobPostingInput, JobPostingWorkArrengmentUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingWorkArrengmentCreateOrConnectWithoutJobPostingInput
    upsert?: JobPostingWorkArrengmentUpsertWithoutJobPostingInput
    disconnect?: JobPostingWorkArrengmentWhereInput | boolean
    delete?: JobPostingWorkArrengmentWhereInput | boolean
    connect?: JobPostingWorkArrengmentWhereUniqueInput
    update?: XOR<XOR<JobPostingWorkArrengmentUpdateToOneWithWhereWithoutJobPostingInput, JobPostingWorkArrengmentUpdateWithoutJobPostingInput>, JobPostingWorkArrengmentUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobPostingEmploymentTypeUpdateOneWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingEmploymentTypeCreateWithoutJobPostingInput, JobPostingEmploymentTypeUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingEmploymentTypeCreateOrConnectWithoutJobPostingInput
    upsert?: JobPostingEmploymentTypeUpsertWithoutJobPostingInput
    disconnect?: JobPostingEmploymentTypeWhereInput | boolean
    delete?: JobPostingEmploymentTypeWhereInput | boolean
    connect?: JobPostingEmploymentTypeWhereUniqueInput
    update?: XOR<XOR<JobPostingEmploymentTypeUpdateToOneWithWhereWithoutJobPostingInput, JobPostingEmploymentTypeUpdateWithoutJobPostingInput>, JobPostingEmploymentTypeUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobPostingSalaryUpdateOneWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingSalaryCreateWithoutJobPostingInput, JobPostingSalaryUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingSalaryCreateOrConnectWithoutJobPostingInput
    upsert?: JobPostingSalaryUpsertWithoutJobPostingInput
    disconnect?: JobPostingSalaryWhereInput | boolean
    delete?: JobPostingSalaryWhereInput | boolean
    connect?: JobPostingSalaryWhereUniqueInput
    update?: XOR<XOR<JobPostingSalaryUpdateToOneWithWhereWithoutJobPostingInput, JobPostingSalaryUpdateWithoutJobPostingInput>, JobPostingSalaryUncheckedUpdateWithoutJobPostingInput>
  }

  export type CreatedJobPostingUpdateOneWithoutJobPostingNestedInput = {
    create?: XOR<CreatedJobPostingCreateWithoutJobPostingInput, CreatedJobPostingUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: CreatedJobPostingCreateOrConnectWithoutJobPostingInput
    upsert?: CreatedJobPostingUpsertWithoutJobPostingInput
    disconnect?: CreatedJobPostingWhereInput | boolean
    delete?: CreatedJobPostingWhereInput | boolean
    connect?: CreatedJobPostingWhereUniqueInput
    update?: XOR<XOR<CreatedJobPostingUpdateToOneWithWhereWithoutJobPostingInput, CreatedJobPostingUpdateWithoutJobPostingInput>, CreatedJobPostingUncheckedUpdateWithoutJobPostingInput>
  }

  export type CompanyUpdateOneWithoutJobPostingsNestedInput = {
    create?: XOR<CompanyCreateWithoutJobPostingsInput, CompanyUncheckedCreateWithoutJobPostingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJobPostingsInput
    upsert?: CompanyUpsertWithoutJobPostingsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutJobPostingsInput, CompanyUpdateWithoutJobPostingsInput>, CompanyUncheckedUpdateWithoutJobPostingsInput>
  }

  export type JobApplicantsUpdateManyWithoutJobPostingNestedInput = {
    create?: XOR<JobApplicantsCreateWithoutJobPostingInput, JobApplicantsUncheckedCreateWithoutJobPostingInput> | JobApplicantsCreateWithoutJobPostingInput[] | JobApplicantsUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobApplicantsCreateOrConnectWithoutJobPostingInput | JobApplicantsCreateOrConnectWithoutJobPostingInput[]
    upsert?: JobApplicantsUpsertWithWhereUniqueWithoutJobPostingInput | JobApplicantsUpsertWithWhereUniqueWithoutJobPostingInput[]
    createMany?: JobApplicantsCreateManyJobPostingInputEnvelope
    set?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    disconnect?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    delete?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    connect?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    update?: JobApplicantsUpdateWithWhereUniqueWithoutJobPostingInput | JobApplicantsUpdateWithWhereUniqueWithoutJobPostingInput[]
    updateMany?: JobApplicantsUpdateManyWithWhereWithoutJobPostingInput | JobApplicantsUpdateManyWithWhereWithoutJobPostingInput[]
    deleteMany?: JobApplicantsScalarWhereInput | JobApplicantsScalarWhereInput[]
  }

  export type UserProcessUpdateManyWithoutJobPostingNestedInput = {
    create?: XOR<UserProcessCreateWithoutJobPostingInput, UserProcessUncheckedCreateWithoutJobPostingInput> | UserProcessCreateWithoutJobPostingInput[] | UserProcessUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: UserProcessCreateOrConnectWithoutJobPostingInput | UserProcessCreateOrConnectWithoutJobPostingInput[]
    upsert?: UserProcessUpsertWithWhereUniqueWithoutJobPostingInput | UserProcessUpsertWithWhereUniqueWithoutJobPostingInput[]
    createMany?: UserProcessCreateManyJobPostingInputEnvelope
    set?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    disconnect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    delete?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    connect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    update?: UserProcessUpdateWithWhereUniqueWithoutJobPostingInput | UserProcessUpdateWithWhereUniqueWithoutJobPostingInput[]
    updateMany?: UserProcessUpdateManyWithWhereWithoutJobPostingInput | UserProcessUpdateManyWithWhereWithoutJobPostingInput[]
    deleteMany?: UserProcessScalarWhereInput | UserProcessScalarWhereInput[]
  }

  export type JobPostingLanguageUncheckedUpdateManyWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingLanguageCreateWithoutJobPostingInput, JobPostingLanguageUncheckedCreateWithoutJobPostingInput> | JobPostingLanguageCreateWithoutJobPostingInput[] | JobPostingLanguageUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingLanguageCreateOrConnectWithoutJobPostingInput | JobPostingLanguageCreateOrConnectWithoutJobPostingInput[]
    upsert?: JobPostingLanguageUpsertWithWhereUniqueWithoutJobPostingInput | JobPostingLanguageUpsertWithWhereUniqueWithoutJobPostingInput[]
    createMany?: JobPostingLanguageCreateManyJobPostingInputEnvelope
    set?: JobPostingLanguageWhereUniqueInput | JobPostingLanguageWhereUniqueInput[]
    disconnect?: JobPostingLanguageWhereUniqueInput | JobPostingLanguageWhereUniqueInput[]
    delete?: JobPostingLanguageWhereUniqueInput | JobPostingLanguageWhereUniqueInput[]
    connect?: JobPostingLanguageWhereUniqueInput | JobPostingLanguageWhereUniqueInput[]
    update?: JobPostingLanguageUpdateWithWhereUniqueWithoutJobPostingInput | JobPostingLanguageUpdateWithWhereUniqueWithoutJobPostingInput[]
    updateMany?: JobPostingLanguageUpdateManyWithWhereWithoutJobPostingInput | JobPostingLanguageUpdateManyWithWhereWithoutJobPostingInput[]
    deleteMany?: JobPostingLanguageScalarWhereInput | JobPostingLanguageScalarWhereInput[]
  }

  export type JobPostingRequirementUncheckedUpdateManyWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingRequirementCreateWithoutJobPostingInput, JobPostingRequirementUncheckedCreateWithoutJobPostingInput> | JobPostingRequirementCreateWithoutJobPostingInput[] | JobPostingRequirementUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingRequirementCreateOrConnectWithoutJobPostingInput | JobPostingRequirementCreateOrConnectWithoutJobPostingInput[]
    upsert?: JobPostingRequirementUpsertWithWhereUniqueWithoutJobPostingInput | JobPostingRequirementUpsertWithWhereUniqueWithoutJobPostingInput[]
    createMany?: JobPostingRequirementCreateManyJobPostingInputEnvelope
    set?: JobPostingRequirementWhereUniqueInput | JobPostingRequirementWhereUniqueInput[]
    disconnect?: JobPostingRequirementWhereUniqueInput | JobPostingRequirementWhereUniqueInput[]
    delete?: JobPostingRequirementWhereUniqueInput | JobPostingRequirementWhereUniqueInput[]
    connect?: JobPostingRequirementWhereUniqueInput | JobPostingRequirementWhereUniqueInput[]
    update?: JobPostingRequirementUpdateWithWhereUniqueWithoutJobPostingInput | JobPostingRequirementUpdateWithWhereUniqueWithoutJobPostingInput[]
    updateMany?: JobPostingRequirementUpdateManyWithWhereWithoutJobPostingInput | JobPostingRequirementUpdateManyWithWhereWithoutJobPostingInput[]
    deleteMany?: JobPostingRequirementScalarWhereInput | JobPostingRequirementScalarWhereInput[]
  }

  export type JobPostingMeritUncheckedUpdateManyWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingMeritCreateWithoutJobPostingInput, JobPostingMeritUncheckedCreateWithoutJobPostingInput> | JobPostingMeritCreateWithoutJobPostingInput[] | JobPostingMeritUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingMeritCreateOrConnectWithoutJobPostingInput | JobPostingMeritCreateOrConnectWithoutJobPostingInput[]
    upsert?: JobPostingMeritUpsertWithWhereUniqueWithoutJobPostingInput | JobPostingMeritUpsertWithWhereUniqueWithoutJobPostingInput[]
    createMany?: JobPostingMeritCreateManyJobPostingInputEnvelope
    set?: JobPostingMeritWhereUniqueInput | JobPostingMeritWhereUniqueInput[]
    disconnect?: JobPostingMeritWhereUniqueInput | JobPostingMeritWhereUniqueInput[]
    delete?: JobPostingMeritWhereUniqueInput | JobPostingMeritWhereUniqueInput[]
    connect?: JobPostingMeritWhereUniqueInput | JobPostingMeritWhereUniqueInput[]
    update?: JobPostingMeritUpdateWithWhereUniqueWithoutJobPostingInput | JobPostingMeritUpdateWithWhereUniqueWithoutJobPostingInput[]
    updateMany?: JobPostingMeritUpdateManyWithWhereWithoutJobPostingInput | JobPostingMeritUpdateManyWithWhereWithoutJobPostingInput[]
    deleteMany?: JobPostingMeritScalarWhereInput | JobPostingMeritScalarWhereInput[]
  }

  export type JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingApplicantQualityCreateWithoutJobPostingInput, JobPostingApplicantQualityUncheckedCreateWithoutJobPostingInput> | JobPostingApplicantQualityCreateWithoutJobPostingInput[] | JobPostingApplicantQualityUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobPostingApplicantQualityCreateOrConnectWithoutJobPostingInput | JobPostingApplicantQualityCreateOrConnectWithoutJobPostingInput[]
    upsert?: JobPostingApplicantQualityUpsertWithWhereUniqueWithoutJobPostingInput | JobPostingApplicantQualityUpsertWithWhereUniqueWithoutJobPostingInput[]
    createMany?: JobPostingApplicantQualityCreateManyJobPostingInputEnvelope
    set?: JobPostingApplicantQualityWhereUniqueInput | JobPostingApplicantQualityWhereUniqueInput[]
    disconnect?: JobPostingApplicantQualityWhereUniqueInput | JobPostingApplicantQualityWhereUniqueInput[]
    delete?: JobPostingApplicantQualityWhereUniqueInput | JobPostingApplicantQualityWhereUniqueInput[]
    connect?: JobPostingApplicantQualityWhereUniqueInput | JobPostingApplicantQualityWhereUniqueInput[]
    update?: JobPostingApplicantQualityUpdateWithWhereUniqueWithoutJobPostingInput | JobPostingApplicantQualityUpdateWithWhereUniqueWithoutJobPostingInput[]
    updateMany?: JobPostingApplicantQualityUpdateManyWithWhereWithoutJobPostingInput | JobPostingApplicantQualityUpdateManyWithWhereWithoutJobPostingInput[]
    deleteMany?: JobPostingApplicantQualityScalarWhereInput | JobPostingApplicantQualityScalarWhereInput[]
  }

  export type JobPostingLocationUncheckedUpdateOneWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingLocationCreateWithoutJobPostingInput, JobPostingLocationUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingLocationCreateOrConnectWithoutJobPostingInput
    upsert?: JobPostingLocationUpsertWithoutJobPostingInput
    disconnect?: JobPostingLocationWhereInput | boolean
    delete?: JobPostingLocationWhereInput | boolean
    connect?: JobPostingLocationWhereUniqueInput
    update?: XOR<XOR<JobPostingLocationUpdateToOneWithWhereWithoutJobPostingInput, JobPostingLocationUpdateWithoutJobPostingInput>, JobPostingLocationUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobPostingWorkArrengmentUncheckedUpdateOneWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingWorkArrengmentCreateWithoutJobPostingInput, JobPostingWorkArrengmentUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingWorkArrengmentCreateOrConnectWithoutJobPostingInput
    upsert?: JobPostingWorkArrengmentUpsertWithoutJobPostingInput
    disconnect?: JobPostingWorkArrengmentWhereInput | boolean
    delete?: JobPostingWorkArrengmentWhereInput | boolean
    connect?: JobPostingWorkArrengmentWhereUniqueInput
    update?: XOR<XOR<JobPostingWorkArrengmentUpdateToOneWithWhereWithoutJobPostingInput, JobPostingWorkArrengmentUpdateWithoutJobPostingInput>, JobPostingWorkArrengmentUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobPostingEmploymentTypeUncheckedUpdateOneWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingEmploymentTypeCreateWithoutJobPostingInput, JobPostingEmploymentTypeUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingEmploymentTypeCreateOrConnectWithoutJobPostingInput
    upsert?: JobPostingEmploymentTypeUpsertWithoutJobPostingInput
    disconnect?: JobPostingEmploymentTypeWhereInput | boolean
    delete?: JobPostingEmploymentTypeWhereInput | boolean
    connect?: JobPostingEmploymentTypeWhereUniqueInput
    update?: XOR<XOR<JobPostingEmploymentTypeUpdateToOneWithWhereWithoutJobPostingInput, JobPostingEmploymentTypeUpdateWithoutJobPostingInput>, JobPostingEmploymentTypeUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobPostingSalaryUncheckedUpdateOneWithoutJobPostingNestedInput = {
    create?: XOR<JobPostingSalaryCreateWithoutJobPostingInput, JobPostingSalaryUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: JobPostingSalaryCreateOrConnectWithoutJobPostingInput
    upsert?: JobPostingSalaryUpsertWithoutJobPostingInput
    disconnect?: JobPostingSalaryWhereInput | boolean
    delete?: JobPostingSalaryWhereInput | boolean
    connect?: JobPostingSalaryWhereUniqueInput
    update?: XOR<XOR<JobPostingSalaryUpdateToOneWithWhereWithoutJobPostingInput, JobPostingSalaryUpdateWithoutJobPostingInput>, JobPostingSalaryUncheckedUpdateWithoutJobPostingInput>
  }

  export type CreatedJobPostingUncheckedUpdateOneWithoutJobPostingNestedInput = {
    create?: XOR<CreatedJobPostingCreateWithoutJobPostingInput, CreatedJobPostingUncheckedCreateWithoutJobPostingInput>
    connectOrCreate?: CreatedJobPostingCreateOrConnectWithoutJobPostingInput
    upsert?: CreatedJobPostingUpsertWithoutJobPostingInput
    disconnect?: CreatedJobPostingWhereInput | boolean
    delete?: CreatedJobPostingWhereInput | boolean
    connect?: CreatedJobPostingWhereUniqueInput
    update?: XOR<XOR<CreatedJobPostingUpdateToOneWithWhereWithoutJobPostingInput, CreatedJobPostingUpdateWithoutJobPostingInput>, CreatedJobPostingUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobApplicantsUncheckedUpdateManyWithoutJobPostingNestedInput = {
    create?: XOR<JobApplicantsCreateWithoutJobPostingInput, JobApplicantsUncheckedCreateWithoutJobPostingInput> | JobApplicantsCreateWithoutJobPostingInput[] | JobApplicantsUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: JobApplicantsCreateOrConnectWithoutJobPostingInput | JobApplicantsCreateOrConnectWithoutJobPostingInput[]
    upsert?: JobApplicantsUpsertWithWhereUniqueWithoutJobPostingInput | JobApplicantsUpsertWithWhereUniqueWithoutJobPostingInput[]
    createMany?: JobApplicantsCreateManyJobPostingInputEnvelope
    set?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    disconnect?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    delete?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    connect?: JobApplicantsWhereUniqueInput | JobApplicantsWhereUniqueInput[]
    update?: JobApplicantsUpdateWithWhereUniqueWithoutJobPostingInput | JobApplicantsUpdateWithWhereUniqueWithoutJobPostingInput[]
    updateMany?: JobApplicantsUpdateManyWithWhereWithoutJobPostingInput | JobApplicantsUpdateManyWithWhereWithoutJobPostingInput[]
    deleteMany?: JobApplicantsScalarWhereInput | JobApplicantsScalarWhereInput[]
  }

  export type UserProcessUncheckedUpdateManyWithoutJobPostingNestedInput = {
    create?: XOR<UserProcessCreateWithoutJobPostingInput, UserProcessUncheckedCreateWithoutJobPostingInput> | UserProcessCreateWithoutJobPostingInput[] | UserProcessUncheckedCreateWithoutJobPostingInput[]
    connectOrCreate?: UserProcessCreateOrConnectWithoutJobPostingInput | UserProcessCreateOrConnectWithoutJobPostingInput[]
    upsert?: UserProcessUpsertWithWhereUniqueWithoutJobPostingInput | UserProcessUpsertWithWhereUniqueWithoutJobPostingInput[]
    createMany?: UserProcessCreateManyJobPostingInputEnvelope
    set?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    disconnect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    delete?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    connect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    update?: UserProcessUpdateWithWhereUniqueWithoutJobPostingInput | UserProcessUpdateWithWhereUniqueWithoutJobPostingInput[]
    updateMany?: UserProcessUpdateManyWithWhereWithoutJobPostingInput | UserProcessUpdateManyWithWhereWithoutJobPostingInput[]
    deleteMany?: UserProcessScalarWhereInput | UserProcessScalarWhereInput[]
  }

  export type JobPostingCreateNestedOneWithoutLanguageInput = {
    create?: XOR<JobPostingCreateWithoutLanguageInput, JobPostingUncheckedCreateWithoutLanguageInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutLanguageInput
    connect?: JobPostingWhereUniqueInput
  }

  export type JobPostingUpdateOneRequiredWithoutLanguageNestedInput = {
    create?: XOR<JobPostingCreateWithoutLanguageInput, JobPostingUncheckedCreateWithoutLanguageInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutLanguageInput
    upsert?: JobPostingUpsertWithoutLanguageInput
    connect?: JobPostingWhereUniqueInput
    update?: XOR<XOR<JobPostingUpdateToOneWithWhereWithoutLanguageInput, JobPostingUpdateWithoutLanguageInput>, JobPostingUncheckedUpdateWithoutLanguageInput>
  }

  export type JobPostingCreateNestedOneWithoutJobRequirementsInput = {
    create?: XOR<JobPostingCreateWithoutJobRequirementsInput, JobPostingUncheckedCreateWithoutJobRequirementsInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutJobRequirementsInput
    connect?: JobPostingWhereUniqueInput
  }

  export type JobPostingUpdateOneRequiredWithoutJobRequirementsNestedInput = {
    create?: XOR<JobPostingCreateWithoutJobRequirementsInput, JobPostingUncheckedCreateWithoutJobRequirementsInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutJobRequirementsInput
    upsert?: JobPostingUpsertWithoutJobRequirementsInput
    connect?: JobPostingWhereUniqueInput
    update?: XOR<XOR<JobPostingUpdateToOneWithWhereWithoutJobRequirementsInput, JobPostingUpdateWithoutJobRequirementsInput>, JobPostingUncheckedUpdateWithoutJobRequirementsInput>
  }

  export type JobPostingCreateNestedOneWithoutMeritsInput = {
    create?: XOR<JobPostingCreateWithoutMeritsInput, JobPostingUncheckedCreateWithoutMeritsInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutMeritsInput
    connect?: JobPostingWhereUniqueInput
  }

  export type JobPostingUpdateOneRequiredWithoutMeritsNestedInput = {
    create?: XOR<JobPostingCreateWithoutMeritsInput, JobPostingUncheckedCreateWithoutMeritsInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutMeritsInput
    upsert?: JobPostingUpsertWithoutMeritsInput
    connect?: JobPostingWhereUniqueInput
    update?: XOR<XOR<JobPostingUpdateToOneWithWhereWithoutMeritsInput, JobPostingUpdateWithoutMeritsInput>, JobPostingUncheckedUpdateWithoutMeritsInput>
  }

  export type JobPostingCreateNestedOneWithoutApplicantQualitiesInput = {
    create?: XOR<JobPostingCreateWithoutApplicantQualitiesInput, JobPostingUncheckedCreateWithoutApplicantQualitiesInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutApplicantQualitiesInput
    connect?: JobPostingWhereUniqueInput
  }

  export type JobPostingUpdateOneRequiredWithoutApplicantQualitiesNestedInput = {
    create?: XOR<JobPostingCreateWithoutApplicantQualitiesInput, JobPostingUncheckedCreateWithoutApplicantQualitiesInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutApplicantQualitiesInput
    upsert?: JobPostingUpsertWithoutApplicantQualitiesInput
    connect?: JobPostingWhereUniqueInput
    update?: XOR<XOR<JobPostingUpdateToOneWithWhereWithoutApplicantQualitiesInput, JobPostingUpdateWithoutApplicantQualitiesInput>, JobPostingUncheckedUpdateWithoutApplicantQualitiesInput>
  }

  export type JobPostingCreateNestedOneWithoutLocationInput = {
    create?: XOR<JobPostingCreateWithoutLocationInput, JobPostingUncheckedCreateWithoutLocationInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutLocationInput
    connect?: JobPostingWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobPostingUpdateOneRequiredWithoutLocationNestedInput = {
    create?: XOR<JobPostingCreateWithoutLocationInput, JobPostingUncheckedCreateWithoutLocationInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutLocationInput
    upsert?: JobPostingUpsertWithoutLocationInput
    connect?: JobPostingWhereUniqueInput
    update?: XOR<XOR<JobPostingUpdateToOneWithWhereWithoutLocationInput, JobPostingUpdateWithoutLocationInput>, JobPostingUncheckedUpdateWithoutLocationInput>
  }

  export type JobPostingCreateNestedOneWithoutWorkArrengmentInput = {
    create?: XOR<JobPostingCreateWithoutWorkArrengmentInput, JobPostingUncheckedCreateWithoutWorkArrengmentInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutWorkArrengmentInput
    connect?: JobPostingWhereUniqueInput
  }

  export type JobPostingUpdateOneRequiredWithoutWorkArrengmentNestedInput = {
    create?: XOR<JobPostingCreateWithoutWorkArrengmentInput, JobPostingUncheckedCreateWithoutWorkArrengmentInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutWorkArrengmentInput
    upsert?: JobPostingUpsertWithoutWorkArrengmentInput
    connect?: JobPostingWhereUniqueInput
    update?: XOR<XOR<JobPostingUpdateToOneWithWhereWithoutWorkArrengmentInput, JobPostingUpdateWithoutWorkArrengmentInput>, JobPostingUncheckedUpdateWithoutWorkArrengmentInput>
  }

  export type JobPostingCreateNestedOneWithoutEmploymentTypeInput = {
    create?: XOR<JobPostingCreateWithoutEmploymentTypeInput, JobPostingUncheckedCreateWithoutEmploymentTypeInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutEmploymentTypeInput
    connect?: JobPostingWhereUniqueInput
  }

  export type JobPostingUpdateOneRequiredWithoutEmploymentTypeNestedInput = {
    create?: XOR<JobPostingCreateWithoutEmploymentTypeInput, JobPostingUncheckedCreateWithoutEmploymentTypeInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutEmploymentTypeInput
    upsert?: JobPostingUpsertWithoutEmploymentTypeInput
    connect?: JobPostingWhereUniqueInput
    update?: XOR<XOR<JobPostingUpdateToOneWithWhereWithoutEmploymentTypeInput, JobPostingUpdateWithoutEmploymentTypeInput>, JobPostingUncheckedUpdateWithoutEmploymentTypeInput>
  }

  export type JobPostingSalaryCreatebenefitsInput = {
    set: string[]
  }

  export type JobPostingCreateNestedOneWithoutSalaryInput = {
    create?: XOR<JobPostingCreateWithoutSalaryInput, JobPostingUncheckedCreateWithoutSalaryInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutSalaryInput
    connect?: JobPostingWhereUniqueInput
  }

  export type JobPostingSalaryUpdatebenefitsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type JobPostingUpdateOneRequiredWithoutSalaryNestedInput = {
    create?: XOR<JobPostingCreateWithoutSalaryInput, JobPostingUncheckedCreateWithoutSalaryInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutSalaryInput
    upsert?: JobPostingUpsertWithoutSalaryInput
    connect?: JobPostingWhereUniqueInput
    update?: XOR<XOR<JobPostingUpdateToOneWithWhereWithoutSalaryInput, JobPostingUpdateWithoutSalaryInput>, JobPostingUncheckedUpdateWithoutSalaryInput>
  }

  export type JobPostingCreateNestedOneWithoutCreatedJobPostingInput = {
    create?: XOR<JobPostingCreateWithoutCreatedJobPostingInput, JobPostingUncheckedCreateWithoutCreatedJobPostingInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutCreatedJobPostingInput
    connect?: JobPostingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedJobPostingsInput = {
    create?: XOR<UserCreateWithoutCreatedJobPostingsInput, UserUncheckedCreateWithoutCreatedJobPostingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedJobPostingsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCreatedByEnumFieldUpdateOperationsInput = {
    set?: $Enums.CreatedByEnum
  }

  export type NullableEnumJobSourceEnumFieldUpdateOperationsInput = {
    set?: $Enums.JobSourceEnum | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type JobPostingUpdateOneRequiredWithoutCreatedJobPostingNestedInput = {
    create?: XOR<JobPostingCreateWithoutCreatedJobPostingInput, JobPostingUncheckedCreateWithoutCreatedJobPostingInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutCreatedJobPostingInput
    upsert?: JobPostingUpsertWithoutCreatedJobPostingInput
    connect?: JobPostingWhereUniqueInput
    update?: XOR<XOR<JobPostingUpdateToOneWithWhereWithoutCreatedJobPostingInput, JobPostingUpdateWithoutCreatedJobPostingInput>, JobPostingUncheckedUpdateWithoutCreatedJobPostingInput>
  }

  export type UserUpdateOneWithoutCreatedJobPostingsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedJobPostingsInput, UserUncheckedCreateWithoutCreatedJobPostingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedJobPostingsInput
    upsert?: UserUpsertWithoutCreatedJobPostingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedJobPostingsInput, UserUpdateWithoutCreatedJobPostingsInput>, UserUncheckedUpdateWithoutCreatedJobPostingsInput>
  }

  export type UserCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type JobPostingCreateNestedOneWithoutUserJobApplicationsInput = {
    create?: XOR<JobPostingCreateWithoutUserJobApplicationsInput, JobPostingUncheckedCreateWithoutUserJobApplicationsInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutUserJobApplicationsInput
    connect?: JobPostingWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput
    upsert?: UserUpsertWithoutApplicationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApplicationsInput, UserUpdateWithoutApplicationsInput>, UserUncheckedUpdateWithoutApplicationsInput>
  }

  export type JobPostingUpdateOneRequiredWithoutUserJobApplicationsNestedInput = {
    create?: XOR<JobPostingCreateWithoutUserJobApplicationsInput, JobPostingUncheckedCreateWithoutUserJobApplicationsInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutUserJobApplicationsInput
    upsert?: JobPostingUpsertWithoutUserJobApplicationsInput
    connect?: JobPostingWhereUniqueInput
    update?: XOR<XOR<JobPostingUpdateToOneWithWhereWithoutUserJobApplicationsInput, JobPostingUpdateWithoutUserJobApplicationsInput>, JobPostingUncheckedUpdateWithoutUserJobApplicationsInput>
  }

  export type UserCreateNestedOneWithoutUserProcessInput = {
    create?: XOR<UserCreateWithoutUserProcessInput, UserUncheckedCreateWithoutUserProcessInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProcessInput
    connect?: UserWhereUniqueInput
  }

  export type UserProcessStepCreateNestedManyWithoutProcessInput = {
    create?: XOR<UserProcessStepCreateWithoutProcessInput, UserProcessStepUncheckedCreateWithoutProcessInput> | UserProcessStepCreateWithoutProcessInput[] | UserProcessStepUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: UserProcessStepCreateOrConnectWithoutProcessInput | UserProcessStepCreateOrConnectWithoutProcessInput[]
    createMany?: UserProcessStepCreateManyProcessInputEnvelope
    connect?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
  }

  export type JobPostingCreateNestedOneWithoutUserProcessesInput = {
    create?: XOR<JobPostingCreateWithoutUserProcessesInput, JobPostingUncheckedCreateWithoutUserProcessesInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutUserProcessesInput
    connect?: JobPostingWhereUniqueInput
  }

  export type ProcessCreateNestedOneWithoutProcessesInput = {
    create?: XOR<ProcessCreateWithoutProcessesInput, ProcessUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutProcessesInput
    connect?: ProcessWhereUniqueInput
  }

  export type TodoUserProcessCreateNestedManyWithoutUserProcessInput = {
    create?: XOR<TodoUserProcessCreateWithoutUserProcessInput, TodoUserProcessUncheckedCreateWithoutUserProcessInput> | TodoUserProcessCreateWithoutUserProcessInput[] | TodoUserProcessUncheckedCreateWithoutUserProcessInput[]
    connectOrCreate?: TodoUserProcessCreateOrConnectWithoutUserProcessInput | TodoUserProcessCreateOrConnectWithoutUserProcessInput[]
    createMany?: TodoUserProcessCreateManyUserProcessInputEnvelope
    connect?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
  }

  export type UserProcessStepUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<UserProcessStepCreateWithoutProcessInput, UserProcessStepUncheckedCreateWithoutProcessInput> | UserProcessStepCreateWithoutProcessInput[] | UserProcessStepUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: UserProcessStepCreateOrConnectWithoutProcessInput | UserProcessStepCreateOrConnectWithoutProcessInput[]
    createMany?: UserProcessStepCreateManyProcessInputEnvelope
    connect?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
  }

  export type TodoUserProcessUncheckedCreateNestedManyWithoutUserProcessInput = {
    create?: XOR<TodoUserProcessCreateWithoutUserProcessInput, TodoUserProcessUncheckedCreateWithoutUserProcessInput> | TodoUserProcessCreateWithoutUserProcessInput[] | TodoUserProcessUncheckedCreateWithoutUserProcessInput[]
    connectOrCreate?: TodoUserProcessCreateOrConnectWithoutUserProcessInput | TodoUserProcessCreateOrConnectWithoutUserProcessInput[]
    createMany?: TodoUserProcessCreateManyUserProcessInputEnvelope
    connect?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
  }

  export type EnumStatusUserJobProcessesFieldUpdateOperationsInput = {
    set?: $Enums.StatusUserJobProcesses
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutUserProcessNestedInput = {
    create?: XOR<UserCreateWithoutUserProcessInput, UserUncheckedCreateWithoutUserProcessInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProcessInput
    upsert?: UserUpsertWithoutUserProcessInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserProcessInput, UserUpdateWithoutUserProcessInput>, UserUncheckedUpdateWithoutUserProcessInput>
  }

  export type UserProcessStepUpdateManyWithoutProcessNestedInput = {
    create?: XOR<UserProcessStepCreateWithoutProcessInput, UserProcessStepUncheckedCreateWithoutProcessInput> | UserProcessStepCreateWithoutProcessInput[] | UserProcessStepUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: UserProcessStepCreateOrConnectWithoutProcessInput | UserProcessStepCreateOrConnectWithoutProcessInput[]
    upsert?: UserProcessStepUpsertWithWhereUniqueWithoutProcessInput | UserProcessStepUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: UserProcessStepCreateManyProcessInputEnvelope
    set?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    disconnect?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    delete?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    connect?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    update?: UserProcessStepUpdateWithWhereUniqueWithoutProcessInput | UserProcessStepUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: UserProcessStepUpdateManyWithWhereWithoutProcessInput | UserProcessStepUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: UserProcessStepScalarWhereInput | UserProcessStepScalarWhereInput[]
  }

  export type JobPostingUpdateOneWithoutUserProcessesNestedInput = {
    create?: XOR<JobPostingCreateWithoutUserProcessesInput, JobPostingUncheckedCreateWithoutUserProcessesInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutUserProcessesInput
    upsert?: JobPostingUpsertWithoutUserProcessesInput
    disconnect?: JobPostingWhereInput | boolean
    delete?: JobPostingWhereInput | boolean
    connect?: JobPostingWhereUniqueInput
    update?: XOR<XOR<JobPostingUpdateToOneWithWhereWithoutUserProcessesInput, JobPostingUpdateWithoutUserProcessesInput>, JobPostingUncheckedUpdateWithoutUserProcessesInput>
  }

  export type ProcessUpdateOneWithoutProcessesNestedInput = {
    create?: XOR<ProcessCreateWithoutProcessesInput, ProcessUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutProcessesInput
    upsert?: ProcessUpsertWithoutProcessesInput
    disconnect?: ProcessWhereInput | boolean
    delete?: ProcessWhereInput | boolean
    connect?: ProcessWhereUniqueInput
    update?: XOR<XOR<ProcessUpdateToOneWithWhereWithoutProcessesInput, ProcessUpdateWithoutProcessesInput>, ProcessUncheckedUpdateWithoutProcessesInput>
  }

  export type TodoUserProcessUpdateManyWithoutUserProcessNestedInput = {
    create?: XOR<TodoUserProcessCreateWithoutUserProcessInput, TodoUserProcessUncheckedCreateWithoutUserProcessInput> | TodoUserProcessCreateWithoutUserProcessInput[] | TodoUserProcessUncheckedCreateWithoutUserProcessInput[]
    connectOrCreate?: TodoUserProcessCreateOrConnectWithoutUserProcessInput | TodoUserProcessCreateOrConnectWithoutUserProcessInput[]
    upsert?: TodoUserProcessUpsertWithWhereUniqueWithoutUserProcessInput | TodoUserProcessUpsertWithWhereUniqueWithoutUserProcessInput[]
    createMany?: TodoUserProcessCreateManyUserProcessInputEnvelope
    set?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    disconnect?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    delete?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    connect?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    update?: TodoUserProcessUpdateWithWhereUniqueWithoutUserProcessInput | TodoUserProcessUpdateWithWhereUniqueWithoutUserProcessInput[]
    updateMany?: TodoUserProcessUpdateManyWithWhereWithoutUserProcessInput | TodoUserProcessUpdateManyWithWhereWithoutUserProcessInput[]
    deleteMany?: TodoUserProcessScalarWhereInput | TodoUserProcessScalarWhereInput[]
  }

  export type UserProcessStepUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<UserProcessStepCreateWithoutProcessInput, UserProcessStepUncheckedCreateWithoutProcessInput> | UserProcessStepCreateWithoutProcessInput[] | UserProcessStepUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: UserProcessStepCreateOrConnectWithoutProcessInput | UserProcessStepCreateOrConnectWithoutProcessInput[]
    upsert?: UserProcessStepUpsertWithWhereUniqueWithoutProcessInput | UserProcessStepUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: UserProcessStepCreateManyProcessInputEnvelope
    set?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    disconnect?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    delete?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    connect?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    update?: UserProcessStepUpdateWithWhereUniqueWithoutProcessInput | UserProcessStepUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: UserProcessStepUpdateManyWithWhereWithoutProcessInput | UserProcessStepUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: UserProcessStepScalarWhereInput | UserProcessStepScalarWhereInput[]
  }

  export type TodoUserProcessUncheckedUpdateManyWithoutUserProcessNestedInput = {
    create?: XOR<TodoUserProcessCreateWithoutUserProcessInput, TodoUserProcessUncheckedCreateWithoutUserProcessInput> | TodoUserProcessCreateWithoutUserProcessInput[] | TodoUserProcessUncheckedCreateWithoutUserProcessInput[]
    connectOrCreate?: TodoUserProcessCreateOrConnectWithoutUserProcessInput | TodoUserProcessCreateOrConnectWithoutUserProcessInput[]
    upsert?: TodoUserProcessUpsertWithWhereUniqueWithoutUserProcessInput | TodoUserProcessUpsertWithWhereUniqueWithoutUserProcessInput[]
    createMany?: TodoUserProcessCreateManyUserProcessInputEnvelope
    set?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    disconnect?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    delete?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    connect?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    update?: TodoUserProcessUpdateWithWhereUniqueWithoutUserProcessInput | TodoUserProcessUpdateWithWhereUniqueWithoutUserProcessInput[]
    updateMany?: TodoUserProcessUpdateManyWithWhereWithoutUserProcessInput | TodoUserProcessUpdateManyWithWhereWithoutUserProcessInput[]
    deleteMany?: TodoUserProcessScalarWhereInput | TodoUserProcessScalarWhereInput[]
  }

  export type UserPipelineStepCommentCreateNestedManyWithoutStepInput = {
    create?: XOR<UserPipelineStepCommentCreateWithoutStepInput, UserPipelineStepCommentUncheckedCreateWithoutStepInput> | UserPipelineStepCommentCreateWithoutStepInput[] | UserPipelineStepCommentUncheckedCreateWithoutStepInput[]
    connectOrCreate?: UserPipelineStepCommentCreateOrConnectWithoutStepInput | UserPipelineStepCommentCreateOrConnectWithoutStepInput[]
    createMany?: UserPipelineStepCommentCreateManyStepInputEnvelope
    connect?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
  }

  export type UserProcessCreateNestedOneWithoutStepsInput = {
    create?: XOR<UserProcessCreateWithoutStepsInput, UserProcessUncheckedCreateWithoutStepsInput>
    connectOrCreate?: UserProcessCreateOrConnectWithoutStepsInput
    connect?: UserProcessWhereUniqueInput
  }

  export type ProcessStepCreateNestedOneWithoutUserProcessStepsInput = {
    create?: XOR<ProcessStepCreateWithoutUserProcessStepsInput, ProcessStepUncheckedCreateWithoutUserProcessStepsInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutUserProcessStepsInput
    connect?: ProcessStepWhereUniqueInput
  }

  export type UserPipelineStepCommentUncheckedCreateNestedManyWithoutStepInput = {
    create?: XOR<UserPipelineStepCommentCreateWithoutStepInput, UserPipelineStepCommentUncheckedCreateWithoutStepInput> | UserPipelineStepCommentCreateWithoutStepInput[] | UserPipelineStepCommentUncheckedCreateWithoutStepInput[]
    connectOrCreate?: UserPipelineStepCommentCreateOrConnectWithoutStepInput | UserPipelineStepCommentCreateOrConnectWithoutStepInput[]
    createMany?: UserPipelineStepCommentCreateManyStepInputEnvelope
    connect?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
  }

  export type UserPipelineStepCommentUpdateManyWithoutStepNestedInput = {
    create?: XOR<UserPipelineStepCommentCreateWithoutStepInput, UserPipelineStepCommentUncheckedCreateWithoutStepInput> | UserPipelineStepCommentCreateWithoutStepInput[] | UserPipelineStepCommentUncheckedCreateWithoutStepInput[]
    connectOrCreate?: UserPipelineStepCommentCreateOrConnectWithoutStepInput | UserPipelineStepCommentCreateOrConnectWithoutStepInput[]
    upsert?: UserPipelineStepCommentUpsertWithWhereUniqueWithoutStepInput | UserPipelineStepCommentUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: UserPipelineStepCommentCreateManyStepInputEnvelope
    set?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    disconnect?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    delete?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    connect?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    update?: UserPipelineStepCommentUpdateWithWhereUniqueWithoutStepInput | UserPipelineStepCommentUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: UserPipelineStepCommentUpdateManyWithWhereWithoutStepInput | UserPipelineStepCommentUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: UserPipelineStepCommentScalarWhereInput | UserPipelineStepCommentScalarWhereInput[]
  }

  export type UserProcessUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<UserProcessCreateWithoutStepsInput, UserProcessUncheckedCreateWithoutStepsInput>
    connectOrCreate?: UserProcessCreateOrConnectWithoutStepsInput
    upsert?: UserProcessUpsertWithoutStepsInput
    connect?: UserProcessWhereUniqueInput
    update?: XOR<XOR<UserProcessUpdateToOneWithWhereWithoutStepsInput, UserProcessUpdateWithoutStepsInput>, UserProcessUncheckedUpdateWithoutStepsInput>
  }

  export type ProcessStepUpdateOneWithoutUserProcessStepsNestedInput = {
    create?: XOR<ProcessStepCreateWithoutUserProcessStepsInput, ProcessStepUncheckedCreateWithoutUserProcessStepsInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutUserProcessStepsInput
    upsert?: ProcessStepUpsertWithoutUserProcessStepsInput
    disconnect?: ProcessStepWhereInput | boolean
    delete?: ProcessStepWhereInput | boolean
    connect?: ProcessStepWhereUniqueInput
    update?: XOR<XOR<ProcessStepUpdateToOneWithWhereWithoutUserProcessStepsInput, ProcessStepUpdateWithoutUserProcessStepsInput>, ProcessStepUncheckedUpdateWithoutUserProcessStepsInput>
  }

  export type UserPipelineStepCommentUncheckedUpdateManyWithoutStepNestedInput = {
    create?: XOR<UserPipelineStepCommentCreateWithoutStepInput, UserPipelineStepCommentUncheckedCreateWithoutStepInput> | UserPipelineStepCommentCreateWithoutStepInput[] | UserPipelineStepCommentUncheckedCreateWithoutStepInput[]
    connectOrCreate?: UserPipelineStepCommentCreateOrConnectWithoutStepInput | UserPipelineStepCommentCreateOrConnectWithoutStepInput[]
    upsert?: UserPipelineStepCommentUpsertWithWhereUniqueWithoutStepInput | UserPipelineStepCommentUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: UserPipelineStepCommentCreateManyStepInputEnvelope
    set?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    disconnect?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    delete?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    connect?: UserPipelineStepCommentWhereUniqueInput | UserPipelineStepCommentWhereUniqueInput[]
    update?: UserPipelineStepCommentUpdateWithWhereUniqueWithoutStepInput | UserPipelineStepCommentUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: UserPipelineStepCommentUpdateManyWithWhereWithoutStepInput | UserPipelineStepCommentUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: UserPipelineStepCommentScalarWhereInput | UserPipelineStepCommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserPipelineStepCommentsInput = {
    create?: XOR<UserCreateWithoutUserPipelineStepCommentsInput, UserUncheckedCreateWithoutUserPipelineStepCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPipelineStepCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserProcessStepCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserProcessStepCreateWithoutCommentsInput, UserProcessStepUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserProcessStepCreateOrConnectWithoutCommentsInput
    connect?: UserProcessStepWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserPipelineStepCommentsNestedInput = {
    create?: XOR<UserCreateWithoutUserPipelineStepCommentsInput, UserUncheckedCreateWithoutUserPipelineStepCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPipelineStepCommentsInput
    upsert?: UserUpsertWithoutUserPipelineStepCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPipelineStepCommentsInput, UserUpdateWithoutUserPipelineStepCommentsInput>, UserUncheckedUpdateWithoutUserPipelineStepCommentsInput>
  }

  export type UserProcessStepUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserProcessStepCreateWithoutCommentsInput, UserProcessStepUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserProcessStepCreateOrConnectWithoutCommentsInput
    upsert?: UserProcessStepUpsertWithoutCommentsInput
    connect?: UserProcessStepWhereUniqueInput
    update?: XOR<XOR<UserProcessStepUpdateToOneWithWhereWithoutCommentsInput, UserProcessStepUpdateWithoutCommentsInput>, UserProcessStepUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedOneWithoutProcessesInput = {
    create?: XOR<UserCreateWithoutProcessesInput, UserUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessesInput
    connect?: UserWhereUniqueInput
  }

  export type ProcessStepCreateNestedManyWithoutProcessInput = {
    create?: XOR<ProcessStepCreateWithoutProcessInput, ProcessStepUncheckedCreateWithoutProcessInput> | ProcessStepCreateWithoutProcessInput[] | ProcessStepUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutProcessInput | ProcessStepCreateOrConnectWithoutProcessInput[]
    createMany?: ProcessStepCreateManyProcessInputEnvelope
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
  }

  export type UserProcessCreateNestedManyWithoutProcessInput = {
    create?: XOR<UserProcessCreateWithoutProcessInput, UserProcessUncheckedCreateWithoutProcessInput> | UserProcessCreateWithoutProcessInput[] | UserProcessUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: UserProcessCreateOrConnectWithoutProcessInput | UserProcessCreateOrConnectWithoutProcessInput[]
    createMany?: UserProcessCreateManyProcessInputEnvelope
    connect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
  }

  export type ProcessStepUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<ProcessStepCreateWithoutProcessInput, ProcessStepUncheckedCreateWithoutProcessInput> | ProcessStepCreateWithoutProcessInput[] | ProcessStepUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutProcessInput | ProcessStepCreateOrConnectWithoutProcessInput[]
    createMany?: ProcessStepCreateManyProcessInputEnvelope
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
  }

  export type UserProcessUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<UserProcessCreateWithoutProcessInput, UserProcessUncheckedCreateWithoutProcessInput> | UserProcessCreateWithoutProcessInput[] | UserProcessUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: UserProcessCreateOrConnectWithoutProcessInput | UserProcessCreateOrConnectWithoutProcessInput[]
    createMany?: UserProcessCreateManyProcessInputEnvelope
    connect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutProcessesNestedInput = {
    create?: XOR<UserCreateWithoutProcessesInput, UserUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessesInput
    upsert?: UserUpsertWithoutProcessesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessesInput, UserUpdateWithoutProcessesInput>, UserUncheckedUpdateWithoutProcessesInput>
  }

  export type ProcessStepUpdateManyWithoutProcessNestedInput = {
    create?: XOR<ProcessStepCreateWithoutProcessInput, ProcessStepUncheckedCreateWithoutProcessInput> | ProcessStepCreateWithoutProcessInput[] | ProcessStepUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutProcessInput | ProcessStepCreateOrConnectWithoutProcessInput[]
    upsert?: ProcessStepUpsertWithWhereUniqueWithoutProcessInput | ProcessStepUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: ProcessStepCreateManyProcessInputEnvelope
    set?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    disconnect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    delete?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    update?: ProcessStepUpdateWithWhereUniqueWithoutProcessInput | ProcessStepUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: ProcessStepUpdateManyWithWhereWithoutProcessInput | ProcessStepUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
  }

  export type UserProcessUpdateManyWithoutProcessNestedInput = {
    create?: XOR<UserProcessCreateWithoutProcessInput, UserProcessUncheckedCreateWithoutProcessInput> | UserProcessCreateWithoutProcessInput[] | UserProcessUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: UserProcessCreateOrConnectWithoutProcessInput | UserProcessCreateOrConnectWithoutProcessInput[]
    upsert?: UserProcessUpsertWithWhereUniqueWithoutProcessInput | UserProcessUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: UserProcessCreateManyProcessInputEnvelope
    set?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    disconnect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    delete?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    connect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    update?: UserProcessUpdateWithWhereUniqueWithoutProcessInput | UserProcessUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: UserProcessUpdateManyWithWhereWithoutProcessInput | UserProcessUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: UserProcessScalarWhereInput | UserProcessScalarWhereInput[]
  }

  export type ProcessStepUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<ProcessStepCreateWithoutProcessInput, ProcessStepUncheckedCreateWithoutProcessInput> | ProcessStepCreateWithoutProcessInput[] | ProcessStepUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessStepCreateOrConnectWithoutProcessInput | ProcessStepCreateOrConnectWithoutProcessInput[]
    upsert?: ProcessStepUpsertWithWhereUniqueWithoutProcessInput | ProcessStepUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: ProcessStepCreateManyProcessInputEnvelope
    set?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    disconnect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    delete?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    connect?: ProcessStepWhereUniqueInput | ProcessStepWhereUniqueInput[]
    update?: ProcessStepUpdateWithWhereUniqueWithoutProcessInput | ProcessStepUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: ProcessStepUpdateManyWithWhereWithoutProcessInput | ProcessStepUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
  }

  export type UserProcessUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<UserProcessCreateWithoutProcessInput, UserProcessUncheckedCreateWithoutProcessInput> | UserProcessCreateWithoutProcessInput[] | UserProcessUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: UserProcessCreateOrConnectWithoutProcessInput | UserProcessCreateOrConnectWithoutProcessInput[]
    upsert?: UserProcessUpsertWithWhereUniqueWithoutProcessInput | UserProcessUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: UserProcessCreateManyProcessInputEnvelope
    set?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    disconnect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    delete?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    connect?: UserProcessWhereUniqueInput | UserProcessWhereUniqueInput[]
    update?: UserProcessUpdateWithWhereUniqueWithoutProcessInput | UserProcessUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: UserProcessUpdateManyWithWhereWithoutProcessInput | UserProcessUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: UserProcessScalarWhereInput | UserProcessScalarWhereInput[]
  }

  export type ProcessCreateNestedOneWithoutStepsInput = {
    create?: XOR<ProcessCreateWithoutStepsInput, ProcessUncheckedCreateWithoutStepsInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutStepsInput
    connect?: ProcessWhereUniqueInput
  }

  export type TriggerDefinitionCreateNestedManyWithoutStepInput = {
    create?: XOR<TriggerDefinitionCreateWithoutStepInput, TriggerDefinitionUncheckedCreateWithoutStepInput> | TriggerDefinitionCreateWithoutStepInput[] | TriggerDefinitionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: TriggerDefinitionCreateOrConnectWithoutStepInput | TriggerDefinitionCreateOrConnectWithoutStepInput[]
    createMany?: TriggerDefinitionCreateManyStepInputEnvelope
    connect?: TriggerDefinitionWhereUniqueInput | TriggerDefinitionWhereUniqueInput[]
  }

  export type ActionDefinitionCreateNestedManyWithoutStepInput = {
    create?: XOR<ActionDefinitionCreateWithoutStepInput, ActionDefinitionUncheckedCreateWithoutStepInput> | ActionDefinitionCreateWithoutStepInput[] | ActionDefinitionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: ActionDefinitionCreateOrConnectWithoutStepInput | ActionDefinitionCreateOrConnectWithoutStepInput[]
    createMany?: ActionDefinitionCreateManyStepInputEnvelope
    connect?: ActionDefinitionWhereUniqueInput | ActionDefinitionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutProcessStepsInput = {
    create?: XOR<UserCreateWithoutProcessStepsInput, UserUncheckedCreateWithoutProcessStepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessStepsInput
    connect?: UserWhereUniqueInput
  }

  export type UserProcessStepCreateNestedManyWithoutStepInput = {
    create?: XOR<UserProcessStepCreateWithoutStepInput, UserProcessStepUncheckedCreateWithoutStepInput> | UserProcessStepCreateWithoutStepInput[] | UserProcessStepUncheckedCreateWithoutStepInput[]
    connectOrCreate?: UserProcessStepCreateOrConnectWithoutStepInput | UserProcessStepCreateOrConnectWithoutStepInput[]
    createMany?: UserProcessStepCreateManyStepInputEnvelope
    connect?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
  }

  export type TriggerDefinitionUncheckedCreateNestedManyWithoutStepInput = {
    create?: XOR<TriggerDefinitionCreateWithoutStepInput, TriggerDefinitionUncheckedCreateWithoutStepInput> | TriggerDefinitionCreateWithoutStepInput[] | TriggerDefinitionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: TriggerDefinitionCreateOrConnectWithoutStepInput | TriggerDefinitionCreateOrConnectWithoutStepInput[]
    createMany?: TriggerDefinitionCreateManyStepInputEnvelope
    connect?: TriggerDefinitionWhereUniqueInput | TriggerDefinitionWhereUniqueInput[]
  }

  export type ActionDefinitionUncheckedCreateNestedManyWithoutStepInput = {
    create?: XOR<ActionDefinitionCreateWithoutStepInput, ActionDefinitionUncheckedCreateWithoutStepInput> | ActionDefinitionCreateWithoutStepInput[] | ActionDefinitionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: ActionDefinitionCreateOrConnectWithoutStepInput | ActionDefinitionCreateOrConnectWithoutStepInput[]
    createMany?: ActionDefinitionCreateManyStepInputEnvelope
    connect?: ActionDefinitionWhereUniqueInput | ActionDefinitionWhereUniqueInput[]
  }

  export type UserProcessStepUncheckedCreateNestedManyWithoutStepInput = {
    create?: XOR<UserProcessStepCreateWithoutStepInput, UserProcessStepUncheckedCreateWithoutStepInput> | UserProcessStepCreateWithoutStepInput[] | UserProcessStepUncheckedCreateWithoutStepInput[]
    connectOrCreate?: UserProcessStepCreateOrConnectWithoutStepInput | UserProcessStepCreateOrConnectWithoutStepInput[]
    createMany?: UserProcessStepCreateManyStepInputEnvelope
    connect?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProcessUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<ProcessCreateWithoutStepsInput, ProcessUncheckedCreateWithoutStepsInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutStepsInput
    upsert?: ProcessUpsertWithoutStepsInput
    connect?: ProcessWhereUniqueInput
    update?: XOR<XOR<ProcessUpdateToOneWithWhereWithoutStepsInput, ProcessUpdateWithoutStepsInput>, ProcessUncheckedUpdateWithoutStepsInput>
  }

  export type TriggerDefinitionUpdateManyWithoutStepNestedInput = {
    create?: XOR<TriggerDefinitionCreateWithoutStepInput, TriggerDefinitionUncheckedCreateWithoutStepInput> | TriggerDefinitionCreateWithoutStepInput[] | TriggerDefinitionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: TriggerDefinitionCreateOrConnectWithoutStepInput | TriggerDefinitionCreateOrConnectWithoutStepInput[]
    upsert?: TriggerDefinitionUpsertWithWhereUniqueWithoutStepInput | TriggerDefinitionUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: TriggerDefinitionCreateManyStepInputEnvelope
    set?: TriggerDefinitionWhereUniqueInput | TriggerDefinitionWhereUniqueInput[]
    disconnect?: TriggerDefinitionWhereUniqueInput | TriggerDefinitionWhereUniqueInput[]
    delete?: TriggerDefinitionWhereUniqueInput | TriggerDefinitionWhereUniqueInput[]
    connect?: TriggerDefinitionWhereUniqueInput | TriggerDefinitionWhereUniqueInput[]
    update?: TriggerDefinitionUpdateWithWhereUniqueWithoutStepInput | TriggerDefinitionUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: TriggerDefinitionUpdateManyWithWhereWithoutStepInput | TriggerDefinitionUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: TriggerDefinitionScalarWhereInput | TriggerDefinitionScalarWhereInput[]
  }

  export type ActionDefinitionUpdateManyWithoutStepNestedInput = {
    create?: XOR<ActionDefinitionCreateWithoutStepInput, ActionDefinitionUncheckedCreateWithoutStepInput> | ActionDefinitionCreateWithoutStepInput[] | ActionDefinitionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: ActionDefinitionCreateOrConnectWithoutStepInput | ActionDefinitionCreateOrConnectWithoutStepInput[]
    upsert?: ActionDefinitionUpsertWithWhereUniqueWithoutStepInput | ActionDefinitionUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: ActionDefinitionCreateManyStepInputEnvelope
    set?: ActionDefinitionWhereUniqueInput | ActionDefinitionWhereUniqueInput[]
    disconnect?: ActionDefinitionWhereUniqueInput | ActionDefinitionWhereUniqueInput[]
    delete?: ActionDefinitionWhereUniqueInput | ActionDefinitionWhereUniqueInput[]
    connect?: ActionDefinitionWhereUniqueInput | ActionDefinitionWhereUniqueInput[]
    update?: ActionDefinitionUpdateWithWhereUniqueWithoutStepInput | ActionDefinitionUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: ActionDefinitionUpdateManyWithWhereWithoutStepInput | ActionDefinitionUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: ActionDefinitionScalarWhereInput | ActionDefinitionScalarWhereInput[]
  }

  export type UserUpdateOneWithoutProcessStepsNestedInput = {
    create?: XOR<UserCreateWithoutProcessStepsInput, UserUncheckedCreateWithoutProcessStepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessStepsInput
    upsert?: UserUpsertWithoutProcessStepsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessStepsInput, UserUpdateWithoutProcessStepsInput>, UserUncheckedUpdateWithoutProcessStepsInput>
  }

  export type UserProcessStepUpdateManyWithoutStepNestedInput = {
    create?: XOR<UserProcessStepCreateWithoutStepInput, UserProcessStepUncheckedCreateWithoutStepInput> | UserProcessStepCreateWithoutStepInput[] | UserProcessStepUncheckedCreateWithoutStepInput[]
    connectOrCreate?: UserProcessStepCreateOrConnectWithoutStepInput | UserProcessStepCreateOrConnectWithoutStepInput[]
    upsert?: UserProcessStepUpsertWithWhereUniqueWithoutStepInput | UserProcessStepUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: UserProcessStepCreateManyStepInputEnvelope
    set?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    disconnect?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    delete?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    connect?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    update?: UserProcessStepUpdateWithWhereUniqueWithoutStepInput | UserProcessStepUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: UserProcessStepUpdateManyWithWhereWithoutStepInput | UserProcessStepUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: UserProcessStepScalarWhereInput | UserProcessStepScalarWhereInput[]
  }

  export type TriggerDefinitionUncheckedUpdateManyWithoutStepNestedInput = {
    create?: XOR<TriggerDefinitionCreateWithoutStepInput, TriggerDefinitionUncheckedCreateWithoutStepInput> | TriggerDefinitionCreateWithoutStepInput[] | TriggerDefinitionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: TriggerDefinitionCreateOrConnectWithoutStepInput | TriggerDefinitionCreateOrConnectWithoutStepInput[]
    upsert?: TriggerDefinitionUpsertWithWhereUniqueWithoutStepInput | TriggerDefinitionUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: TriggerDefinitionCreateManyStepInputEnvelope
    set?: TriggerDefinitionWhereUniqueInput | TriggerDefinitionWhereUniqueInput[]
    disconnect?: TriggerDefinitionWhereUniqueInput | TriggerDefinitionWhereUniqueInput[]
    delete?: TriggerDefinitionWhereUniqueInput | TriggerDefinitionWhereUniqueInput[]
    connect?: TriggerDefinitionWhereUniqueInput | TriggerDefinitionWhereUniqueInput[]
    update?: TriggerDefinitionUpdateWithWhereUniqueWithoutStepInput | TriggerDefinitionUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: TriggerDefinitionUpdateManyWithWhereWithoutStepInput | TriggerDefinitionUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: TriggerDefinitionScalarWhereInput | TriggerDefinitionScalarWhereInput[]
  }

  export type ActionDefinitionUncheckedUpdateManyWithoutStepNestedInput = {
    create?: XOR<ActionDefinitionCreateWithoutStepInput, ActionDefinitionUncheckedCreateWithoutStepInput> | ActionDefinitionCreateWithoutStepInput[] | ActionDefinitionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: ActionDefinitionCreateOrConnectWithoutStepInput | ActionDefinitionCreateOrConnectWithoutStepInput[]
    upsert?: ActionDefinitionUpsertWithWhereUniqueWithoutStepInput | ActionDefinitionUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: ActionDefinitionCreateManyStepInputEnvelope
    set?: ActionDefinitionWhereUniqueInput | ActionDefinitionWhereUniqueInput[]
    disconnect?: ActionDefinitionWhereUniqueInput | ActionDefinitionWhereUniqueInput[]
    delete?: ActionDefinitionWhereUniqueInput | ActionDefinitionWhereUniqueInput[]
    connect?: ActionDefinitionWhereUniqueInput | ActionDefinitionWhereUniqueInput[]
    update?: ActionDefinitionUpdateWithWhereUniqueWithoutStepInput | ActionDefinitionUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: ActionDefinitionUpdateManyWithWhereWithoutStepInput | ActionDefinitionUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: ActionDefinitionScalarWhereInput | ActionDefinitionScalarWhereInput[]
  }

  export type UserProcessStepUncheckedUpdateManyWithoutStepNestedInput = {
    create?: XOR<UserProcessStepCreateWithoutStepInput, UserProcessStepUncheckedCreateWithoutStepInput> | UserProcessStepCreateWithoutStepInput[] | UserProcessStepUncheckedCreateWithoutStepInput[]
    connectOrCreate?: UserProcessStepCreateOrConnectWithoutStepInput | UserProcessStepCreateOrConnectWithoutStepInput[]
    upsert?: UserProcessStepUpsertWithWhereUniqueWithoutStepInput | UserProcessStepUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: UserProcessStepCreateManyStepInputEnvelope
    set?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    disconnect?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    delete?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    connect?: UserProcessStepWhereUniqueInput | UserProcessStepWhereUniqueInput[]
    update?: UserProcessStepUpdateWithWhereUniqueWithoutStepInput | UserProcessStepUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: UserProcessStepUpdateManyWithWhereWithoutStepInput | UserProcessStepUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: UserProcessStepScalarWhereInput | UserProcessStepScalarWhereInput[]
  }

  export type ProcessStepCreateNestedOneWithoutActionsInput = {
    create?: XOR<ProcessStepCreateWithoutActionsInput, ProcessStepUncheckedCreateWithoutActionsInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutActionsInput
    connect?: ProcessStepWhereUniqueInput
  }

  export type ProcessStepUpdateOneWithoutActionsNestedInput = {
    create?: XOR<ProcessStepCreateWithoutActionsInput, ProcessStepUncheckedCreateWithoutActionsInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutActionsInput
    upsert?: ProcessStepUpsertWithoutActionsInput
    disconnect?: ProcessStepWhereInput | boolean
    delete?: ProcessStepWhereInput | boolean
    connect?: ProcessStepWhereUniqueInput
    update?: XOR<XOR<ProcessStepUpdateToOneWithWhereWithoutActionsInput, ProcessStepUpdateWithoutActionsInput>, ProcessStepUncheckedUpdateWithoutActionsInput>
  }

  export type ConditionalCreateNestedManyWithoutTriggerInput = {
    create?: XOR<ConditionalCreateWithoutTriggerInput, ConditionalUncheckedCreateWithoutTriggerInput> | ConditionalCreateWithoutTriggerInput[] | ConditionalUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: ConditionalCreateOrConnectWithoutTriggerInput | ConditionalCreateOrConnectWithoutTriggerInput[]
    createMany?: ConditionalCreateManyTriggerInputEnvelope
    connect?: ConditionalWhereUniqueInput | ConditionalWhereUniqueInput[]
  }

  export type ProcessStepCreateNestedOneWithoutTriggersInput = {
    create?: XOR<ProcessStepCreateWithoutTriggersInput, ProcessStepUncheckedCreateWithoutTriggersInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutTriggersInput
    connect?: ProcessStepWhereUniqueInput
  }

  export type ConditionalUncheckedCreateNestedManyWithoutTriggerInput = {
    create?: XOR<ConditionalCreateWithoutTriggerInput, ConditionalUncheckedCreateWithoutTriggerInput> | ConditionalCreateWithoutTriggerInput[] | ConditionalUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: ConditionalCreateOrConnectWithoutTriggerInput | ConditionalCreateOrConnectWithoutTriggerInput[]
    createMany?: ConditionalCreateManyTriggerInputEnvelope
    connect?: ConditionalWhereUniqueInput | ConditionalWhereUniqueInput[]
  }

  export type NullableEnumTriggerEventCodeFieldUpdateOperationsInput = {
    set?: $Enums.TriggerEventCode | null
  }

  export type NullableEnumCombinatorEnumFieldUpdateOperationsInput = {
    set?: $Enums.CombinatorEnum | null
  }

  export type ConditionalUpdateManyWithoutTriggerNestedInput = {
    create?: XOR<ConditionalCreateWithoutTriggerInput, ConditionalUncheckedCreateWithoutTriggerInput> | ConditionalCreateWithoutTriggerInput[] | ConditionalUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: ConditionalCreateOrConnectWithoutTriggerInput | ConditionalCreateOrConnectWithoutTriggerInput[]
    upsert?: ConditionalUpsertWithWhereUniqueWithoutTriggerInput | ConditionalUpsertWithWhereUniqueWithoutTriggerInput[]
    createMany?: ConditionalCreateManyTriggerInputEnvelope
    set?: ConditionalWhereUniqueInput | ConditionalWhereUniqueInput[]
    disconnect?: ConditionalWhereUniqueInput | ConditionalWhereUniqueInput[]
    delete?: ConditionalWhereUniqueInput | ConditionalWhereUniqueInput[]
    connect?: ConditionalWhereUniqueInput | ConditionalWhereUniqueInput[]
    update?: ConditionalUpdateWithWhereUniqueWithoutTriggerInput | ConditionalUpdateWithWhereUniqueWithoutTriggerInput[]
    updateMany?: ConditionalUpdateManyWithWhereWithoutTriggerInput | ConditionalUpdateManyWithWhereWithoutTriggerInput[]
    deleteMany?: ConditionalScalarWhereInput | ConditionalScalarWhereInput[]
  }

  export type ProcessStepUpdateOneWithoutTriggersNestedInput = {
    create?: XOR<ProcessStepCreateWithoutTriggersInput, ProcessStepUncheckedCreateWithoutTriggersInput>
    connectOrCreate?: ProcessStepCreateOrConnectWithoutTriggersInput
    upsert?: ProcessStepUpsertWithoutTriggersInput
    disconnect?: ProcessStepWhereInput | boolean
    delete?: ProcessStepWhereInput | boolean
    connect?: ProcessStepWhereUniqueInput
    update?: XOR<XOR<ProcessStepUpdateToOneWithWhereWithoutTriggersInput, ProcessStepUpdateWithoutTriggersInput>, ProcessStepUncheckedUpdateWithoutTriggersInput>
  }

  export type ConditionalUncheckedUpdateManyWithoutTriggerNestedInput = {
    create?: XOR<ConditionalCreateWithoutTriggerInput, ConditionalUncheckedCreateWithoutTriggerInput> | ConditionalCreateWithoutTriggerInput[] | ConditionalUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: ConditionalCreateOrConnectWithoutTriggerInput | ConditionalCreateOrConnectWithoutTriggerInput[]
    upsert?: ConditionalUpsertWithWhereUniqueWithoutTriggerInput | ConditionalUpsertWithWhereUniqueWithoutTriggerInput[]
    createMany?: ConditionalCreateManyTriggerInputEnvelope
    set?: ConditionalWhereUniqueInput | ConditionalWhereUniqueInput[]
    disconnect?: ConditionalWhereUniqueInput | ConditionalWhereUniqueInput[]
    delete?: ConditionalWhereUniqueInput | ConditionalWhereUniqueInput[]
    connect?: ConditionalWhereUniqueInput | ConditionalWhereUniqueInput[]
    update?: ConditionalUpdateWithWhereUniqueWithoutTriggerInput | ConditionalUpdateWithWhereUniqueWithoutTriggerInput[]
    updateMany?: ConditionalUpdateManyWithWhereWithoutTriggerInput | ConditionalUpdateManyWithWhereWithoutTriggerInput[]
    deleteMany?: ConditionalScalarWhereInput | ConditionalScalarWhereInput[]
  }

  export type TriggerDefinitionCreateNestedOneWithoutConditionsInput = {
    create?: XOR<TriggerDefinitionCreateWithoutConditionsInput, TriggerDefinitionUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: TriggerDefinitionCreateOrConnectWithoutConditionsInput
    connect?: TriggerDefinitionWhereUniqueInput
  }

  export type EnumComparisonOperatorEnumFieldUpdateOperationsInput = {
    set?: $Enums.ComparisonOperatorEnum
  }

  export type TriggerDefinitionUpdateOneRequiredWithoutConditionsNestedInput = {
    create?: XOR<TriggerDefinitionCreateWithoutConditionsInput, TriggerDefinitionUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: TriggerDefinitionCreateOrConnectWithoutConditionsInput
    upsert?: TriggerDefinitionUpsertWithoutConditionsInput
    connect?: TriggerDefinitionWhereUniqueInput
    update?: XOR<XOR<TriggerDefinitionUpdateToOneWithWhereWithoutConditionsInput, TriggerDefinitionUpdateWithoutConditionsInput>, TriggerDefinitionUncheckedUpdateWithoutConditionsInput>
  }

  export type UserCreateNestedOneWithoutTodosInput = {
    create?: XOR<UserCreateWithoutTodosInput, UserUncheckedCreateWithoutTodosInput>
    connectOrCreate?: UserCreateOrConnectWithoutTodosInput
    connect?: UserWhereUniqueInput
  }

  export type TodoItemCreateNestedManyWithoutTodoInput = {
    create?: XOR<TodoItemCreateWithoutTodoInput, TodoItemUncheckedCreateWithoutTodoInput> | TodoItemCreateWithoutTodoInput[] | TodoItemUncheckedCreateWithoutTodoInput[]
    connectOrCreate?: TodoItemCreateOrConnectWithoutTodoInput | TodoItemCreateOrConnectWithoutTodoInput[]
    createMany?: TodoItemCreateManyTodoInputEnvelope
    connect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
  }

  export type TodoUserProcessCreateNestedManyWithoutTodoInput = {
    create?: XOR<TodoUserProcessCreateWithoutTodoInput, TodoUserProcessUncheckedCreateWithoutTodoInput> | TodoUserProcessCreateWithoutTodoInput[] | TodoUserProcessUncheckedCreateWithoutTodoInput[]
    connectOrCreate?: TodoUserProcessCreateOrConnectWithoutTodoInput | TodoUserProcessCreateOrConnectWithoutTodoInput[]
    createMany?: TodoUserProcessCreateManyTodoInputEnvelope
    connect?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
  }

  export type TodoItemUncheckedCreateNestedManyWithoutTodoInput = {
    create?: XOR<TodoItemCreateWithoutTodoInput, TodoItemUncheckedCreateWithoutTodoInput> | TodoItemCreateWithoutTodoInput[] | TodoItemUncheckedCreateWithoutTodoInput[]
    connectOrCreate?: TodoItemCreateOrConnectWithoutTodoInput | TodoItemCreateOrConnectWithoutTodoInput[]
    createMany?: TodoItemCreateManyTodoInputEnvelope
    connect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
  }

  export type TodoUserProcessUncheckedCreateNestedManyWithoutTodoInput = {
    create?: XOR<TodoUserProcessCreateWithoutTodoInput, TodoUserProcessUncheckedCreateWithoutTodoInput> | TodoUserProcessCreateWithoutTodoInput[] | TodoUserProcessUncheckedCreateWithoutTodoInput[]
    connectOrCreate?: TodoUserProcessCreateOrConnectWithoutTodoInput | TodoUserProcessCreateOrConnectWithoutTodoInput[]
    createMany?: TodoUserProcessCreateManyTodoInputEnvelope
    connect?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTodosNestedInput = {
    create?: XOR<UserCreateWithoutTodosInput, UserUncheckedCreateWithoutTodosInput>
    connectOrCreate?: UserCreateOrConnectWithoutTodosInput
    upsert?: UserUpsertWithoutTodosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTodosInput, UserUpdateWithoutTodosInput>, UserUncheckedUpdateWithoutTodosInput>
  }

  export type TodoItemUpdateManyWithoutTodoNestedInput = {
    create?: XOR<TodoItemCreateWithoutTodoInput, TodoItemUncheckedCreateWithoutTodoInput> | TodoItemCreateWithoutTodoInput[] | TodoItemUncheckedCreateWithoutTodoInput[]
    connectOrCreate?: TodoItemCreateOrConnectWithoutTodoInput | TodoItemCreateOrConnectWithoutTodoInput[]
    upsert?: TodoItemUpsertWithWhereUniqueWithoutTodoInput | TodoItemUpsertWithWhereUniqueWithoutTodoInput[]
    createMany?: TodoItemCreateManyTodoInputEnvelope
    set?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    disconnect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    delete?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    connect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    update?: TodoItemUpdateWithWhereUniqueWithoutTodoInput | TodoItemUpdateWithWhereUniqueWithoutTodoInput[]
    updateMany?: TodoItemUpdateManyWithWhereWithoutTodoInput | TodoItemUpdateManyWithWhereWithoutTodoInput[]
    deleteMany?: TodoItemScalarWhereInput | TodoItemScalarWhereInput[]
  }

  export type TodoUserProcessUpdateManyWithoutTodoNestedInput = {
    create?: XOR<TodoUserProcessCreateWithoutTodoInput, TodoUserProcessUncheckedCreateWithoutTodoInput> | TodoUserProcessCreateWithoutTodoInput[] | TodoUserProcessUncheckedCreateWithoutTodoInput[]
    connectOrCreate?: TodoUserProcessCreateOrConnectWithoutTodoInput | TodoUserProcessCreateOrConnectWithoutTodoInput[]
    upsert?: TodoUserProcessUpsertWithWhereUniqueWithoutTodoInput | TodoUserProcessUpsertWithWhereUniqueWithoutTodoInput[]
    createMany?: TodoUserProcessCreateManyTodoInputEnvelope
    set?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    disconnect?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    delete?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    connect?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    update?: TodoUserProcessUpdateWithWhereUniqueWithoutTodoInput | TodoUserProcessUpdateWithWhereUniqueWithoutTodoInput[]
    updateMany?: TodoUserProcessUpdateManyWithWhereWithoutTodoInput | TodoUserProcessUpdateManyWithWhereWithoutTodoInput[]
    deleteMany?: TodoUserProcessScalarWhereInput | TodoUserProcessScalarWhereInput[]
  }

  export type TodoItemUncheckedUpdateManyWithoutTodoNestedInput = {
    create?: XOR<TodoItemCreateWithoutTodoInput, TodoItemUncheckedCreateWithoutTodoInput> | TodoItemCreateWithoutTodoInput[] | TodoItemUncheckedCreateWithoutTodoInput[]
    connectOrCreate?: TodoItemCreateOrConnectWithoutTodoInput | TodoItemCreateOrConnectWithoutTodoInput[]
    upsert?: TodoItemUpsertWithWhereUniqueWithoutTodoInput | TodoItemUpsertWithWhereUniqueWithoutTodoInput[]
    createMany?: TodoItemCreateManyTodoInputEnvelope
    set?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    disconnect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    delete?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    connect?: TodoItemWhereUniqueInput | TodoItemWhereUniqueInput[]
    update?: TodoItemUpdateWithWhereUniqueWithoutTodoInput | TodoItemUpdateWithWhereUniqueWithoutTodoInput[]
    updateMany?: TodoItemUpdateManyWithWhereWithoutTodoInput | TodoItemUpdateManyWithWhereWithoutTodoInput[]
    deleteMany?: TodoItemScalarWhereInput | TodoItemScalarWhereInput[]
  }

  export type TodoUserProcessUncheckedUpdateManyWithoutTodoNestedInput = {
    create?: XOR<TodoUserProcessCreateWithoutTodoInput, TodoUserProcessUncheckedCreateWithoutTodoInput> | TodoUserProcessCreateWithoutTodoInput[] | TodoUserProcessUncheckedCreateWithoutTodoInput[]
    connectOrCreate?: TodoUserProcessCreateOrConnectWithoutTodoInput | TodoUserProcessCreateOrConnectWithoutTodoInput[]
    upsert?: TodoUserProcessUpsertWithWhereUniqueWithoutTodoInput | TodoUserProcessUpsertWithWhereUniqueWithoutTodoInput[]
    createMany?: TodoUserProcessCreateManyTodoInputEnvelope
    set?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    disconnect?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    delete?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    connect?: TodoUserProcessWhereUniqueInput | TodoUserProcessWhereUniqueInput[]
    update?: TodoUserProcessUpdateWithWhereUniqueWithoutTodoInput | TodoUserProcessUpdateWithWhereUniqueWithoutTodoInput[]
    updateMany?: TodoUserProcessUpdateManyWithWhereWithoutTodoInput | TodoUserProcessUpdateManyWithWhereWithoutTodoInput[]
    deleteMany?: TodoUserProcessScalarWhereInput | TodoUserProcessScalarWhereInput[]
  }

  export type TodoCreateNestedOneWithoutItemsInput = {
    create?: XOR<TodoCreateWithoutItemsInput, TodoUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TodoCreateOrConnectWithoutItemsInput
    connect?: TodoWhereUniqueInput
  }

  export type EnumTodoItemTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.TodoItemTypeEnum
  }

  export type TodoUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TodoCreateWithoutItemsInput, TodoUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TodoCreateOrConnectWithoutItemsInput
    upsert?: TodoUpsertWithoutItemsInput
    connect?: TodoWhereUniqueInput
    update?: XOR<XOR<TodoUpdateToOneWithWhereWithoutItemsInput, TodoUpdateWithoutItemsInput>, TodoUncheckedUpdateWithoutItemsInput>
  }

  export type TodoCreateNestedOneWithoutUserProcessesInput = {
    create?: XOR<TodoCreateWithoutUserProcessesInput, TodoUncheckedCreateWithoutUserProcessesInput>
    connectOrCreate?: TodoCreateOrConnectWithoutUserProcessesInput
    connect?: TodoWhereUniqueInput
  }

  export type UserProcessCreateNestedOneWithoutTodosInput = {
    create?: XOR<UserProcessCreateWithoutTodosInput, UserProcessUncheckedCreateWithoutTodosInput>
    connectOrCreate?: UserProcessCreateOrConnectWithoutTodosInput
    connect?: UserProcessWhereUniqueInput
  }

  export type TodoUpdateOneRequiredWithoutUserProcessesNestedInput = {
    create?: XOR<TodoCreateWithoutUserProcessesInput, TodoUncheckedCreateWithoutUserProcessesInput>
    connectOrCreate?: TodoCreateOrConnectWithoutUserProcessesInput
    upsert?: TodoUpsertWithoutUserProcessesInput
    connect?: TodoWhereUniqueInput
    update?: XOR<XOR<TodoUpdateToOneWithWhereWithoutUserProcessesInput, TodoUpdateWithoutUserProcessesInput>, TodoUncheckedUpdateWithoutUserProcessesInput>
  }

  export type UserProcessUpdateOneRequiredWithoutTodosNestedInput = {
    create?: XOR<UserProcessCreateWithoutTodosInput, UserProcessUncheckedCreateWithoutTodosInput>
    connectOrCreate?: UserProcessCreateOrConnectWithoutTodosInput
    upsert?: UserProcessUpsertWithoutTodosInput
    connect?: UserProcessWhereUniqueInput
    update?: XOR<XOR<UserProcessUpdateToOneWithWhereWithoutTodosInput, UserProcessUpdateWithoutTodosInput>, UserProcessUncheckedUpdateWithoutTodosInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumProviderEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderEnum | EnumProviderEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderEnum[] | ListEnumProviderEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderEnum[] | ListEnumProviderEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderEnumFilter<$PrismaModel> | $Enums.ProviderEnum
  }

  export type NestedEnumProviderEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderEnum | EnumProviderEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderEnum[] | ListEnumProviderEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderEnum[] | ListEnumProviderEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderEnumWithAggregatesFilter<$PrismaModel> | $Enums.ProviderEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderEnumFilter<$PrismaModel>
    _max?: NestedEnumProviderEnumFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCreatedByEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatedByEnum | EnumCreatedByEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CreatedByEnum[] | ListEnumCreatedByEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatedByEnum[] | ListEnumCreatedByEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatedByEnumFilter<$PrismaModel> | $Enums.CreatedByEnum
  }

  export type NestedEnumJobSourceEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.JobSourceEnum | EnumJobSourceEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.JobSourceEnum[] | ListEnumJobSourceEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.JobSourceEnum[] | ListEnumJobSourceEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumJobSourceEnumNullableFilter<$PrismaModel> | $Enums.JobSourceEnum | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumCreatedByEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatedByEnum | EnumCreatedByEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CreatedByEnum[] | ListEnumCreatedByEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatedByEnum[] | ListEnumCreatedByEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatedByEnumWithAggregatesFilter<$PrismaModel> | $Enums.CreatedByEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreatedByEnumFilter<$PrismaModel>
    _max?: NestedEnumCreatedByEnumFilter<$PrismaModel>
  }

  export type NestedEnumJobSourceEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobSourceEnum | EnumJobSourceEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.JobSourceEnum[] | ListEnumJobSourceEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.JobSourceEnum[] | ListEnumJobSourceEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumJobSourceEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.JobSourceEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumJobSourceEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumJobSourceEnumNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusUserJobProcessesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusUserJobProcesses | EnumStatusUserJobProcessesFieldRefInput<$PrismaModel>
    in?: $Enums.StatusUserJobProcesses[] | ListEnumStatusUserJobProcessesFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusUserJobProcesses[] | ListEnumStatusUserJobProcessesFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusUserJobProcessesFilter<$PrismaModel> | $Enums.StatusUserJobProcesses
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumStatusUserJobProcessesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusUserJobProcesses | EnumStatusUserJobProcessesFieldRefInput<$PrismaModel>
    in?: $Enums.StatusUserJobProcesses[] | ListEnumStatusUserJobProcessesFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusUserJobProcesses[] | ListEnumStatusUserJobProcessesFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusUserJobProcessesWithAggregatesFilter<$PrismaModel> | $Enums.StatusUserJobProcesses
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusUserJobProcessesFilter<$PrismaModel>
    _max?: NestedEnumStatusUserJobProcessesFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTriggerEventCodeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerEventCode | EnumTriggerEventCodeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriggerEventCode[] | ListEnumTriggerEventCodeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TriggerEventCode[] | ListEnumTriggerEventCodeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTriggerEventCodeNullableFilter<$PrismaModel> | $Enums.TriggerEventCode | null
  }

  export type NestedEnumCombinatorEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CombinatorEnum | EnumCombinatorEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.CombinatorEnum[] | ListEnumCombinatorEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CombinatorEnum[] | ListEnumCombinatorEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCombinatorEnumNullableFilter<$PrismaModel> | $Enums.CombinatorEnum | null
  }

  export type NestedEnumTriggerEventCodeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerEventCode | EnumTriggerEventCodeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriggerEventCode[] | ListEnumTriggerEventCodeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TriggerEventCode[] | ListEnumTriggerEventCodeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTriggerEventCodeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TriggerEventCode | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTriggerEventCodeNullableFilter<$PrismaModel>
    _max?: NestedEnumTriggerEventCodeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCombinatorEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CombinatorEnum | EnumCombinatorEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.CombinatorEnum[] | ListEnumCombinatorEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CombinatorEnum[] | ListEnumCombinatorEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCombinatorEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.CombinatorEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCombinatorEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumCombinatorEnumNullableFilter<$PrismaModel>
  }

  export type NestedEnumComparisonOperatorEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ComparisonOperatorEnum | EnumComparisonOperatorEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ComparisonOperatorEnum[] | ListEnumComparisonOperatorEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComparisonOperatorEnum[] | ListEnumComparisonOperatorEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumComparisonOperatorEnumFilter<$PrismaModel> | $Enums.ComparisonOperatorEnum
  }

  export type NestedEnumComparisonOperatorEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComparisonOperatorEnum | EnumComparisonOperatorEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ComparisonOperatorEnum[] | ListEnumComparisonOperatorEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComparisonOperatorEnum[] | ListEnumComparisonOperatorEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumComparisonOperatorEnumWithAggregatesFilter<$PrismaModel> | $Enums.ComparisonOperatorEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComparisonOperatorEnumFilter<$PrismaModel>
    _max?: NestedEnumComparisonOperatorEnumFilter<$PrismaModel>
  }

  export type NestedEnumTodoItemTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.TodoItemTypeEnum | EnumTodoItemTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TodoItemTypeEnum[] | ListEnumTodoItemTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.TodoItemTypeEnum[] | ListEnumTodoItemTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumTodoItemTypeEnumFilter<$PrismaModel> | $Enums.TodoItemTypeEnum
  }

  export type NestedEnumTodoItemTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TodoItemTypeEnum | EnumTodoItemTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TodoItemTypeEnum[] | ListEnumTodoItemTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.TodoItemTypeEnum[] | ListEnumTodoItemTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumTodoItemTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.TodoItemTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTodoItemTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumTodoItemTypeEnumFilter<$PrismaModel>
  }

  export type ProviderCreateWithoutUserInput = {
    id?: string
    provider: $Enums.ProviderEnum
    providerAccountId: string
    token?: TokenCreateNestedOneWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutUserInput = {
    id?: string
    provider: $Enums.ProviderEnum
    providerAccountId: string
    token?: TokenUncheckedCreateNestedOneWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutUserInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutUserInput, ProviderUncheckedCreateWithoutUserInput>
  }

  export type ProviderCreateManyUserInputEnvelope = {
    data: ProviderCreateManyUserInput | ProviderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type JobApplicantsCreateWithoutUserInput = {
    id?: string
    status?: string
    appliedAt: string
    gotJob?: boolean
    jobPosting: JobPostingCreateNestedOneWithoutUserJobApplicationsInput
  }

  export type JobApplicantsUncheckedCreateWithoutUserInput = {
    id?: string
    jobPostingId: string
    status?: string
    appliedAt: string
    gotJob?: boolean
  }

  export type JobApplicantsCreateOrConnectWithoutUserInput = {
    where: JobApplicantsWhereUniqueInput
    create: XOR<JobApplicantsCreateWithoutUserInput, JobApplicantsUncheckedCreateWithoutUserInput>
  }

  export type JobApplicantsCreateManyUserInputEnvelope = {
    data: JobApplicantsCreateManyUserInput | JobApplicantsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserProcessCreateWithoutUserInput = {
    id?: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    steps?: UserProcessStepCreateNestedManyWithoutProcessInput
    jobPosting?: JobPostingCreateNestedOneWithoutUserProcessesInput
    process?: ProcessCreateNestedOneWithoutProcessesInput
    todos?: TodoUserProcessCreateNestedManyWithoutUserProcessInput
  }

  export type UserProcessUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    jobPostingId: string
    processId?: string | null
    steps?: UserProcessStepUncheckedCreateNestedManyWithoutProcessInput
    todos?: TodoUserProcessUncheckedCreateNestedManyWithoutUserProcessInput
  }

  export type UserProcessCreateOrConnectWithoutUserInput = {
    where: UserProcessWhereUniqueInput
    create: XOR<UserProcessCreateWithoutUserInput, UserProcessUncheckedCreateWithoutUserInput>
  }

  export type UserProcessCreateManyUserInputEnvelope = {
    data: UserProcessCreateManyUserInput | UserProcessCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    logo?: string | null
    jobPostings?: JobPostingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    logo?: string | null
    jobPostings?: JobPostingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type CreatedJobPostingCreateWithoutCreatedByInput = {
    id?: string
    createdByType: $Enums.CreatedByEnum
    source?: $Enums.JobSourceEnum | null
    importedAt?: Date | string | null
    jobPosting: JobPostingCreateNestedOneWithoutCreatedJobPostingInput
  }

  export type CreatedJobPostingUncheckedCreateWithoutCreatedByInput = {
    id?: string
    jobPostingId: string
    createdByType: $Enums.CreatedByEnum
    source?: $Enums.JobSourceEnum | null
    importedAt?: Date | string | null
  }

  export type CreatedJobPostingCreateOrConnectWithoutCreatedByInput = {
    where: CreatedJobPostingWhereUniqueInput
    create: XOR<CreatedJobPostingCreateWithoutCreatedByInput, CreatedJobPostingUncheckedCreateWithoutCreatedByInput>
  }

  export type CreatedJobPostingCreateManyCreatedByInputEnvelope = {
    data: CreatedJobPostingCreateManyCreatedByInput | CreatedJobPostingCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type UserPipelineStepCommentCreateWithoutUserInput = {
    id?: string
    comment: string
    createdAt: string
    step: UserProcessStepCreateNestedOneWithoutCommentsInput
  }

  export type UserPipelineStepCommentUncheckedCreateWithoutUserInput = {
    id?: string
    userPipelineStepId: string
    comment: string
    createdAt: string
  }

  export type UserPipelineStepCommentCreateOrConnectWithoutUserInput = {
    where: UserPipelineStepCommentWhereUniqueInput
    create: XOR<UserPipelineStepCommentCreateWithoutUserInput, UserPipelineStepCommentUncheckedCreateWithoutUserInput>
  }

  export type UserPipelineStepCommentCreateManyUserInputEnvelope = {
    data: UserPipelineStepCommentCreateManyUserInput | UserPipelineStepCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProcessStepCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    icon?: string | null
    order: number
    process: ProcessCreateNestedOneWithoutStepsInput
    triggers?: TriggerDefinitionCreateNestedManyWithoutStepInput
    actions?: ActionDefinitionCreateNestedManyWithoutStepInput
    userProcessSteps?: UserProcessStepCreateNestedManyWithoutStepInput
  }

  export type ProcessStepUncheckedCreateWithoutUserInput = {
    id?: string
    processId: string
    title: string
    description: string
    icon?: string | null
    order: number
    triggers?: TriggerDefinitionUncheckedCreateNestedManyWithoutStepInput
    actions?: ActionDefinitionUncheckedCreateNestedManyWithoutStepInput
    userProcessSteps?: UserProcessStepUncheckedCreateNestedManyWithoutStepInput
  }

  export type ProcessStepCreateOrConnectWithoutUserInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutUserInput, ProcessStepUncheckedCreateWithoutUserInput>
  }

  export type ProcessStepCreateManyUserInputEnvelope = {
    data: ProcessStepCreateManyUserInput | ProcessStepCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProcessCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    isTemplate: boolean
    isPublic?: boolean
    steps?: ProcessStepCreateNestedManyWithoutProcessInput
    processes?: UserProcessCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    isTemplate: boolean
    isPublic?: boolean
    steps?: ProcessStepUncheckedCreateNestedManyWithoutProcessInput
    processes?: UserProcessUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutUserInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput>
  }

  export type ProcessCreateManyUserInputEnvelope = {
    data: ProcessCreateManyUserInput | ProcessCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TodoCreateWithoutUserInput = {
    id?: string
    title: string
    dueDate: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TodoItemCreateNestedManyWithoutTodoInput
    userProcesses?: TodoUserProcessCreateNestedManyWithoutTodoInput
  }

  export type TodoUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    dueDate: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TodoItemUncheckedCreateNestedManyWithoutTodoInput
    userProcesses?: TodoUserProcessUncheckedCreateNestedManyWithoutTodoInput
  }

  export type TodoCreateOrConnectWithoutUserInput = {
    where: TodoWhereUniqueInput
    create: XOR<TodoCreateWithoutUserInput, TodoUncheckedCreateWithoutUserInput>
  }

  export type TodoCreateManyUserInputEnvelope = {
    data: TodoCreateManyUserInput | TodoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProviderUpsertWithWhereUniqueWithoutUserInput = {
    where: ProviderWhereUniqueInput
    update: XOR<ProviderUpdateWithoutUserInput, ProviderUncheckedUpdateWithoutUserInput>
    create: XOR<ProviderCreateWithoutUserInput, ProviderUncheckedCreateWithoutUserInput>
  }

  export type ProviderUpdateWithWhereUniqueWithoutUserInput = {
    where: ProviderWhereUniqueInput
    data: XOR<ProviderUpdateWithoutUserInput, ProviderUncheckedUpdateWithoutUserInput>
  }

  export type ProviderUpdateManyWithWhereWithoutUserInput = {
    where: ProviderScalarWhereInput
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyWithoutUserInput>
  }

  export type ProviderScalarWhereInput = {
    AND?: ProviderScalarWhereInput | ProviderScalarWhereInput[]
    OR?: ProviderScalarWhereInput[]
    NOT?: ProviderScalarWhereInput | ProviderScalarWhereInput[]
    id?: StringFilter<"Provider"> | string
    userId?: StringFilter<"Provider"> | string
    provider?: EnumProviderEnumFilter<"Provider"> | $Enums.ProviderEnum
    providerAccountId?: StringFilter<"Provider"> | string
  }

  export type JobApplicantsUpsertWithWhereUniqueWithoutUserInput = {
    where: JobApplicantsWhereUniqueInput
    update: XOR<JobApplicantsUpdateWithoutUserInput, JobApplicantsUncheckedUpdateWithoutUserInput>
    create: XOR<JobApplicantsCreateWithoutUserInput, JobApplicantsUncheckedCreateWithoutUserInput>
  }

  export type JobApplicantsUpdateWithWhereUniqueWithoutUserInput = {
    where: JobApplicantsWhereUniqueInput
    data: XOR<JobApplicantsUpdateWithoutUserInput, JobApplicantsUncheckedUpdateWithoutUserInput>
  }

  export type JobApplicantsUpdateManyWithWhereWithoutUserInput = {
    where: JobApplicantsScalarWhereInput
    data: XOR<JobApplicantsUpdateManyMutationInput, JobApplicantsUncheckedUpdateManyWithoutUserInput>
  }

  export type JobApplicantsScalarWhereInput = {
    AND?: JobApplicantsScalarWhereInput | JobApplicantsScalarWhereInput[]
    OR?: JobApplicantsScalarWhereInput[]
    NOT?: JobApplicantsScalarWhereInput | JobApplicantsScalarWhereInput[]
    id?: StringFilter<"JobApplicants"> | string
    userId?: StringFilter<"JobApplicants"> | string
    jobPostingId?: StringFilter<"JobApplicants"> | string
    status?: StringFilter<"JobApplicants"> | string
    appliedAt?: StringFilter<"JobApplicants"> | string
    gotJob?: BoolFilter<"JobApplicants"> | boolean
  }

  export type UserProcessUpsertWithWhereUniqueWithoutUserInput = {
    where: UserProcessWhereUniqueInput
    update: XOR<UserProcessUpdateWithoutUserInput, UserProcessUncheckedUpdateWithoutUserInput>
    create: XOR<UserProcessCreateWithoutUserInput, UserProcessUncheckedCreateWithoutUserInput>
  }

  export type UserProcessUpdateWithWhereUniqueWithoutUserInput = {
    where: UserProcessWhereUniqueInput
    data: XOR<UserProcessUpdateWithoutUserInput, UserProcessUncheckedUpdateWithoutUserInput>
  }

  export type UserProcessUpdateManyWithWhereWithoutUserInput = {
    where: UserProcessScalarWhereInput
    data: XOR<UserProcessUpdateManyMutationInput, UserProcessUncheckedUpdateManyWithoutUserInput>
  }

  export type UserProcessScalarWhereInput = {
    AND?: UserProcessScalarWhereInput | UserProcessScalarWhereInput[]
    OR?: UserProcessScalarWhereInput[]
    NOT?: UserProcessScalarWhereInput | UserProcessScalarWhereInput[]
    id?: StringFilter<"UserProcess"> | string
    userId?: StringFilter<"UserProcess"> | string
    status?: EnumStatusUserJobProcessesFilter<"UserProcess"> | $Enums.StatusUserJobProcesses
    startedAt?: StringNullableFilter<"UserProcess"> | string | null
    createdAt?: DateTimeFilter<"UserProcess"> | Date | string
    updatedAt?: DateTimeFilter<"UserProcess"> | Date | string
    completedAt?: StringNullableFilter<"UserProcess"> | string | null
    jobPostingId?: StringFilter<"UserProcess"> | string
    processId?: StringNullableFilter<"UserProcess"> | string | null
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostings?: JobPostingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostings?: JobPostingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CreatedJobPostingUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CreatedJobPostingWhereUniqueInput
    update: XOR<CreatedJobPostingUpdateWithoutCreatedByInput, CreatedJobPostingUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CreatedJobPostingCreateWithoutCreatedByInput, CreatedJobPostingUncheckedCreateWithoutCreatedByInput>
  }

  export type CreatedJobPostingUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CreatedJobPostingWhereUniqueInput
    data: XOR<CreatedJobPostingUpdateWithoutCreatedByInput, CreatedJobPostingUncheckedUpdateWithoutCreatedByInput>
  }

  export type CreatedJobPostingUpdateManyWithWhereWithoutCreatedByInput = {
    where: CreatedJobPostingScalarWhereInput
    data: XOR<CreatedJobPostingUpdateManyMutationInput, CreatedJobPostingUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CreatedJobPostingScalarWhereInput = {
    AND?: CreatedJobPostingScalarWhereInput | CreatedJobPostingScalarWhereInput[]
    OR?: CreatedJobPostingScalarWhereInput[]
    NOT?: CreatedJobPostingScalarWhereInput | CreatedJobPostingScalarWhereInput[]
    id?: StringFilter<"CreatedJobPosting"> | string
    jobPostingId?: StringFilter<"CreatedJobPosting"> | string
    createdByType?: EnumCreatedByEnumFilter<"CreatedJobPosting"> | $Enums.CreatedByEnum
    createdById?: StringNullableFilter<"CreatedJobPosting"> | string | null
    source?: EnumJobSourceEnumNullableFilter<"CreatedJobPosting"> | $Enums.JobSourceEnum | null
    importedAt?: DateTimeNullableFilter<"CreatedJobPosting"> | Date | string | null
  }

  export type UserPipelineStepCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPipelineStepCommentWhereUniqueInput
    update: XOR<UserPipelineStepCommentUpdateWithoutUserInput, UserPipelineStepCommentUncheckedUpdateWithoutUserInput>
    create: XOR<UserPipelineStepCommentCreateWithoutUserInput, UserPipelineStepCommentUncheckedCreateWithoutUserInput>
  }

  export type UserPipelineStepCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPipelineStepCommentWhereUniqueInput
    data: XOR<UserPipelineStepCommentUpdateWithoutUserInput, UserPipelineStepCommentUncheckedUpdateWithoutUserInput>
  }

  export type UserPipelineStepCommentUpdateManyWithWhereWithoutUserInput = {
    where: UserPipelineStepCommentScalarWhereInput
    data: XOR<UserPipelineStepCommentUpdateManyMutationInput, UserPipelineStepCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPipelineStepCommentScalarWhereInput = {
    AND?: UserPipelineStepCommentScalarWhereInput | UserPipelineStepCommentScalarWhereInput[]
    OR?: UserPipelineStepCommentScalarWhereInput[]
    NOT?: UserPipelineStepCommentScalarWhereInput | UserPipelineStepCommentScalarWhereInput[]
    id?: StringFilter<"UserPipelineStepComment"> | string
    userPipelineStepId?: StringFilter<"UserPipelineStepComment"> | string
    userId?: StringFilter<"UserPipelineStepComment"> | string
    comment?: StringFilter<"UserPipelineStepComment"> | string
    createdAt?: StringFilter<"UserPipelineStepComment"> | string
  }

  export type ProcessStepUpsertWithWhereUniqueWithoutUserInput = {
    where: ProcessStepWhereUniqueInput
    update: XOR<ProcessStepUpdateWithoutUserInput, ProcessStepUncheckedUpdateWithoutUserInput>
    create: XOR<ProcessStepCreateWithoutUserInput, ProcessStepUncheckedCreateWithoutUserInput>
  }

  export type ProcessStepUpdateWithWhereUniqueWithoutUserInput = {
    where: ProcessStepWhereUniqueInput
    data: XOR<ProcessStepUpdateWithoutUserInput, ProcessStepUncheckedUpdateWithoutUserInput>
  }

  export type ProcessStepUpdateManyWithWhereWithoutUserInput = {
    where: ProcessStepScalarWhereInput
    data: XOR<ProcessStepUpdateManyMutationInput, ProcessStepUncheckedUpdateManyWithoutUserInput>
  }

  export type ProcessStepScalarWhereInput = {
    AND?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
    OR?: ProcessStepScalarWhereInput[]
    NOT?: ProcessStepScalarWhereInput | ProcessStepScalarWhereInput[]
    id?: StringFilter<"ProcessStep"> | string
    processId?: StringFilter<"ProcessStep"> | string
    title?: StringFilter<"ProcessStep"> | string
    description?: StringFilter<"ProcessStep"> | string
    icon?: StringNullableFilter<"ProcessStep"> | string | null
    order?: IntFilter<"ProcessStep"> | number
    userId?: StringNullableFilter<"ProcessStep"> | string | null
  }

  export type ProcessUpsertWithWhereUniqueWithoutUserInput = {
    where: ProcessWhereUniqueInput
    update: XOR<ProcessUpdateWithoutUserInput, ProcessUncheckedUpdateWithoutUserInput>
    create: XOR<ProcessCreateWithoutUserInput, ProcessUncheckedCreateWithoutUserInput>
  }

  export type ProcessUpdateWithWhereUniqueWithoutUserInput = {
    where: ProcessWhereUniqueInput
    data: XOR<ProcessUpdateWithoutUserInput, ProcessUncheckedUpdateWithoutUserInput>
  }

  export type ProcessUpdateManyWithWhereWithoutUserInput = {
    where: ProcessScalarWhereInput
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyWithoutUserInput>
  }

  export type ProcessScalarWhereInput = {
    AND?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
    OR?: ProcessScalarWhereInput[]
    NOT?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
    id?: StringFilter<"Process"> | string
    name?: StringFilter<"Process"> | string
    description?: StringNullableFilter<"Process"> | string | null
    icon?: StringNullableFilter<"Process"> | string | null
    ownerId?: StringNullableFilter<"Process"> | string | null
    isTemplate?: BoolFilter<"Process"> | boolean
    isPublic?: BoolFilter<"Process"> | boolean
  }

  export type TodoUpsertWithWhereUniqueWithoutUserInput = {
    where: TodoWhereUniqueInput
    update: XOR<TodoUpdateWithoutUserInput, TodoUncheckedUpdateWithoutUserInput>
    create: XOR<TodoCreateWithoutUserInput, TodoUncheckedCreateWithoutUserInput>
  }

  export type TodoUpdateWithWhereUniqueWithoutUserInput = {
    where: TodoWhereUniqueInput
    data: XOR<TodoUpdateWithoutUserInput, TodoUncheckedUpdateWithoutUserInput>
  }

  export type TodoUpdateManyWithWhereWithoutUserInput = {
    where: TodoScalarWhereInput
    data: XOR<TodoUpdateManyMutationInput, TodoUncheckedUpdateManyWithoutUserInput>
  }

  export type TodoScalarWhereInput = {
    AND?: TodoScalarWhereInput | TodoScalarWhereInput[]
    OR?: TodoScalarWhereInput[]
    NOT?: TodoScalarWhereInput | TodoScalarWhereInput[]
    id?: StringFilter<"Todo"> | string
    userId?: StringFilter<"Todo"> | string
    title?: StringFilter<"Todo"> | string
    dueDate?: DateTimeFilter<"Todo"> | Date | string
    completed?: BoolFilter<"Todo"> | boolean
    completedAt?: DateTimeNullableFilter<"Todo"> | Date | string | null
    createdAt?: DateTimeFilter<"Todo"> | Date | string
    updatedAt?: DateTimeFilter<"Todo"> | Date | string
  }

  export type TokenCreateWithoutProviderInput = {
    id?: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type TokenUncheckedCreateWithoutProviderInput = {
    id?: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type TokenCreateOrConnectWithoutProviderInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutProviderInput, TokenUncheckedCreateWithoutProviderInput>
  }

  export type UserCreateWithoutProvidersInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    applications?: JobApplicantsCreateNestedManyWithoutUserInput
    userProcess?: UserProcessCreateNestedManyWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    createdJobPostings?: CreatedJobPostingCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepCreateNestedManyWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProvidersInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    companyId?: string | null
    applications?: JobApplicantsUncheckedCreateNestedManyWithoutUserInput
    userProcess?: UserProcessUncheckedCreateNestedManyWithoutUserInput
    createdJobPostings?: CreatedJobPostingUncheckedCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutUserInput
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProvidersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProvidersInput, UserUncheckedCreateWithoutProvidersInput>
  }

  export type TokenUpsertWithoutProviderInput = {
    update: XOR<TokenUpdateWithoutProviderInput, TokenUncheckedUpdateWithoutProviderInput>
    create: XOR<TokenCreateWithoutProviderInput, TokenUncheckedCreateWithoutProviderInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutProviderInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutProviderInput, TokenUncheckedUpdateWithoutProviderInput>
  }

  export type TokenUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TokenUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutProvidersInput = {
    update: XOR<UserUpdateWithoutProvidersInput, UserUncheckedUpdateWithoutProvidersInput>
    create: XOR<UserCreateWithoutProvidersInput, UserUncheckedCreateWithoutProvidersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProvidersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProvidersInput, UserUncheckedUpdateWithoutProvidersInput>
  }

  export type UserUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    applications?: JobApplicantsUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    createdJobPostings?: CreatedJobPostingUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUpdateManyWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    applications?: JobApplicantsUncheckedUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUncheckedUpdateManyWithoutUserNestedInput
    createdJobPostings?: CreatedJobPostingUncheckedUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutUserNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProviderCreateWithoutTokenInput = {
    id?: string
    provider: $Enums.ProviderEnum
    providerAccountId: string
    user: UserCreateNestedOneWithoutProvidersInput
  }

  export type ProviderUncheckedCreateWithoutTokenInput = {
    id?: string
    userId: string
    provider: $Enums.ProviderEnum
    providerAccountId: string
  }

  export type ProviderCreateOrConnectWithoutTokenInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutTokenInput, ProviderUncheckedCreateWithoutTokenInput>
  }

  export type ProviderUpsertWithoutTokenInput = {
    update: XOR<ProviderUpdateWithoutTokenInput, ProviderUncheckedUpdateWithoutTokenInput>
    create: XOR<ProviderCreateWithoutTokenInput, ProviderUncheckedCreateWithoutTokenInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutTokenInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutTokenInput, ProviderUncheckedUpdateWithoutTokenInput>
  }

  export type ProviderUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderEnumFieldUpdateOperationsInput | $Enums.ProviderEnum
    providerAccountId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutProvidersNestedInput
  }

  export type ProviderUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderEnumFieldUpdateOperationsInput | $Enums.ProviderEnum
    providerAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    providers?: ProviderCreateNestedManyWithoutUserInput
    applications?: JobApplicantsCreateNestedManyWithoutUserInput
    userProcess?: UserProcessCreateNestedManyWithoutUserInput
    createdJobPostings?: CreatedJobPostingCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepCreateNestedManyWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    providers?: ProviderUncheckedCreateNestedManyWithoutUserInput
    applications?: JobApplicantsUncheckedCreateNestedManyWithoutUserInput
    userProcess?: UserProcessUncheckedCreateNestedManyWithoutUserInput
    createdJobPostings?: CreatedJobPostingUncheckedCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutUserInput
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: UserCreateManyCompanyInput | UserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type JobPostingCreateWithoutCompanyInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    language?: JobPostingLanguageCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingCreateNestedOneWithoutJobPostingInput
    userJobApplications?: JobApplicantsCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingUncheckedCreateWithoutCompanyInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    language?: JobPostingLanguageUncheckedCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementUncheckedCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritUncheckedCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityUncheckedCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationUncheckedCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentUncheckedCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeUncheckedCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryUncheckedCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingUncheckedCreateNestedOneWithoutJobPostingInput
    userJobApplications?: JobApplicantsUncheckedCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessUncheckedCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingCreateOrConnectWithoutCompanyInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutCompanyInput, JobPostingUncheckedCreateWithoutCompanyInput>
  }

  export type JobPostingCreateManyCompanyInputEnvelope = {
    data: JobPostingCreateManyCompanyInput | JobPostingCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    companyId?: StringNullableFilter<"User"> | string | null
  }

  export type JobPostingUpsertWithWhereUniqueWithoutCompanyInput = {
    where: JobPostingWhereUniqueInput
    update: XOR<JobPostingUpdateWithoutCompanyInput, JobPostingUncheckedUpdateWithoutCompanyInput>
    create: XOR<JobPostingCreateWithoutCompanyInput, JobPostingUncheckedCreateWithoutCompanyInput>
  }

  export type JobPostingUpdateWithWhereUniqueWithoutCompanyInput = {
    where: JobPostingWhereUniqueInput
    data: XOR<JobPostingUpdateWithoutCompanyInput, JobPostingUncheckedUpdateWithoutCompanyInput>
  }

  export type JobPostingUpdateManyWithWhereWithoutCompanyInput = {
    where: JobPostingScalarWhereInput
    data: XOR<JobPostingUpdateManyMutationInput, JobPostingUncheckedUpdateManyWithoutCompanyInput>
  }

  export type JobPostingScalarWhereInput = {
    AND?: JobPostingScalarWhereInput | JobPostingScalarWhereInput[]
    OR?: JobPostingScalarWhereInput[]
    NOT?: JobPostingScalarWhereInput | JobPostingScalarWhereInput[]
    id?: StringFilter<"JobPosting"> | string
    title?: StringFilter<"JobPosting"> | string
    companyName?: StringFilter<"JobPosting"> | string
    companyLogo?: StringNullableFilter<"JobPosting"> | string | null
    jobPostingUrl?: StringFilter<"JobPosting"> | string
    jobDescription?: StringFilter<"JobPosting"> | string
    markdownText?: StringFilter<"JobPosting"> | string
    status?: StringFilter<"JobPosting"> | string
    endsAt?: StringNullableFilter<"JobPosting"> | string | null
    createdAt?: StringFilter<"JobPosting"> | string
    updatedAt?: StringFilter<"JobPosting"> | string
    companyId?: StringNullableFilter<"JobPosting"> | string | null
  }

  export type JobPostingLanguageCreateWithoutJobPostingInput = {
    id?: string
    language: string
    level?: string | null
  }

  export type JobPostingLanguageUncheckedCreateWithoutJobPostingInput = {
    id?: string
    language: string
    level?: string | null
  }

  export type JobPostingLanguageCreateOrConnectWithoutJobPostingInput = {
    where: JobPostingLanguageWhereUniqueInput
    create: XOR<JobPostingLanguageCreateWithoutJobPostingInput, JobPostingLanguageUncheckedCreateWithoutJobPostingInput>
  }

  export type JobPostingLanguageCreateManyJobPostingInputEnvelope = {
    data: JobPostingLanguageCreateManyJobPostingInput | JobPostingLanguageCreateManyJobPostingInput[]
    skipDuplicates?: boolean
  }

  export type JobPostingRequirementCreateWithoutJobPostingInput = {
    id?: string
    requirement: string
  }

  export type JobPostingRequirementUncheckedCreateWithoutJobPostingInput = {
    id?: string
    requirement: string
  }

  export type JobPostingRequirementCreateOrConnectWithoutJobPostingInput = {
    where: JobPostingRequirementWhereUniqueInput
    create: XOR<JobPostingRequirementCreateWithoutJobPostingInput, JobPostingRequirementUncheckedCreateWithoutJobPostingInput>
  }

  export type JobPostingRequirementCreateManyJobPostingInputEnvelope = {
    data: JobPostingRequirementCreateManyJobPostingInput | JobPostingRequirementCreateManyJobPostingInput[]
    skipDuplicates?: boolean
  }

  export type JobPostingMeritCreateWithoutJobPostingInput = {
    id?: string
    merit: string
  }

  export type JobPostingMeritUncheckedCreateWithoutJobPostingInput = {
    id?: string
    merit: string
  }

  export type JobPostingMeritCreateOrConnectWithoutJobPostingInput = {
    where: JobPostingMeritWhereUniqueInput
    create: XOR<JobPostingMeritCreateWithoutJobPostingInput, JobPostingMeritUncheckedCreateWithoutJobPostingInput>
  }

  export type JobPostingMeritCreateManyJobPostingInputEnvelope = {
    data: JobPostingMeritCreateManyJobPostingInput | JobPostingMeritCreateManyJobPostingInput[]
    skipDuplicates?: boolean
  }

  export type JobPostingApplicantQualityCreateWithoutJobPostingInput = {
    id?: string
    quality: string
  }

  export type JobPostingApplicantQualityUncheckedCreateWithoutJobPostingInput = {
    id?: string
    quality: string
  }

  export type JobPostingApplicantQualityCreateOrConnectWithoutJobPostingInput = {
    where: JobPostingApplicantQualityWhereUniqueInput
    create: XOR<JobPostingApplicantQualityCreateWithoutJobPostingInput, JobPostingApplicantQualityUncheckedCreateWithoutJobPostingInput>
  }

  export type JobPostingApplicantQualityCreateManyJobPostingInputEnvelope = {
    data: JobPostingApplicantQualityCreateManyJobPostingInput | JobPostingApplicantQualityCreateManyJobPostingInput[]
    skipDuplicates?: boolean
  }

  export type JobPostingLocationCreateWithoutJobPostingInput = {
    id?: string
    city?: string | null
    region?: string | null
    country?: string
    isRemote?: boolean
    lat?: number | null
    lng?: number | null
  }

  export type JobPostingLocationUncheckedCreateWithoutJobPostingInput = {
    id?: string
    city?: string | null
    region?: string | null
    country?: string
    isRemote?: boolean
    lat?: number | null
    lng?: number | null
  }

  export type JobPostingLocationCreateOrConnectWithoutJobPostingInput = {
    where: JobPostingLocationWhereUniqueInput
    create: XOR<JobPostingLocationCreateWithoutJobPostingInput, JobPostingLocationUncheckedCreateWithoutJobPostingInput>
  }

  export type JobPostingWorkArrengmentCreateWithoutJobPostingInput = {
    id?: string
    mode: string
  }

  export type JobPostingWorkArrengmentUncheckedCreateWithoutJobPostingInput = {
    id?: string
    mode: string
  }

  export type JobPostingWorkArrengmentCreateOrConnectWithoutJobPostingInput = {
    where: JobPostingWorkArrengmentWhereUniqueInput
    create: XOR<JobPostingWorkArrengmentCreateWithoutJobPostingInput, JobPostingWorkArrengmentUncheckedCreateWithoutJobPostingInput>
  }

  export type JobPostingEmploymentTypeCreateWithoutJobPostingInput = {
    id?: string
    type: string
  }

  export type JobPostingEmploymentTypeUncheckedCreateWithoutJobPostingInput = {
    id?: string
    type: string
  }

  export type JobPostingEmploymentTypeCreateOrConnectWithoutJobPostingInput = {
    where: JobPostingEmploymentTypeWhereUniqueInput
    create: XOR<JobPostingEmploymentTypeCreateWithoutJobPostingInput, JobPostingEmploymentTypeUncheckedCreateWithoutJobPostingInput>
  }

  export type JobPostingSalaryCreateWithoutJobPostingInput = {
    id?: string
    type: string
    amount?: string | null
    currency?: string
    period?: string
    benefits?: JobPostingSalaryCreatebenefitsInput | string[]
    notes?: string | null
  }

  export type JobPostingSalaryUncheckedCreateWithoutJobPostingInput = {
    id?: string
    type: string
    amount?: string | null
    currency?: string
    period?: string
    benefits?: JobPostingSalaryCreatebenefitsInput | string[]
    notes?: string | null
  }

  export type JobPostingSalaryCreateOrConnectWithoutJobPostingInput = {
    where: JobPostingSalaryWhereUniqueInput
    create: XOR<JobPostingSalaryCreateWithoutJobPostingInput, JobPostingSalaryUncheckedCreateWithoutJobPostingInput>
  }

  export type CreatedJobPostingCreateWithoutJobPostingInput = {
    id?: string
    createdByType: $Enums.CreatedByEnum
    source?: $Enums.JobSourceEnum | null
    importedAt?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutCreatedJobPostingsInput
  }

  export type CreatedJobPostingUncheckedCreateWithoutJobPostingInput = {
    id?: string
    createdByType: $Enums.CreatedByEnum
    createdById?: string | null
    source?: $Enums.JobSourceEnum | null
    importedAt?: Date | string | null
  }

  export type CreatedJobPostingCreateOrConnectWithoutJobPostingInput = {
    where: CreatedJobPostingWhereUniqueInput
    create: XOR<CreatedJobPostingCreateWithoutJobPostingInput, CreatedJobPostingUncheckedCreateWithoutJobPostingInput>
  }

  export type CompanyCreateWithoutJobPostingsInput = {
    id?: string
    name: string
    logo?: string | null
    users?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutJobPostingsInput = {
    id?: string
    name: string
    logo?: string | null
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutJobPostingsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutJobPostingsInput, CompanyUncheckedCreateWithoutJobPostingsInput>
  }

  export type JobApplicantsCreateWithoutJobPostingInput = {
    id?: string
    status?: string
    appliedAt: string
    gotJob?: boolean
    user: UserCreateNestedOneWithoutApplicationsInput
  }

  export type JobApplicantsUncheckedCreateWithoutJobPostingInput = {
    id?: string
    userId: string
    status?: string
    appliedAt: string
    gotJob?: boolean
  }

  export type JobApplicantsCreateOrConnectWithoutJobPostingInput = {
    where: JobApplicantsWhereUniqueInput
    create: XOR<JobApplicantsCreateWithoutJobPostingInput, JobApplicantsUncheckedCreateWithoutJobPostingInput>
  }

  export type JobApplicantsCreateManyJobPostingInputEnvelope = {
    data: JobApplicantsCreateManyJobPostingInput | JobApplicantsCreateManyJobPostingInput[]
    skipDuplicates?: boolean
  }

  export type UserProcessCreateWithoutJobPostingInput = {
    id?: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    user: UserCreateNestedOneWithoutUserProcessInput
    steps?: UserProcessStepCreateNestedManyWithoutProcessInput
    process?: ProcessCreateNestedOneWithoutProcessesInput
    todos?: TodoUserProcessCreateNestedManyWithoutUserProcessInput
  }

  export type UserProcessUncheckedCreateWithoutJobPostingInput = {
    id?: string
    userId: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    processId?: string | null
    steps?: UserProcessStepUncheckedCreateNestedManyWithoutProcessInput
    todos?: TodoUserProcessUncheckedCreateNestedManyWithoutUserProcessInput
  }

  export type UserProcessCreateOrConnectWithoutJobPostingInput = {
    where: UserProcessWhereUniqueInput
    create: XOR<UserProcessCreateWithoutJobPostingInput, UserProcessUncheckedCreateWithoutJobPostingInput>
  }

  export type UserProcessCreateManyJobPostingInputEnvelope = {
    data: UserProcessCreateManyJobPostingInput | UserProcessCreateManyJobPostingInput[]
    skipDuplicates?: boolean
  }

  export type JobPostingLanguageUpsertWithWhereUniqueWithoutJobPostingInput = {
    where: JobPostingLanguageWhereUniqueInput
    update: XOR<JobPostingLanguageUpdateWithoutJobPostingInput, JobPostingLanguageUncheckedUpdateWithoutJobPostingInput>
    create: XOR<JobPostingLanguageCreateWithoutJobPostingInput, JobPostingLanguageUncheckedCreateWithoutJobPostingInput>
  }

  export type JobPostingLanguageUpdateWithWhereUniqueWithoutJobPostingInput = {
    where: JobPostingLanguageWhereUniqueInput
    data: XOR<JobPostingLanguageUpdateWithoutJobPostingInput, JobPostingLanguageUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobPostingLanguageUpdateManyWithWhereWithoutJobPostingInput = {
    where: JobPostingLanguageScalarWhereInput
    data: XOR<JobPostingLanguageUpdateManyMutationInput, JobPostingLanguageUncheckedUpdateManyWithoutJobPostingInput>
  }

  export type JobPostingLanguageScalarWhereInput = {
    AND?: JobPostingLanguageScalarWhereInput | JobPostingLanguageScalarWhereInput[]
    OR?: JobPostingLanguageScalarWhereInput[]
    NOT?: JobPostingLanguageScalarWhereInput | JobPostingLanguageScalarWhereInput[]
    id?: StringFilter<"JobPostingLanguage"> | string
    jobPostingId?: StringFilter<"JobPostingLanguage"> | string
    language?: StringFilter<"JobPostingLanguage"> | string
    level?: StringNullableFilter<"JobPostingLanguage"> | string | null
  }

  export type JobPostingRequirementUpsertWithWhereUniqueWithoutJobPostingInput = {
    where: JobPostingRequirementWhereUniqueInput
    update: XOR<JobPostingRequirementUpdateWithoutJobPostingInput, JobPostingRequirementUncheckedUpdateWithoutJobPostingInput>
    create: XOR<JobPostingRequirementCreateWithoutJobPostingInput, JobPostingRequirementUncheckedCreateWithoutJobPostingInput>
  }

  export type JobPostingRequirementUpdateWithWhereUniqueWithoutJobPostingInput = {
    where: JobPostingRequirementWhereUniqueInput
    data: XOR<JobPostingRequirementUpdateWithoutJobPostingInput, JobPostingRequirementUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobPostingRequirementUpdateManyWithWhereWithoutJobPostingInput = {
    where: JobPostingRequirementScalarWhereInput
    data: XOR<JobPostingRequirementUpdateManyMutationInput, JobPostingRequirementUncheckedUpdateManyWithoutJobPostingInput>
  }

  export type JobPostingRequirementScalarWhereInput = {
    AND?: JobPostingRequirementScalarWhereInput | JobPostingRequirementScalarWhereInput[]
    OR?: JobPostingRequirementScalarWhereInput[]
    NOT?: JobPostingRequirementScalarWhereInput | JobPostingRequirementScalarWhereInput[]
    id?: StringFilter<"JobPostingRequirement"> | string
    jobPostingId?: StringFilter<"JobPostingRequirement"> | string
    requirement?: StringFilter<"JobPostingRequirement"> | string
  }

  export type JobPostingMeritUpsertWithWhereUniqueWithoutJobPostingInput = {
    where: JobPostingMeritWhereUniqueInput
    update: XOR<JobPostingMeritUpdateWithoutJobPostingInput, JobPostingMeritUncheckedUpdateWithoutJobPostingInput>
    create: XOR<JobPostingMeritCreateWithoutJobPostingInput, JobPostingMeritUncheckedCreateWithoutJobPostingInput>
  }

  export type JobPostingMeritUpdateWithWhereUniqueWithoutJobPostingInput = {
    where: JobPostingMeritWhereUniqueInput
    data: XOR<JobPostingMeritUpdateWithoutJobPostingInput, JobPostingMeritUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobPostingMeritUpdateManyWithWhereWithoutJobPostingInput = {
    where: JobPostingMeritScalarWhereInput
    data: XOR<JobPostingMeritUpdateManyMutationInput, JobPostingMeritUncheckedUpdateManyWithoutJobPostingInput>
  }

  export type JobPostingMeritScalarWhereInput = {
    AND?: JobPostingMeritScalarWhereInput | JobPostingMeritScalarWhereInput[]
    OR?: JobPostingMeritScalarWhereInput[]
    NOT?: JobPostingMeritScalarWhereInput | JobPostingMeritScalarWhereInput[]
    id?: StringFilter<"JobPostingMerit"> | string
    jobPostingId?: StringFilter<"JobPostingMerit"> | string
    merit?: StringFilter<"JobPostingMerit"> | string
  }

  export type JobPostingApplicantQualityUpsertWithWhereUniqueWithoutJobPostingInput = {
    where: JobPostingApplicantQualityWhereUniqueInput
    update: XOR<JobPostingApplicantQualityUpdateWithoutJobPostingInput, JobPostingApplicantQualityUncheckedUpdateWithoutJobPostingInput>
    create: XOR<JobPostingApplicantQualityCreateWithoutJobPostingInput, JobPostingApplicantQualityUncheckedCreateWithoutJobPostingInput>
  }

  export type JobPostingApplicantQualityUpdateWithWhereUniqueWithoutJobPostingInput = {
    where: JobPostingApplicantQualityWhereUniqueInput
    data: XOR<JobPostingApplicantQualityUpdateWithoutJobPostingInput, JobPostingApplicantQualityUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobPostingApplicantQualityUpdateManyWithWhereWithoutJobPostingInput = {
    where: JobPostingApplicantQualityScalarWhereInput
    data: XOR<JobPostingApplicantQualityUpdateManyMutationInput, JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingInput>
  }

  export type JobPostingApplicantQualityScalarWhereInput = {
    AND?: JobPostingApplicantQualityScalarWhereInput | JobPostingApplicantQualityScalarWhereInput[]
    OR?: JobPostingApplicantQualityScalarWhereInput[]
    NOT?: JobPostingApplicantQualityScalarWhereInput | JobPostingApplicantQualityScalarWhereInput[]
    id?: StringFilter<"JobPostingApplicantQuality"> | string
    jobPostingId?: StringFilter<"JobPostingApplicantQuality"> | string
    quality?: StringFilter<"JobPostingApplicantQuality"> | string
  }

  export type JobPostingLocationUpsertWithoutJobPostingInput = {
    update: XOR<JobPostingLocationUpdateWithoutJobPostingInput, JobPostingLocationUncheckedUpdateWithoutJobPostingInput>
    create: XOR<JobPostingLocationCreateWithoutJobPostingInput, JobPostingLocationUncheckedCreateWithoutJobPostingInput>
    where?: JobPostingLocationWhereInput
  }

  export type JobPostingLocationUpdateToOneWithWhereWithoutJobPostingInput = {
    where?: JobPostingLocationWhereInput
    data: XOR<JobPostingLocationUpdateWithoutJobPostingInput, JobPostingLocationUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobPostingLocationUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type JobPostingLocationUncheckedUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type JobPostingWorkArrengmentUpsertWithoutJobPostingInput = {
    update: XOR<JobPostingWorkArrengmentUpdateWithoutJobPostingInput, JobPostingWorkArrengmentUncheckedUpdateWithoutJobPostingInput>
    create: XOR<JobPostingWorkArrengmentCreateWithoutJobPostingInput, JobPostingWorkArrengmentUncheckedCreateWithoutJobPostingInput>
    where?: JobPostingWorkArrengmentWhereInput
  }

  export type JobPostingWorkArrengmentUpdateToOneWithWhereWithoutJobPostingInput = {
    where?: JobPostingWorkArrengmentWhereInput
    data: XOR<JobPostingWorkArrengmentUpdateWithoutJobPostingInput, JobPostingWorkArrengmentUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobPostingWorkArrengmentUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingWorkArrengmentUncheckedUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingEmploymentTypeUpsertWithoutJobPostingInput = {
    update: XOR<JobPostingEmploymentTypeUpdateWithoutJobPostingInput, JobPostingEmploymentTypeUncheckedUpdateWithoutJobPostingInput>
    create: XOR<JobPostingEmploymentTypeCreateWithoutJobPostingInput, JobPostingEmploymentTypeUncheckedCreateWithoutJobPostingInput>
    where?: JobPostingEmploymentTypeWhereInput
  }

  export type JobPostingEmploymentTypeUpdateToOneWithWhereWithoutJobPostingInput = {
    where?: JobPostingEmploymentTypeWhereInput
    data: XOR<JobPostingEmploymentTypeUpdateWithoutJobPostingInput, JobPostingEmploymentTypeUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobPostingEmploymentTypeUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingEmploymentTypeUncheckedUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingSalaryUpsertWithoutJobPostingInput = {
    update: XOR<JobPostingSalaryUpdateWithoutJobPostingInput, JobPostingSalaryUncheckedUpdateWithoutJobPostingInput>
    create: XOR<JobPostingSalaryCreateWithoutJobPostingInput, JobPostingSalaryUncheckedCreateWithoutJobPostingInput>
    where?: JobPostingSalaryWhereInput
  }

  export type JobPostingSalaryUpdateToOneWithWhereWithoutJobPostingInput = {
    where?: JobPostingSalaryWhereInput
    data: XOR<JobPostingSalaryUpdateWithoutJobPostingInput, JobPostingSalaryUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobPostingSalaryUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    benefits?: JobPostingSalaryUpdatebenefitsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobPostingSalaryUncheckedUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    benefits?: JobPostingSalaryUpdatebenefitsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatedJobPostingUpsertWithoutJobPostingInput = {
    update: XOR<CreatedJobPostingUpdateWithoutJobPostingInput, CreatedJobPostingUncheckedUpdateWithoutJobPostingInput>
    create: XOR<CreatedJobPostingCreateWithoutJobPostingInput, CreatedJobPostingUncheckedCreateWithoutJobPostingInput>
    where?: CreatedJobPostingWhereInput
  }

  export type CreatedJobPostingUpdateToOneWithWhereWithoutJobPostingInput = {
    where?: CreatedJobPostingWhereInput
    data: XOR<CreatedJobPostingUpdateWithoutJobPostingInput, CreatedJobPostingUncheckedUpdateWithoutJobPostingInput>
  }

  export type CreatedJobPostingUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByType?: EnumCreatedByEnumFieldUpdateOperationsInput | $Enums.CreatedByEnum
    source?: NullableEnumJobSourceEnumFieldUpdateOperationsInput | $Enums.JobSourceEnum | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutCreatedJobPostingsNestedInput
  }

  export type CreatedJobPostingUncheckedUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByType?: EnumCreatedByEnumFieldUpdateOperationsInput | $Enums.CreatedByEnum
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableEnumJobSourceEnumFieldUpdateOperationsInput | $Enums.JobSourceEnum | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyUpsertWithoutJobPostingsInput = {
    update: XOR<CompanyUpdateWithoutJobPostingsInput, CompanyUncheckedUpdateWithoutJobPostingsInput>
    create: XOR<CompanyCreateWithoutJobPostingsInput, CompanyUncheckedCreateWithoutJobPostingsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutJobPostingsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutJobPostingsInput, CompanyUncheckedUpdateWithoutJobPostingsInput>
  }

  export type CompanyUpdateWithoutJobPostingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutJobPostingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type JobApplicantsUpsertWithWhereUniqueWithoutJobPostingInput = {
    where: JobApplicantsWhereUniqueInput
    update: XOR<JobApplicantsUpdateWithoutJobPostingInput, JobApplicantsUncheckedUpdateWithoutJobPostingInput>
    create: XOR<JobApplicantsCreateWithoutJobPostingInput, JobApplicantsUncheckedCreateWithoutJobPostingInput>
  }

  export type JobApplicantsUpdateWithWhereUniqueWithoutJobPostingInput = {
    where: JobApplicantsWhereUniqueInput
    data: XOR<JobApplicantsUpdateWithoutJobPostingInput, JobApplicantsUncheckedUpdateWithoutJobPostingInput>
  }

  export type JobApplicantsUpdateManyWithWhereWithoutJobPostingInput = {
    where: JobApplicantsScalarWhereInput
    data: XOR<JobApplicantsUpdateManyMutationInput, JobApplicantsUncheckedUpdateManyWithoutJobPostingInput>
  }

  export type UserProcessUpsertWithWhereUniqueWithoutJobPostingInput = {
    where: UserProcessWhereUniqueInput
    update: XOR<UserProcessUpdateWithoutJobPostingInput, UserProcessUncheckedUpdateWithoutJobPostingInput>
    create: XOR<UserProcessCreateWithoutJobPostingInput, UserProcessUncheckedCreateWithoutJobPostingInput>
  }

  export type UserProcessUpdateWithWhereUniqueWithoutJobPostingInput = {
    where: UserProcessWhereUniqueInput
    data: XOR<UserProcessUpdateWithoutJobPostingInput, UserProcessUncheckedUpdateWithoutJobPostingInput>
  }

  export type UserProcessUpdateManyWithWhereWithoutJobPostingInput = {
    where: UserProcessScalarWhereInput
    data: XOR<UserProcessUpdateManyMutationInput, UserProcessUncheckedUpdateManyWithoutJobPostingInput>
  }

  export type JobPostingCreateWithoutLanguageInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    jobRequirements?: JobPostingRequirementCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingCreateNestedOneWithoutJobPostingInput
    company?: CompanyCreateNestedOneWithoutJobPostingsInput
    userJobApplications?: JobApplicantsCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingUncheckedCreateWithoutLanguageInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    companyId?: string | null
    jobRequirements?: JobPostingRequirementUncheckedCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritUncheckedCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityUncheckedCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationUncheckedCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentUncheckedCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeUncheckedCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryUncheckedCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingUncheckedCreateNestedOneWithoutJobPostingInput
    userJobApplications?: JobApplicantsUncheckedCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessUncheckedCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingCreateOrConnectWithoutLanguageInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutLanguageInput, JobPostingUncheckedCreateWithoutLanguageInput>
  }

  export type JobPostingUpsertWithoutLanguageInput = {
    update: XOR<JobPostingUpdateWithoutLanguageInput, JobPostingUncheckedUpdateWithoutLanguageInput>
    create: XOR<JobPostingCreateWithoutLanguageInput, JobPostingUncheckedCreateWithoutLanguageInput>
    where?: JobPostingWhereInput
  }

  export type JobPostingUpdateToOneWithWhereWithoutLanguageInput = {
    where?: JobPostingWhereInput
    data: XOR<JobPostingUpdateWithoutLanguageInput, JobPostingUncheckedUpdateWithoutLanguageInput>
  }

  export type JobPostingUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    jobRequirements?: JobPostingRequirementUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUpdateOneWithoutJobPostingNestedInput
    company?: CompanyUpdateOneWithoutJobPostingsNestedInput
    userJobApplications?: JobApplicantsUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    jobRequirements?: JobPostingRequirementUncheckedUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUncheckedUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUncheckedUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUncheckedUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUncheckedUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUncheckedUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUncheckedUpdateOneWithoutJobPostingNestedInput
    userJobApplications?: JobApplicantsUncheckedUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUncheckedUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingCreateWithoutJobRequirementsInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    language?: JobPostingLanguageCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingCreateNestedOneWithoutJobPostingInput
    company?: CompanyCreateNestedOneWithoutJobPostingsInput
    userJobApplications?: JobApplicantsCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingUncheckedCreateWithoutJobRequirementsInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    companyId?: string | null
    language?: JobPostingLanguageUncheckedCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritUncheckedCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityUncheckedCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationUncheckedCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentUncheckedCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeUncheckedCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryUncheckedCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingUncheckedCreateNestedOneWithoutJobPostingInput
    userJobApplications?: JobApplicantsUncheckedCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessUncheckedCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingCreateOrConnectWithoutJobRequirementsInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutJobRequirementsInput, JobPostingUncheckedCreateWithoutJobRequirementsInput>
  }

  export type JobPostingUpsertWithoutJobRequirementsInput = {
    update: XOR<JobPostingUpdateWithoutJobRequirementsInput, JobPostingUncheckedUpdateWithoutJobRequirementsInput>
    create: XOR<JobPostingCreateWithoutJobRequirementsInput, JobPostingUncheckedCreateWithoutJobRequirementsInput>
    where?: JobPostingWhereInput
  }

  export type JobPostingUpdateToOneWithWhereWithoutJobRequirementsInput = {
    where?: JobPostingWhereInput
    data: XOR<JobPostingUpdateWithoutJobRequirementsInput, JobPostingUncheckedUpdateWithoutJobRequirementsInput>
  }

  export type JobPostingUpdateWithoutJobRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    language?: JobPostingLanguageUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUpdateOneWithoutJobPostingNestedInput
    company?: CompanyUpdateOneWithoutJobPostingsNestedInput
    userJobApplications?: JobApplicantsUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutJobRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    language?: JobPostingLanguageUncheckedUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUncheckedUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUncheckedUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUncheckedUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUncheckedUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUncheckedUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUncheckedUpdateOneWithoutJobPostingNestedInput
    userJobApplications?: JobApplicantsUncheckedUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUncheckedUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingCreateWithoutMeritsInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    language?: JobPostingLanguageCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingCreateNestedOneWithoutJobPostingInput
    company?: CompanyCreateNestedOneWithoutJobPostingsInput
    userJobApplications?: JobApplicantsCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingUncheckedCreateWithoutMeritsInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    companyId?: string | null
    language?: JobPostingLanguageUncheckedCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementUncheckedCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityUncheckedCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationUncheckedCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentUncheckedCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeUncheckedCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryUncheckedCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingUncheckedCreateNestedOneWithoutJobPostingInput
    userJobApplications?: JobApplicantsUncheckedCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessUncheckedCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingCreateOrConnectWithoutMeritsInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutMeritsInput, JobPostingUncheckedCreateWithoutMeritsInput>
  }

  export type JobPostingUpsertWithoutMeritsInput = {
    update: XOR<JobPostingUpdateWithoutMeritsInput, JobPostingUncheckedUpdateWithoutMeritsInput>
    create: XOR<JobPostingCreateWithoutMeritsInput, JobPostingUncheckedCreateWithoutMeritsInput>
    where?: JobPostingWhereInput
  }

  export type JobPostingUpdateToOneWithWhereWithoutMeritsInput = {
    where?: JobPostingWhereInput
    data: XOR<JobPostingUpdateWithoutMeritsInput, JobPostingUncheckedUpdateWithoutMeritsInput>
  }

  export type JobPostingUpdateWithoutMeritsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    language?: JobPostingLanguageUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUpdateOneWithoutJobPostingNestedInput
    company?: CompanyUpdateOneWithoutJobPostingsNestedInput
    userJobApplications?: JobApplicantsUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutMeritsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    language?: JobPostingLanguageUncheckedUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUncheckedUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUncheckedUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUncheckedUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUncheckedUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUncheckedUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUncheckedUpdateOneWithoutJobPostingNestedInput
    userJobApplications?: JobApplicantsUncheckedUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUncheckedUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingCreateWithoutApplicantQualitiesInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    language?: JobPostingLanguageCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingCreateNestedOneWithoutJobPostingInput
    company?: CompanyCreateNestedOneWithoutJobPostingsInput
    userJobApplications?: JobApplicantsCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingUncheckedCreateWithoutApplicantQualitiesInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    companyId?: string | null
    language?: JobPostingLanguageUncheckedCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementUncheckedCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritUncheckedCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationUncheckedCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentUncheckedCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeUncheckedCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryUncheckedCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingUncheckedCreateNestedOneWithoutJobPostingInput
    userJobApplications?: JobApplicantsUncheckedCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessUncheckedCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingCreateOrConnectWithoutApplicantQualitiesInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutApplicantQualitiesInput, JobPostingUncheckedCreateWithoutApplicantQualitiesInput>
  }

  export type JobPostingUpsertWithoutApplicantQualitiesInput = {
    update: XOR<JobPostingUpdateWithoutApplicantQualitiesInput, JobPostingUncheckedUpdateWithoutApplicantQualitiesInput>
    create: XOR<JobPostingCreateWithoutApplicantQualitiesInput, JobPostingUncheckedCreateWithoutApplicantQualitiesInput>
    where?: JobPostingWhereInput
  }

  export type JobPostingUpdateToOneWithWhereWithoutApplicantQualitiesInput = {
    where?: JobPostingWhereInput
    data: XOR<JobPostingUpdateWithoutApplicantQualitiesInput, JobPostingUncheckedUpdateWithoutApplicantQualitiesInput>
  }

  export type JobPostingUpdateWithoutApplicantQualitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    language?: JobPostingLanguageUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUpdateOneWithoutJobPostingNestedInput
    company?: CompanyUpdateOneWithoutJobPostingsNestedInput
    userJobApplications?: JobApplicantsUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutApplicantQualitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    language?: JobPostingLanguageUncheckedUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUncheckedUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUncheckedUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUncheckedUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUncheckedUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUncheckedUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUncheckedUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUncheckedUpdateOneWithoutJobPostingNestedInput
    userJobApplications?: JobApplicantsUncheckedUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUncheckedUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingCreateWithoutLocationInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    language?: JobPostingLanguageCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityCreateNestedManyWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingCreateNestedOneWithoutJobPostingInput
    company?: CompanyCreateNestedOneWithoutJobPostingsInput
    userJobApplications?: JobApplicantsCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingUncheckedCreateWithoutLocationInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    companyId?: string | null
    language?: JobPostingLanguageUncheckedCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementUncheckedCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritUncheckedCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityUncheckedCreateNestedManyWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentUncheckedCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeUncheckedCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryUncheckedCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingUncheckedCreateNestedOneWithoutJobPostingInput
    userJobApplications?: JobApplicantsUncheckedCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessUncheckedCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingCreateOrConnectWithoutLocationInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutLocationInput, JobPostingUncheckedCreateWithoutLocationInput>
  }

  export type JobPostingUpsertWithoutLocationInput = {
    update: XOR<JobPostingUpdateWithoutLocationInput, JobPostingUncheckedUpdateWithoutLocationInput>
    create: XOR<JobPostingCreateWithoutLocationInput, JobPostingUncheckedCreateWithoutLocationInput>
    where?: JobPostingWhereInput
  }

  export type JobPostingUpdateToOneWithWhereWithoutLocationInput = {
    where?: JobPostingWhereInput
    data: XOR<JobPostingUpdateWithoutLocationInput, JobPostingUncheckedUpdateWithoutLocationInput>
  }

  export type JobPostingUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    language?: JobPostingLanguageUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUpdateManyWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUpdateOneWithoutJobPostingNestedInput
    company?: CompanyUpdateOneWithoutJobPostingsNestedInput
    userJobApplications?: JobApplicantsUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    language?: JobPostingLanguageUncheckedUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUncheckedUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUncheckedUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUncheckedUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUncheckedUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUncheckedUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUncheckedUpdateOneWithoutJobPostingNestedInput
    userJobApplications?: JobApplicantsUncheckedUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUncheckedUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingCreateWithoutWorkArrengmentInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    language?: JobPostingLanguageCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingCreateNestedOneWithoutJobPostingInput
    company?: CompanyCreateNestedOneWithoutJobPostingsInput
    userJobApplications?: JobApplicantsCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingUncheckedCreateWithoutWorkArrengmentInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    companyId?: string | null
    language?: JobPostingLanguageUncheckedCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementUncheckedCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritUncheckedCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityUncheckedCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationUncheckedCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeUncheckedCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryUncheckedCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingUncheckedCreateNestedOneWithoutJobPostingInput
    userJobApplications?: JobApplicantsUncheckedCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessUncheckedCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingCreateOrConnectWithoutWorkArrengmentInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutWorkArrengmentInput, JobPostingUncheckedCreateWithoutWorkArrengmentInput>
  }

  export type JobPostingUpsertWithoutWorkArrengmentInput = {
    update: XOR<JobPostingUpdateWithoutWorkArrengmentInput, JobPostingUncheckedUpdateWithoutWorkArrengmentInput>
    create: XOR<JobPostingCreateWithoutWorkArrengmentInput, JobPostingUncheckedCreateWithoutWorkArrengmentInput>
    where?: JobPostingWhereInput
  }

  export type JobPostingUpdateToOneWithWhereWithoutWorkArrengmentInput = {
    where?: JobPostingWhereInput
    data: XOR<JobPostingUpdateWithoutWorkArrengmentInput, JobPostingUncheckedUpdateWithoutWorkArrengmentInput>
  }

  export type JobPostingUpdateWithoutWorkArrengmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    language?: JobPostingLanguageUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUpdateOneWithoutJobPostingNestedInput
    company?: CompanyUpdateOneWithoutJobPostingsNestedInput
    userJobApplications?: JobApplicantsUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutWorkArrengmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    language?: JobPostingLanguageUncheckedUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUncheckedUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUncheckedUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUncheckedUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUncheckedUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUncheckedUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUncheckedUpdateOneWithoutJobPostingNestedInput
    userJobApplications?: JobApplicantsUncheckedUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUncheckedUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingCreateWithoutEmploymentTypeInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    language?: JobPostingLanguageCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingCreateNestedOneWithoutJobPostingInput
    company?: CompanyCreateNestedOneWithoutJobPostingsInput
    userJobApplications?: JobApplicantsCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingUncheckedCreateWithoutEmploymentTypeInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    companyId?: string | null
    language?: JobPostingLanguageUncheckedCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementUncheckedCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritUncheckedCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityUncheckedCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationUncheckedCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentUncheckedCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryUncheckedCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingUncheckedCreateNestedOneWithoutJobPostingInput
    userJobApplications?: JobApplicantsUncheckedCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessUncheckedCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingCreateOrConnectWithoutEmploymentTypeInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutEmploymentTypeInput, JobPostingUncheckedCreateWithoutEmploymentTypeInput>
  }

  export type JobPostingUpsertWithoutEmploymentTypeInput = {
    update: XOR<JobPostingUpdateWithoutEmploymentTypeInput, JobPostingUncheckedUpdateWithoutEmploymentTypeInput>
    create: XOR<JobPostingCreateWithoutEmploymentTypeInput, JobPostingUncheckedCreateWithoutEmploymentTypeInput>
    where?: JobPostingWhereInput
  }

  export type JobPostingUpdateToOneWithWhereWithoutEmploymentTypeInput = {
    where?: JobPostingWhereInput
    data: XOR<JobPostingUpdateWithoutEmploymentTypeInput, JobPostingUncheckedUpdateWithoutEmploymentTypeInput>
  }

  export type JobPostingUpdateWithoutEmploymentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    language?: JobPostingLanguageUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUpdateOneWithoutJobPostingNestedInput
    company?: CompanyUpdateOneWithoutJobPostingsNestedInput
    userJobApplications?: JobApplicantsUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutEmploymentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    language?: JobPostingLanguageUncheckedUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUncheckedUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUncheckedUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUncheckedUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUncheckedUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUncheckedUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUncheckedUpdateOneWithoutJobPostingNestedInput
    userJobApplications?: JobApplicantsUncheckedUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUncheckedUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingCreateWithoutSalaryInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    language?: JobPostingLanguageCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingCreateNestedOneWithoutJobPostingInput
    company?: CompanyCreateNestedOneWithoutJobPostingsInput
    userJobApplications?: JobApplicantsCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingUncheckedCreateWithoutSalaryInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    companyId?: string | null
    language?: JobPostingLanguageUncheckedCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementUncheckedCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritUncheckedCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityUncheckedCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationUncheckedCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentUncheckedCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeUncheckedCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingUncheckedCreateNestedOneWithoutJobPostingInput
    userJobApplications?: JobApplicantsUncheckedCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessUncheckedCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingCreateOrConnectWithoutSalaryInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutSalaryInput, JobPostingUncheckedCreateWithoutSalaryInput>
  }

  export type JobPostingUpsertWithoutSalaryInput = {
    update: XOR<JobPostingUpdateWithoutSalaryInput, JobPostingUncheckedUpdateWithoutSalaryInput>
    create: XOR<JobPostingCreateWithoutSalaryInput, JobPostingUncheckedCreateWithoutSalaryInput>
    where?: JobPostingWhereInput
  }

  export type JobPostingUpdateToOneWithWhereWithoutSalaryInput = {
    where?: JobPostingWhereInput
    data: XOR<JobPostingUpdateWithoutSalaryInput, JobPostingUncheckedUpdateWithoutSalaryInput>
  }

  export type JobPostingUpdateWithoutSalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    language?: JobPostingLanguageUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUpdateOneWithoutJobPostingNestedInput
    company?: CompanyUpdateOneWithoutJobPostingsNestedInput
    userJobApplications?: JobApplicantsUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutSalaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    language?: JobPostingLanguageUncheckedUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUncheckedUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUncheckedUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUncheckedUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUncheckedUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUncheckedUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUncheckedUpdateOneWithoutJobPostingNestedInput
    userJobApplications?: JobApplicantsUncheckedUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUncheckedUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingCreateWithoutCreatedJobPostingInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    language?: JobPostingLanguageCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryCreateNestedOneWithoutJobPostingInput
    company?: CompanyCreateNestedOneWithoutJobPostingsInput
    userJobApplications?: JobApplicantsCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingUncheckedCreateWithoutCreatedJobPostingInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    companyId?: string | null
    language?: JobPostingLanguageUncheckedCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementUncheckedCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritUncheckedCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityUncheckedCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationUncheckedCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentUncheckedCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeUncheckedCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryUncheckedCreateNestedOneWithoutJobPostingInput
    userJobApplications?: JobApplicantsUncheckedCreateNestedManyWithoutJobPostingInput
    userProcesses?: UserProcessUncheckedCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingCreateOrConnectWithoutCreatedJobPostingInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutCreatedJobPostingInput, JobPostingUncheckedCreateWithoutCreatedJobPostingInput>
  }

  export type UserCreateWithoutCreatedJobPostingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    providers?: ProviderCreateNestedManyWithoutUserInput
    applications?: JobApplicantsCreateNestedManyWithoutUserInput
    userProcess?: UserProcessCreateNestedManyWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    userPipelineStepComments?: UserPipelineStepCommentCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepCreateNestedManyWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedJobPostingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    companyId?: string | null
    providers?: ProviderUncheckedCreateNestedManyWithoutUserInput
    applications?: JobApplicantsUncheckedCreateNestedManyWithoutUserInput
    userProcess?: UserProcessUncheckedCreateNestedManyWithoutUserInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutUserInput
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedJobPostingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedJobPostingsInput, UserUncheckedCreateWithoutCreatedJobPostingsInput>
  }

  export type JobPostingUpsertWithoutCreatedJobPostingInput = {
    update: XOR<JobPostingUpdateWithoutCreatedJobPostingInput, JobPostingUncheckedUpdateWithoutCreatedJobPostingInput>
    create: XOR<JobPostingCreateWithoutCreatedJobPostingInput, JobPostingUncheckedCreateWithoutCreatedJobPostingInput>
    where?: JobPostingWhereInput
  }

  export type JobPostingUpdateToOneWithWhereWithoutCreatedJobPostingInput = {
    where?: JobPostingWhereInput
    data: XOR<JobPostingUpdateWithoutCreatedJobPostingInput, JobPostingUncheckedUpdateWithoutCreatedJobPostingInput>
  }

  export type JobPostingUpdateWithoutCreatedJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    language?: JobPostingLanguageUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUpdateOneWithoutJobPostingNestedInput
    company?: CompanyUpdateOneWithoutJobPostingsNestedInput
    userJobApplications?: JobApplicantsUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutCreatedJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    language?: JobPostingLanguageUncheckedUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUncheckedUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUncheckedUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUncheckedUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUncheckedUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUncheckedUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUncheckedUpdateOneWithoutJobPostingNestedInput
    userJobApplications?: JobApplicantsUncheckedUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUncheckedUpdateManyWithoutJobPostingNestedInput
  }

  export type UserUpsertWithoutCreatedJobPostingsInput = {
    update: XOR<UserUpdateWithoutCreatedJobPostingsInput, UserUncheckedUpdateWithoutCreatedJobPostingsInput>
    create: XOR<UserCreateWithoutCreatedJobPostingsInput, UserUncheckedCreateWithoutCreatedJobPostingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedJobPostingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedJobPostingsInput, UserUncheckedUpdateWithoutCreatedJobPostingsInput>
  }

  export type UserUpdateWithoutCreatedJobPostingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUpdateManyWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedJobPostingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUncheckedUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUncheckedUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUncheckedUpdateManyWithoutUserNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutUserNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutApplicationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    providers?: ProviderCreateNestedManyWithoutUserInput
    userProcess?: UserProcessCreateNestedManyWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    createdJobPostings?: CreatedJobPostingCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepCreateNestedManyWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApplicationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    companyId?: string | null
    providers?: ProviderUncheckedCreateNestedManyWithoutUserInput
    userProcess?: UserProcessUncheckedCreateNestedManyWithoutUserInput
    createdJobPostings?: CreatedJobPostingUncheckedCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutUserInput
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
  }

  export type JobPostingCreateWithoutUserJobApplicationsInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    language?: JobPostingLanguageCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingCreateNestedOneWithoutJobPostingInput
    company?: CompanyCreateNestedOneWithoutJobPostingsInput
    userProcesses?: UserProcessCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingUncheckedCreateWithoutUserJobApplicationsInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    companyId?: string | null
    language?: JobPostingLanguageUncheckedCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementUncheckedCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritUncheckedCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityUncheckedCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationUncheckedCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentUncheckedCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeUncheckedCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryUncheckedCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingUncheckedCreateNestedOneWithoutJobPostingInput
    userProcesses?: UserProcessUncheckedCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingCreateOrConnectWithoutUserJobApplicationsInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutUserJobApplicationsInput, JobPostingUncheckedCreateWithoutUserJobApplicationsInput>
  }

  export type UserUpsertWithoutApplicationsInput = {
    update: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>
  }

  export type UserUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    createdJobPostings?: CreatedJobPostingUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUpdateManyWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUncheckedUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUncheckedUpdateManyWithoutUserNestedInput
    createdJobPostings?: CreatedJobPostingUncheckedUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutUserNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type JobPostingUpsertWithoutUserJobApplicationsInput = {
    update: XOR<JobPostingUpdateWithoutUserJobApplicationsInput, JobPostingUncheckedUpdateWithoutUserJobApplicationsInput>
    create: XOR<JobPostingCreateWithoutUserJobApplicationsInput, JobPostingUncheckedCreateWithoutUserJobApplicationsInput>
    where?: JobPostingWhereInput
  }

  export type JobPostingUpdateToOneWithWhereWithoutUserJobApplicationsInput = {
    where?: JobPostingWhereInput
    data: XOR<JobPostingUpdateWithoutUserJobApplicationsInput, JobPostingUncheckedUpdateWithoutUserJobApplicationsInput>
  }

  export type JobPostingUpdateWithoutUserJobApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    language?: JobPostingLanguageUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUpdateOneWithoutJobPostingNestedInput
    company?: CompanyUpdateOneWithoutJobPostingsNestedInput
    userProcesses?: UserProcessUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutUserJobApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    language?: JobPostingLanguageUncheckedUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUncheckedUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUncheckedUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUncheckedUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUncheckedUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUncheckedUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUncheckedUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUncheckedUpdateOneWithoutJobPostingNestedInput
    userProcesses?: UserProcessUncheckedUpdateManyWithoutJobPostingNestedInput
  }

  export type UserCreateWithoutUserProcessInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    providers?: ProviderCreateNestedManyWithoutUserInput
    applications?: JobApplicantsCreateNestedManyWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    createdJobPostings?: CreatedJobPostingCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepCreateNestedManyWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserProcessInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    companyId?: string | null
    providers?: ProviderUncheckedCreateNestedManyWithoutUserInput
    applications?: JobApplicantsUncheckedCreateNestedManyWithoutUserInput
    createdJobPostings?: CreatedJobPostingUncheckedCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutUserInput
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserProcessInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserProcessInput, UserUncheckedCreateWithoutUserProcessInput>
  }

  export type UserProcessStepCreateWithoutProcessInput = {
    id?: string
    isExecuted?: boolean
    executedAt?: string | null
    comments?: UserPipelineStepCommentCreateNestedManyWithoutStepInput
    step?: ProcessStepCreateNestedOneWithoutUserProcessStepsInput
  }

  export type UserProcessStepUncheckedCreateWithoutProcessInput = {
    id?: string
    stepId?: string | null
    isExecuted?: boolean
    executedAt?: string | null
    comments?: UserPipelineStepCommentUncheckedCreateNestedManyWithoutStepInput
  }

  export type UserProcessStepCreateOrConnectWithoutProcessInput = {
    where: UserProcessStepWhereUniqueInput
    create: XOR<UserProcessStepCreateWithoutProcessInput, UserProcessStepUncheckedCreateWithoutProcessInput>
  }

  export type UserProcessStepCreateManyProcessInputEnvelope = {
    data: UserProcessStepCreateManyProcessInput | UserProcessStepCreateManyProcessInput[]
    skipDuplicates?: boolean
  }

  export type JobPostingCreateWithoutUserProcessesInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    language?: JobPostingLanguageCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingCreateNestedOneWithoutJobPostingInput
    company?: CompanyCreateNestedOneWithoutJobPostingsInput
    userJobApplications?: JobApplicantsCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingUncheckedCreateWithoutUserProcessesInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
    companyId?: string | null
    language?: JobPostingLanguageUncheckedCreateNestedManyWithoutJobPostingInput
    jobRequirements?: JobPostingRequirementUncheckedCreateNestedManyWithoutJobPostingInput
    merits?: JobPostingMeritUncheckedCreateNestedManyWithoutJobPostingInput
    applicantQualities?: JobPostingApplicantQualityUncheckedCreateNestedManyWithoutJobPostingInput
    location?: JobPostingLocationUncheckedCreateNestedOneWithoutJobPostingInput
    workArrengment?: JobPostingWorkArrengmentUncheckedCreateNestedOneWithoutJobPostingInput
    employmentType?: JobPostingEmploymentTypeUncheckedCreateNestedOneWithoutJobPostingInput
    salary?: JobPostingSalaryUncheckedCreateNestedOneWithoutJobPostingInput
    createdJobPosting?: CreatedJobPostingUncheckedCreateNestedOneWithoutJobPostingInput
    userJobApplications?: JobApplicantsUncheckedCreateNestedManyWithoutJobPostingInput
  }

  export type JobPostingCreateOrConnectWithoutUserProcessesInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutUserProcessesInput, JobPostingUncheckedCreateWithoutUserProcessesInput>
  }

  export type ProcessCreateWithoutProcessesInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    isTemplate: boolean
    isPublic?: boolean
    user?: UserCreateNestedOneWithoutProcessesInput
    steps?: ProcessStepCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutProcessesInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    ownerId?: string | null
    isTemplate: boolean
    isPublic?: boolean
    steps?: ProcessStepUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutProcessesInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutProcessesInput, ProcessUncheckedCreateWithoutProcessesInput>
  }

  export type TodoUserProcessCreateWithoutUserProcessInput = {
    id?: string
    todo: TodoCreateNestedOneWithoutUserProcessesInput
  }

  export type TodoUserProcessUncheckedCreateWithoutUserProcessInput = {
    id?: string
    todoId: string
  }

  export type TodoUserProcessCreateOrConnectWithoutUserProcessInput = {
    where: TodoUserProcessWhereUniqueInput
    create: XOR<TodoUserProcessCreateWithoutUserProcessInput, TodoUserProcessUncheckedCreateWithoutUserProcessInput>
  }

  export type TodoUserProcessCreateManyUserProcessInputEnvelope = {
    data: TodoUserProcessCreateManyUserProcessInput | TodoUserProcessCreateManyUserProcessInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUserProcessInput = {
    update: XOR<UserUpdateWithoutUserProcessInput, UserUncheckedUpdateWithoutUserProcessInput>
    create: XOR<UserCreateWithoutUserProcessInput, UserUncheckedCreateWithoutUserProcessInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserProcessInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserProcessInput, UserUncheckedUpdateWithoutUserProcessInput>
  }

  export type UserUpdateWithoutUserProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    createdJobPostings?: CreatedJobPostingUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUpdateManyWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUncheckedUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUncheckedUpdateManyWithoutUserNestedInput
    createdJobPostings?: CreatedJobPostingUncheckedUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutUserNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserProcessStepUpsertWithWhereUniqueWithoutProcessInput = {
    where: UserProcessStepWhereUniqueInput
    update: XOR<UserProcessStepUpdateWithoutProcessInput, UserProcessStepUncheckedUpdateWithoutProcessInput>
    create: XOR<UserProcessStepCreateWithoutProcessInput, UserProcessStepUncheckedCreateWithoutProcessInput>
  }

  export type UserProcessStepUpdateWithWhereUniqueWithoutProcessInput = {
    where: UserProcessStepWhereUniqueInput
    data: XOR<UserProcessStepUpdateWithoutProcessInput, UserProcessStepUncheckedUpdateWithoutProcessInput>
  }

  export type UserProcessStepUpdateManyWithWhereWithoutProcessInput = {
    where: UserProcessStepScalarWhereInput
    data: XOR<UserProcessStepUpdateManyMutationInput, UserProcessStepUncheckedUpdateManyWithoutProcessInput>
  }

  export type UserProcessStepScalarWhereInput = {
    AND?: UserProcessStepScalarWhereInput | UserProcessStepScalarWhereInput[]
    OR?: UserProcessStepScalarWhereInput[]
    NOT?: UserProcessStepScalarWhereInput | UserProcessStepScalarWhereInput[]
    id?: StringFilter<"UserProcessStep"> | string
    userProcessId?: StringFilter<"UserProcessStep"> | string
    stepId?: StringNullableFilter<"UserProcessStep"> | string | null
    isExecuted?: BoolFilter<"UserProcessStep"> | boolean
    executedAt?: StringNullableFilter<"UserProcessStep"> | string | null
  }

  export type JobPostingUpsertWithoutUserProcessesInput = {
    update: XOR<JobPostingUpdateWithoutUserProcessesInput, JobPostingUncheckedUpdateWithoutUserProcessesInput>
    create: XOR<JobPostingCreateWithoutUserProcessesInput, JobPostingUncheckedCreateWithoutUserProcessesInput>
    where?: JobPostingWhereInput
  }

  export type JobPostingUpdateToOneWithWhereWithoutUserProcessesInput = {
    where?: JobPostingWhereInput
    data: XOR<JobPostingUpdateWithoutUserProcessesInput, JobPostingUncheckedUpdateWithoutUserProcessesInput>
  }

  export type JobPostingUpdateWithoutUserProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    language?: JobPostingLanguageUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUpdateOneWithoutJobPostingNestedInput
    company?: CompanyUpdateOneWithoutJobPostingsNestedInput
    userJobApplications?: JobApplicantsUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutUserProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    language?: JobPostingLanguageUncheckedUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUncheckedUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUncheckedUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUncheckedUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUncheckedUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUncheckedUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUncheckedUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUncheckedUpdateOneWithoutJobPostingNestedInput
    userJobApplications?: JobApplicantsUncheckedUpdateManyWithoutJobPostingNestedInput
  }

  export type ProcessUpsertWithoutProcessesInput = {
    update: XOR<ProcessUpdateWithoutProcessesInput, ProcessUncheckedUpdateWithoutProcessesInput>
    create: XOR<ProcessCreateWithoutProcessesInput, ProcessUncheckedCreateWithoutProcessesInput>
    where?: ProcessWhereInput
  }

  export type ProcessUpdateToOneWithWhereWithoutProcessesInput = {
    where?: ProcessWhereInput
    data: XOR<ProcessUpdateWithoutProcessesInput, ProcessUncheckedUpdateWithoutProcessesInput>
  }

  export type ProcessUpdateWithoutProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutProcessesNestedInput
    steps?: ProcessStepUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    steps?: ProcessStepUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type TodoUserProcessUpsertWithWhereUniqueWithoutUserProcessInput = {
    where: TodoUserProcessWhereUniqueInput
    update: XOR<TodoUserProcessUpdateWithoutUserProcessInput, TodoUserProcessUncheckedUpdateWithoutUserProcessInput>
    create: XOR<TodoUserProcessCreateWithoutUserProcessInput, TodoUserProcessUncheckedCreateWithoutUserProcessInput>
  }

  export type TodoUserProcessUpdateWithWhereUniqueWithoutUserProcessInput = {
    where: TodoUserProcessWhereUniqueInput
    data: XOR<TodoUserProcessUpdateWithoutUserProcessInput, TodoUserProcessUncheckedUpdateWithoutUserProcessInput>
  }

  export type TodoUserProcessUpdateManyWithWhereWithoutUserProcessInput = {
    where: TodoUserProcessScalarWhereInput
    data: XOR<TodoUserProcessUpdateManyMutationInput, TodoUserProcessUncheckedUpdateManyWithoutUserProcessInput>
  }

  export type TodoUserProcessScalarWhereInput = {
    AND?: TodoUserProcessScalarWhereInput | TodoUserProcessScalarWhereInput[]
    OR?: TodoUserProcessScalarWhereInput[]
    NOT?: TodoUserProcessScalarWhereInput | TodoUserProcessScalarWhereInput[]
    id?: StringFilter<"TodoUserProcess"> | string
    todoId?: StringFilter<"TodoUserProcess"> | string
    userProcessId?: StringFilter<"TodoUserProcess"> | string
  }

  export type UserPipelineStepCommentCreateWithoutStepInput = {
    id?: string
    comment: string
    createdAt: string
    user: UserCreateNestedOneWithoutUserPipelineStepCommentsInput
  }

  export type UserPipelineStepCommentUncheckedCreateWithoutStepInput = {
    id?: string
    userId: string
    comment: string
    createdAt: string
  }

  export type UserPipelineStepCommentCreateOrConnectWithoutStepInput = {
    where: UserPipelineStepCommentWhereUniqueInput
    create: XOR<UserPipelineStepCommentCreateWithoutStepInput, UserPipelineStepCommentUncheckedCreateWithoutStepInput>
  }

  export type UserPipelineStepCommentCreateManyStepInputEnvelope = {
    data: UserPipelineStepCommentCreateManyStepInput | UserPipelineStepCommentCreateManyStepInput[]
    skipDuplicates?: boolean
  }

  export type UserProcessCreateWithoutStepsInput = {
    id?: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    user: UserCreateNestedOneWithoutUserProcessInput
    jobPosting?: JobPostingCreateNestedOneWithoutUserProcessesInput
    process?: ProcessCreateNestedOneWithoutProcessesInput
    todos?: TodoUserProcessCreateNestedManyWithoutUserProcessInput
  }

  export type UserProcessUncheckedCreateWithoutStepsInput = {
    id?: string
    userId: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    jobPostingId: string
    processId?: string | null
    todos?: TodoUserProcessUncheckedCreateNestedManyWithoutUserProcessInput
  }

  export type UserProcessCreateOrConnectWithoutStepsInput = {
    where: UserProcessWhereUniqueInput
    create: XOR<UserProcessCreateWithoutStepsInput, UserProcessUncheckedCreateWithoutStepsInput>
  }

  export type ProcessStepCreateWithoutUserProcessStepsInput = {
    id?: string
    title: string
    description: string
    icon?: string | null
    order: number
    process: ProcessCreateNestedOneWithoutStepsInput
    triggers?: TriggerDefinitionCreateNestedManyWithoutStepInput
    actions?: ActionDefinitionCreateNestedManyWithoutStepInput
    user?: UserCreateNestedOneWithoutProcessStepsInput
  }

  export type ProcessStepUncheckedCreateWithoutUserProcessStepsInput = {
    id?: string
    processId: string
    title: string
    description: string
    icon?: string | null
    order: number
    userId?: string | null
    triggers?: TriggerDefinitionUncheckedCreateNestedManyWithoutStepInput
    actions?: ActionDefinitionUncheckedCreateNestedManyWithoutStepInput
  }

  export type ProcessStepCreateOrConnectWithoutUserProcessStepsInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutUserProcessStepsInput, ProcessStepUncheckedCreateWithoutUserProcessStepsInput>
  }

  export type UserPipelineStepCommentUpsertWithWhereUniqueWithoutStepInput = {
    where: UserPipelineStepCommentWhereUniqueInput
    update: XOR<UserPipelineStepCommentUpdateWithoutStepInput, UserPipelineStepCommentUncheckedUpdateWithoutStepInput>
    create: XOR<UserPipelineStepCommentCreateWithoutStepInput, UserPipelineStepCommentUncheckedCreateWithoutStepInput>
  }

  export type UserPipelineStepCommentUpdateWithWhereUniqueWithoutStepInput = {
    where: UserPipelineStepCommentWhereUniqueInput
    data: XOR<UserPipelineStepCommentUpdateWithoutStepInput, UserPipelineStepCommentUncheckedUpdateWithoutStepInput>
  }

  export type UserPipelineStepCommentUpdateManyWithWhereWithoutStepInput = {
    where: UserPipelineStepCommentScalarWhereInput
    data: XOR<UserPipelineStepCommentUpdateManyMutationInput, UserPipelineStepCommentUncheckedUpdateManyWithoutStepInput>
  }

  export type UserProcessUpsertWithoutStepsInput = {
    update: XOR<UserProcessUpdateWithoutStepsInput, UserProcessUncheckedUpdateWithoutStepsInput>
    create: XOR<UserProcessCreateWithoutStepsInput, UserProcessUncheckedCreateWithoutStepsInput>
    where?: UserProcessWhereInput
  }

  export type UserProcessUpdateToOneWithWhereWithoutStepsInput = {
    where?: UserProcessWhereInput
    data: XOR<UserProcessUpdateWithoutStepsInput, UserProcessUncheckedUpdateWithoutStepsInput>
  }

  export type UserProcessUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserProcessNestedInput
    jobPosting?: JobPostingUpdateOneWithoutUserProcessesNestedInput
    process?: ProcessUpdateOneWithoutProcessesNestedInput
    todos?: TodoUserProcessUpdateManyWithoutUserProcessNestedInput
  }

  export type UserProcessUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingId?: StringFieldUpdateOperationsInput | string
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    todos?: TodoUserProcessUncheckedUpdateManyWithoutUserProcessNestedInput
  }

  export type ProcessStepUpsertWithoutUserProcessStepsInput = {
    update: XOR<ProcessStepUpdateWithoutUserProcessStepsInput, ProcessStepUncheckedUpdateWithoutUserProcessStepsInput>
    create: XOR<ProcessStepCreateWithoutUserProcessStepsInput, ProcessStepUncheckedCreateWithoutUserProcessStepsInput>
    where?: ProcessStepWhereInput
  }

  export type ProcessStepUpdateToOneWithWhereWithoutUserProcessStepsInput = {
    where?: ProcessStepWhereInput
    data: XOR<ProcessStepUpdateWithoutUserProcessStepsInput, ProcessStepUncheckedUpdateWithoutUserProcessStepsInput>
  }

  export type ProcessStepUpdateWithoutUserProcessStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    process?: ProcessUpdateOneRequiredWithoutStepsNestedInput
    triggers?: TriggerDefinitionUpdateManyWithoutStepNestedInput
    actions?: ActionDefinitionUpdateManyWithoutStepNestedInput
    user?: UserUpdateOneWithoutProcessStepsNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutUserProcessStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: TriggerDefinitionUncheckedUpdateManyWithoutStepNestedInput
    actions?: ActionDefinitionUncheckedUpdateManyWithoutStepNestedInput
  }

  export type UserCreateWithoutUserPipelineStepCommentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    providers?: ProviderCreateNestedManyWithoutUserInput
    applications?: JobApplicantsCreateNestedManyWithoutUserInput
    userProcess?: UserProcessCreateNestedManyWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    createdJobPostings?: CreatedJobPostingCreateNestedManyWithoutCreatedByInput
    processSteps?: ProcessStepCreateNestedManyWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPipelineStepCommentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    companyId?: string | null
    providers?: ProviderUncheckedCreateNestedManyWithoutUserInput
    applications?: JobApplicantsUncheckedCreateNestedManyWithoutUserInput
    userProcess?: UserProcessUncheckedCreateNestedManyWithoutUserInput
    createdJobPostings?: CreatedJobPostingUncheckedCreateNestedManyWithoutCreatedByInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutUserInput
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPipelineStepCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPipelineStepCommentsInput, UserUncheckedCreateWithoutUserPipelineStepCommentsInput>
  }

  export type UserProcessStepCreateWithoutCommentsInput = {
    id?: string
    isExecuted?: boolean
    executedAt?: string | null
    process: UserProcessCreateNestedOneWithoutStepsInput
    step?: ProcessStepCreateNestedOneWithoutUserProcessStepsInput
  }

  export type UserProcessStepUncheckedCreateWithoutCommentsInput = {
    id?: string
    userProcessId: string
    stepId?: string | null
    isExecuted?: boolean
    executedAt?: string | null
  }

  export type UserProcessStepCreateOrConnectWithoutCommentsInput = {
    where: UserProcessStepWhereUniqueInput
    create: XOR<UserProcessStepCreateWithoutCommentsInput, UserProcessStepUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpsertWithoutUserPipelineStepCommentsInput = {
    update: XOR<UserUpdateWithoutUserPipelineStepCommentsInput, UserUncheckedUpdateWithoutUserPipelineStepCommentsInput>
    create: XOR<UserCreateWithoutUserPipelineStepCommentsInput, UserUncheckedCreateWithoutUserPipelineStepCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPipelineStepCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPipelineStepCommentsInput, UserUncheckedUpdateWithoutUserPipelineStepCommentsInput>
  }

  export type UserUpdateWithoutUserPipelineStepCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    createdJobPostings?: CreatedJobPostingUpdateManyWithoutCreatedByNestedInput
    processSteps?: ProcessStepUpdateManyWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPipelineStepCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUncheckedUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUncheckedUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUncheckedUpdateManyWithoutUserNestedInput
    createdJobPostings?: CreatedJobPostingUncheckedUpdateManyWithoutCreatedByNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutUserNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserProcessStepUpsertWithoutCommentsInput = {
    update: XOR<UserProcessStepUpdateWithoutCommentsInput, UserProcessStepUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserProcessStepCreateWithoutCommentsInput, UserProcessStepUncheckedCreateWithoutCommentsInput>
    where?: UserProcessStepWhereInput
  }

  export type UserProcessStepUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserProcessStepWhereInput
    data: XOR<UserProcessStepUpdateWithoutCommentsInput, UserProcessStepUncheckedUpdateWithoutCommentsInput>
  }

  export type UserProcessStepUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    executedAt?: NullableStringFieldUpdateOperationsInput | string | null
    process?: UserProcessUpdateOneRequiredWithoutStepsNestedInput
    step?: ProcessStepUpdateOneWithoutUserProcessStepsNestedInput
  }

  export type UserProcessStepUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProcessId?: StringFieldUpdateOperationsInput | string
    stepId?: NullableStringFieldUpdateOperationsInput | string | null
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    executedAt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutProcessesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    providers?: ProviderCreateNestedManyWithoutUserInput
    applications?: JobApplicantsCreateNestedManyWithoutUserInput
    userProcess?: UserProcessCreateNestedManyWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    createdJobPostings?: CreatedJobPostingCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProcessesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    companyId?: string | null
    providers?: ProviderUncheckedCreateNestedManyWithoutUserInput
    applications?: JobApplicantsUncheckedCreateNestedManyWithoutUserInput
    userProcess?: UserProcessUncheckedCreateNestedManyWithoutUserInput
    createdJobPostings?: CreatedJobPostingUncheckedCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProcessesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessesInput, UserUncheckedCreateWithoutProcessesInput>
  }

  export type ProcessStepCreateWithoutProcessInput = {
    id?: string
    title: string
    description: string
    icon?: string | null
    order: number
    triggers?: TriggerDefinitionCreateNestedManyWithoutStepInput
    actions?: ActionDefinitionCreateNestedManyWithoutStepInput
    user?: UserCreateNestedOneWithoutProcessStepsInput
    userProcessSteps?: UserProcessStepCreateNestedManyWithoutStepInput
  }

  export type ProcessStepUncheckedCreateWithoutProcessInput = {
    id?: string
    title: string
    description: string
    icon?: string | null
    order: number
    userId?: string | null
    triggers?: TriggerDefinitionUncheckedCreateNestedManyWithoutStepInput
    actions?: ActionDefinitionUncheckedCreateNestedManyWithoutStepInput
    userProcessSteps?: UserProcessStepUncheckedCreateNestedManyWithoutStepInput
  }

  export type ProcessStepCreateOrConnectWithoutProcessInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutProcessInput, ProcessStepUncheckedCreateWithoutProcessInput>
  }

  export type ProcessStepCreateManyProcessInputEnvelope = {
    data: ProcessStepCreateManyProcessInput | ProcessStepCreateManyProcessInput[]
    skipDuplicates?: boolean
  }

  export type UserProcessCreateWithoutProcessInput = {
    id?: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    user: UserCreateNestedOneWithoutUserProcessInput
    steps?: UserProcessStepCreateNestedManyWithoutProcessInput
    jobPosting?: JobPostingCreateNestedOneWithoutUserProcessesInput
    todos?: TodoUserProcessCreateNestedManyWithoutUserProcessInput
  }

  export type UserProcessUncheckedCreateWithoutProcessInput = {
    id?: string
    userId: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    jobPostingId: string
    steps?: UserProcessStepUncheckedCreateNestedManyWithoutProcessInput
    todos?: TodoUserProcessUncheckedCreateNestedManyWithoutUserProcessInput
  }

  export type UserProcessCreateOrConnectWithoutProcessInput = {
    where: UserProcessWhereUniqueInput
    create: XOR<UserProcessCreateWithoutProcessInput, UserProcessUncheckedCreateWithoutProcessInput>
  }

  export type UserProcessCreateManyProcessInputEnvelope = {
    data: UserProcessCreateManyProcessInput | UserProcessCreateManyProcessInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProcessesInput = {
    update: XOR<UserUpdateWithoutProcessesInput, UserUncheckedUpdateWithoutProcessesInput>
    create: XOR<UserCreateWithoutProcessesInput, UserUncheckedCreateWithoutProcessesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessesInput, UserUncheckedUpdateWithoutProcessesInput>
  }

  export type UserUpdateWithoutProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    createdJobPostings?: CreatedJobPostingUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUncheckedUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUncheckedUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUncheckedUpdateManyWithoutUserNestedInput
    createdJobPostings?: CreatedJobPostingUncheckedUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProcessStepUpsertWithWhereUniqueWithoutProcessInput = {
    where: ProcessStepWhereUniqueInput
    update: XOR<ProcessStepUpdateWithoutProcessInput, ProcessStepUncheckedUpdateWithoutProcessInput>
    create: XOR<ProcessStepCreateWithoutProcessInput, ProcessStepUncheckedCreateWithoutProcessInput>
  }

  export type ProcessStepUpdateWithWhereUniqueWithoutProcessInput = {
    where: ProcessStepWhereUniqueInput
    data: XOR<ProcessStepUpdateWithoutProcessInput, ProcessStepUncheckedUpdateWithoutProcessInput>
  }

  export type ProcessStepUpdateManyWithWhereWithoutProcessInput = {
    where: ProcessStepScalarWhereInput
    data: XOR<ProcessStepUpdateManyMutationInput, ProcessStepUncheckedUpdateManyWithoutProcessInput>
  }

  export type UserProcessUpsertWithWhereUniqueWithoutProcessInput = {
    where: UserProcessWhereUniqueInput
    update: XOR<UserProcessUpdateWithoutProcessInput, UserProcessUncheckedUpdateWithoutProcessInput>
    create: XOR<UserProcessCreateWithoutProcessInput, UserProcessUncheckedCreateWithoutProcessInput>
  }

  export type UserProcessUpdateWithWhereUniqueWithoutProcessInput = {
    where: UserProcessWhereUniqueInput
    data: XOR<UserProcessUpdateWithoutProcessInput, UserProcessUncheckedUpdateWithoutProcessInput>
  }

  export type UserProcessUpdateManyWithWhereWithoutProcessInput = {
    where: UserProcessScalarWhereInput
    data: XOR<UserProcessUpdateManyMutationInput, UserProcessUncheckedUpdateManyWithoutProcessInput>
  }

  export type ProcessCreateWithoutStepsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    isTemplate: boolean
    isPublic?: boolean
    user?: UserCreateNestedOneWithoutProcessesInput
    processes?: UserProcessCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutStepsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    ownerId?: string | null
    isTemplate: boolean
    isPublic?: boolean
    processes?: UserProcessUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutStepsInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutStepsInput, ProcessUncheckedCreateWithoutStepsInput>
  }

  export type TriggerDefinitionCreateWithoutStepInput = {
    id?: string
    order: number
    isPublic?: boolean
    createdBy: string
    triggerCode: string
    executeWhen?: $Enums.TriggerEventCode | null
    executeAt?: string | null
    combinator?: $Enums.CombinatorEnum | null
    config: JsonNullValueInput | InputJsonValue
    expiration?: string | null
    conditions?: ConditionalCreateNestedManyWithoutTriggerInput
  }

  export type TriggerDefinitionUncheckedCreateWithoutStepInput = {
    id?: string
    order: number
    isPublic?: boolean
    createdBy: string
    triggerCode: string
    executeWhen?: $Enums.TriggerEventCode | null
    executeAt?: string | null
    combinator?: $Enums.CombinatorEnum | null
    config: JsonNullValueInput | InputJsonValue
    expiration?: string | null
    conditions?: ConditionalUncheckedCreateNestedManyWithoutTriggerInput
  }

  export type TriggerDefinitionCreateOrConnectWithoutStepInput = {
    where: TriggerDefinitionWhereUniqueInput
    create: XOR<TriggerDefinitionCreateWithoutStepInput, TriggerDefinitionUncheckedCreateWithoutStepInput>
  }

  export type TriggerDefinitionCreateManyStepInputEnvelope = {
    data: TriggerDefinitionCreateManyStepInput | TriggerDefinitionCreateManyStepInput[]
    skipDuplicates?: boolean
  }

  export type ActionDefinitionCreateWithoutStepInput = {
    id?: string
    name: string
    isPublic?: boolean
    order: number
    config: JsonNullValueInput | InputJsonValue
  }

  export type ActionDefinitionUncheckedCreateWithoutStepInput = {
    id?: string
    name: string
    isPublic?: boolean
    order: number
    config: JsonNullValueInput | InputJsonValue
  }

  export type ActionDefinitionCreateOrConnectWithoutStepInput = {
    where: ActionDefinitionWhereUniqueInput
    create: XOR<ActionDefinitionCreateWithoutStepInput, ActionDefinitionUncheckedCreateWithoutStepInput>
  }

  export type ActionDefinitionCreateManyStepInputEnvelope = {
    data: ActionDefinitionCreateManyStepInput | ActionDefinitionCreateManyStepInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutProcessStepsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    providers?: ProviderCreateNestedManyWithoutUserInput
    applications?: JobApplicantsCreateNestedManyWithoutUserInput
    userProcess?: UserProcessCreateNestedManyWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    createdJobPostings?: CreatedJobPostingCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentCreateNestedManyWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
    todos?: TodoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProcessStepsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    companyId?: string | null
    providers?: ProviderUncheckedCreateNestedManyWithoutUserInput
    applications?: JobApplicantsUncheckedCreateNestedManyWithoutUserInput
    userProcess?: UserProcessUncheckedCreateNestedManyWithoutUserInput
    createdJobPostings?: CreatedJobPostingUncheckedCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedCreateNestedManyWithoutUserInput
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProcessStepsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessStepsInput, UserUncheckedCreateWithoutProcessStepsInput>
  }

  export type UserProcessStepCreateWithoutStepInput = {
    id?: string
    isExecuted?: boolean
    executedAt?: string | null
    comments?: UserPipelineStepCommentCreateNestedManyWithoutStepInput
    process: UserProcessCreateNestedOneWithoutStepsInput
  }

  export type UserProcessStepUncheckedCreateWithoutStepInput = {
    id?: string
    userProcessId: string
    isExecuted?: boolean
    executedAt?: string | null
    comments?: UserPipelineStepCommentUncheckedCreateNestedManyWithoutStepInput
  }

  export type UserProcessStepCreateOrConnectWithoutStepInput = {
    where: UserProcessStepWhereUniqueInput
    create: XOR<UserProcessStepCreateWithoutStepInput, UserProcessStepUncheckedCreateWithoutStepInput>
  }

  export type UserProcessStepCreateManyStepInputEnvelope = {
    data: UserProcessStepCreateManyStepInput | UserProcessStepCreateManyStepInput[]
    skipDuplicates?: boolean
  }

  export type ProcessUpsertWithoutStepsInput = {
    update: XOR<ProcessUpdateWithoutStepsInput, ProcessUncheckedUpdateWithoutStepsInput>
    create: XOR<ProcessCreateWithoutStepsInput, ProcessUncheckedCreateWithoutStepsInput>
    where?: ProcessWhereInput
  }

  export type ProcessUpdateToOneWithWhereWithoutStepsInput = {
    where?: ProcessWhereInput
    data: XOR<ProcessUpdateWithoutStepsInput, ProcessUncheckedUpdateWithoutStepsInput>
  }

  export type ProcessUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutProcessesNestedInput
    processes?: UserProcessUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    processes?: UserProcessUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type TriggerDefinitionUpsertWithWhereUniqueWithoutStepInput = {
    where: TriggerDefinitionWhereUniqueInput
    update: XOR<TriggerDefinitionUpdateWithoutStepInput, TriggerDefinitionUncheckedUpdateWithoutStepInput>
    create: XOR<TriggerDefinitionCreateWithoutStepInput, TriggerDefinitionUncheckedCreateWithoutStepInput>
  }

  export type TriggerDefinitionUpdateWithWhereUniqueWithoutStepInput = {
    where: TriggerDefinitionWhereUniqueInput
    data: XOR<TriggerDefinitionUpdateWithoutStepInput, TriggerDefinitionUncheckedUpdateWithoutStepInput>
  }

  export type TriggerDefinitionUpdateManyWithWhereWithoutStepInput = {
    where: TriggerDefinitionScalarWhereInput
    data: XOR<TriggerDefinitionUpdateManyMutationInput, TriggerDefinitionUncheckedUpdateManyWithoutStepInput>
  }

  export type TriggerDefinitionScalarWhereInput = {
    AND?: TriggerDefinitionScalarWhereInput | TriggerDefinitionScalarWhereInput[]
    OR?: TriggerDefinitionScalarWhereInput[]
    NOT?: TriggerDefinitionScalarWhereInput | TriggerDefinitionScalarWhereInput[]
    id?: StringFilter<"TriggerDefinition"> | string
    order?: IntFilter<"TriggerDefinition"> | number
    isPublic?: BoolFilter<"TriggerDefinition"> | boolean
    createdBy?: StringFilter<"TriggerDefinition"> | string
    triggerCode?: StringFilter<"TriggerDefinition"> | string
    executeWhen?: EnumTriggerEventCodeNullableFilter<"TriggerDefinition"> | $Enums.TriggerEventCode | null
    executeAt?: StringNullableFilter<"TriggerDefinition"> | string | null
    combinator?: EnumCombinatorEnumNullableFilter<"TriggerDefinition"> | $Enums.CombinatorEnum | null
    config?: JsonFilter<"TriggerDefinition">
    expiration?: StringNullableFilter<"TriggerDefinition"> | string | null
    stepId?: StringNullableFilter<"TriggerDefinition"> | string | null
  }

  export type ActionDefinitionUpsertWithWhereUniqueWithoutStepInput = {
    where: ActionDefinitionWhereUniqueInput
    update: XOR<ActionDefinitionUpdateWithoutStepInput, ActionDefinitionUncheckedUpdateWithoutStepInput>
    create: XOR<ActionDefinitionCreateWithoutStepInput, ActionDefinitionUncheckedCreateWithoutStepInput>
  }

  export type ActionDefinitionUpdateWithWhereUniqueWithoutStepInput = {
    where: ActionDefinitionWhereUniqueInput
    data: XOR<ActionDefinitionUpdateWithoutStepInput, ActionDefinitionUncheckedUpdateWithoutStepInput>
  }

  export type ActionDefinitionUpdateManyWithWhereWithoutStepInput = {
    where: ActionDefinitionScalarWhereInput
    data: XOR<ActionDefinitionUpdateManyMutationInput, ActionDefinitionUncheckedUpdateManyWithoutStepInput>
  }

  export type ActionDefinitionScalarWhereInput = {
    AND?: ActionDefinitionScalarWhereInput | ActionDefinitionScalarWhereInput[]
    OR?: ActionDefinitionScalarWhereInput[]
    NOT?: ActionDefinitionScalarWhereInput | ActionDefinitionScalarWhereInput[]
    id?: StringFilter<"ActionDefinition"> | string
    name?: StringFilter<"ActionDefinition"> | string
    isPublic?: BoolFilter<"ActionDefinition"> | boolean
    order?: IntFilter<"ActionDefinition"> | number
    config?: JsonFilter<"ActionDefinition">
    stepId?: StringNullableFilter<"ActionDefinition"> | string | null
  }

  export type UserUpsertWithoutProcessStepsInput = {
    update: XOR<UserUpdateWithoutProcessStepsInput, UserUncheckedUpdateWithoutProcessStepsInput>
    create: XOR<UserCreateWithoutProcessStepsInput, UserUncheckedCreateWithoutProcessStepsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessStepsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessStepsInput, UserUncheckedUpdateWithoutProcessStepsInput>
  }

  export type UserUpdateWithoutProcessStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    createdJobPostings?: CreatedJobPostingUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUpdateManyWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUncheckedUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUncheckedUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUncheckedUpdateManyWithoutUserNestedInput
    createdJobPostings?: CreatedJobPostingUncheckedUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedUpdateManyWithoutUserNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserProcessStepUpsertWithWhereUniqueWithoutStepInput = {
    where: UserProcessStepWhereUniqueInput
    update: XOR<UserProcessStepUpdateWithoutStepInput, UserProcessStepUncheckedUpdateWithoutStepInput>
    create: XOR<UserProcessStepCreateWithoutStepInput, UserProcessStepUncheckedCreateWithoutStepInput>
  }

  export type UserProcessStepUpdateWithWhereUniqueWithoutStepInput = {
    where: UserProcessStepWhereUniqueInput
    data: XOR<UserProcessStepUpdateWithoutStepInput, UserProcessStepUncheckedUpdateWithoutStepInput>
  }

  export type UserProcessStepUpdateManyWithWhereWithoutStepInput = {
    where: UserProcessStepScalarWhereInput
    data: XOR<UserProcessStepUpdateManyMutationInput, UserProcessStepUncheckedUpdateManyWithoutStepInput>
  }

  export type ProcessStepCreateWithoutActionsInput = {
    id?: string
    title: string
    description: string
    icon?: string | null
    order: number
    process: ProcessCreateNestedOneWithoutStepsInput
    triggers?: TriggerDefinitionCreateNestedManyWithoutStepInput
    user?: UserCreateNestedOneWithoutProcessStepsInput
    userProcessSteps?: UserProcessStepCreateNestedManyWithoutStepInput
  }

  export type ProcessStepUncheckedCreateWithoutActionsInput = {
    id?: string
    processId: string
    title: string
    description: string
    icon?: string | null
    order: number
    userId?: string | null
    triggers?: TriggerDefinitionUncheckedCreateNestedManyWithoutStepInput
    userProcessSteps?: UserProcessStepUncheckedCreateNestedManyWithoutStepInput
  }

  export type ProcessStepCreateOrConnectWithoutActionsInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutActionsInput, ProcessStepUncheckedCreateWithoutActionsInput>
  }

  export type ProcessStepUpsertWithoutActionsInput = {
    update: XOR<ProcessStepUpdateWithoutActionsInput, ProcessStepUncheckedUpdateWithoutActionsInput>
    create: XOR<ProcessStepCreateWithoutActionsInput, ProcessStepUncheckedCreateWithoutActionsInput>
    where?: ProcessStepWhereInput
  }

  export type ProcessStepUpdateToOneWithWhereWithoutActionsInput = {
    where?: ProcessStepWhereInput
    data: XOR<ProcessStepUpdateWithoutActionsInput, ProcessStepUncheckedUpdateWithoutActionsInput>
  }

  export type ProcessStepUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    process?: ProcessUpdateOneRequiredWithoutStepsNestedInput
    triggers?: TriggerDefinitionUpdateManyWithoutStepNestedInput
    user?: UserUpdateOneWithoutProcessStepsNestedInput
    userProcessSteps?: UserProcessStepUpdateManyWithoutStepNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: TriggerDefinitionUncheckedUpdateManyWithoutStepNestedInput
    userProcessSteps?: UserProcessStepUncheckedUpdateManyWithoutStepNestedInput
  }

  export type ConditionalCreateWithoutTriggerInput = {
    id?: string
    fieldKey: string
    fieldKeyLabel: string
    operator: $Enums.ComparisonOperatorEnum
    comparisonValue: string
    combinator?: $Enums.CombinatorEnum | null
  }

  export type ConditionalUncheckedCreateWithoutTriggerInput = {
    id?: string
    fieldKey: string
    fieldKeyLabel: string
    operator: $Enums.ComparisonOperatorEnum
    comparisonValue: string
    combinator?: $Enums.CombinatorEnum | null
  }

  export type ConditionalCreateOrConnectWithoutTriggerInput = {
    where: ConditionalWhereUniqueInput
    create: XOR<ConditionalCreateWithoutTriggerInput, ConditionalUncheckedCreateWithoutTriggerInput>
  }

  export type ConditionalCreateManyTriggerInputEnvelope = {
    data: ConditionalCreateManyTriggerInput | ConditionalCreateManyTriggerInput[]
    skipDuplicates?: boolean
  }

  export type ProcessStepCreateWithoutTriggersInput = {
    id?: string
    title: string
    description: string
    icon?: string | null
    order: number
    process: ProcessCreateNestedOneWithoutStepsInput
    actions?: ActionDefinitionCreateNestedManyWithoutStepInput
    user?: UserCreateNestedOneWithoutProcessStepsInput
    userProcessSteps?: UserProcessStepCreateNestedManyWithoutStepInput
  }

  export type ProcessStepUncheckedCreateWithoutTriggersInput = {
    id?: string
    processId: string
    title: string
    description: string
    icon?: string | null
    order: number
    userId?: string | null
    actions?: ActionDefinitionUncheckedCreateNestedManyWithoutStepInput
    userProcessSteps?: UserProcessStepUncheckedCreateNestedManyWithoutStepInput
  }

  export type ProcessStepCreateOrConnectWithoutTriggersInput = {
    where: ProcessStepWhereUniqueInput
    create: XOR<ProcessStepCreateWithoutTriggersInput, ProcessStepUncheckedCreateWithoutTriggersInput>
  }

  export type ConditionalUpsertWithWhereUniqueWithoutTriggerInput = {
    where: ConditionalWhereUniqueInput
    update: XOR<ConditionalUpdateWithoutTriggerInput, ConditionalUncheckedUpdateWithoutTriggerInput>
    create: XOR<ConditionalCreateWithoutTriggerInput, ConditionalUncheckedCreateWithoutTriggerInput>
  }

  export type ConditionalUpdateWithWhereUniqueWithoutTriggerInput = {
    where: ConditionalWhereUniqueInput
    data: XOR<ConditionalUpdateWithoutTriggerInput, ConditionalUncheckedUpdateWithoutTriggerInput>
  }

  export type ConditionalUpdateManyWithWhereWithoutTriggerInput = {
    where: ConditionalScalarWhereInput
    data: XOR<ConditionalUpdateManyMutationInput, ConditionalUncheckedUpdateManyWithoutTriggerInput>
  }

  export type ConditionalScalarWhereInput = {
    AND?: ConditionalScalarWhereInput | ConditionalScalarWhereInput[]
    OR?: ConditionalScalarWhereInput[]
    NOT?: ConditionalScalarWhereInput | ConditionalScalarWhereInput[]
    id?: StringFilter<"Conditional"> | string
    triggerId?: StringFilter<"Conditional"> | string
    fieldKey?: StringFilter<"Conditional"> | string
    fieldKeyLabel?: StringFilter<"Conditional"> | string
    operator?: EnumComparisonOperatorEnumFilter<"Conditional"> | $Enums.ComparisonOperatorEnum
    comparisonValue?: StringFilter<"Conditional"> | string
    combinator?: EnumCombinatorEnumNullableFilter<"Conditional"> | $Enums.CombinatorEnum | null
  }

  export type ProcessStepUpsertWithoutTriggersInput = {
    update: XOR<ProcessStepUpdateWithoutTriggersInput, ProcessStepUncheckedUpdateWithoutTriggersInput>
    create: XOR<ProcessStepCreateWithoutTriggersInput, ProcessStepUncheckedCreateWithoutTriggersInput>
    where?: ProcessStepWhereInput
  }

  export type ProcessStepUpdateToOneWithWhereWithoutTriggersInput = {
    where?: ProcessStepWhereInput
    data: XOR<ProcessStepUpdateWithoutTriggersInput, ProcessStepUncheckedUpdateWithoutTriggersInput>
  }

  export type ProcessStepUpdateWithoutTriggersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    process?: ProcessUpdateOneRequiredWithoutStepsNestedInput
    actions?: ActionDefinitionUpdateManyWithoutStepNestedInput
    user?: UserUpdateOneWithoutProcessStepsNestedInput
    userProcessSteps?: UserProcessStepUpdateManyWithoutStepNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutTriggersInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: ActionDefinitionUncheckedUpdateManyWithoutStepNestedInput
    userProcessSteps?: UserProcessStepUncheckedUpdateManyWithoutStepNestedInput
  }

  export type TriggerDefinitionCreateWithoutConditionsInput = {
    id?: string
    order: number
    isPublic?: boolean
    createdBy: string
    triggerCode: string
    executeWhen?: $Enums.TriggerEventCode | null
    executeAt?: string | null
    combinator?: $Enums.CombinatorEnum | null
    config: JsonNullValueInput | InputJsonValue
    expiration?: string | null
    step?: ProcessStepCreateNestedOneWithoutTriggersInput
  }

  export type TriggerDefinitionUncheckedCreateWithoutConditionsInput = {
    id?: string
    order: number
    isPublic?: boolean
    createdBy: string
    triggerCode: string
    executeWhen?: $Enums.TriggerEventCode | null
    executeAt?: string | null
    combinator?: $Enums.CombinatorEnum | null
    config: JsonNullValueInput | InputJsonValue
    expiration?: string | null
    stepId?: string | null
  }

  export type TriggerDefinitionCreateOrConnectWithoutConditionsInput = {
    where: TriggerDefinitionWhereUniqueInput
    create: XOR<TriggerDefinitionCreateWithoutConditionsInput, TriggerDefinitionUncheckedCreateWithoutConditionsInput>
  }

  export type TriggerDefinitionUpsertWithoutConditionsInput = {
    update: XOR<TriggerDefinitionUpdateWithoutConditionsInput, TriggerDefinitionUncheckedUpdateWithoutConditionsInput>
    create: XOR<TriggerDefinitionCreateWithoutConditionsInput, TriggerDefinitionUncheckedCreateWithoutConditionsInput>
    where?: TriggerDefinitionWhereInput
  }

  export type TriggerDefinitionUpdateToOneWithWhereWithoutConditionsInput = {
    where?: TriggerDefinitionWhereInput
    data: XOR<TriggerDefinitionUpdateWithoutConditionsInput, TriggerDefinitionUncheckedUpdateWithoutConditionsInput>
  }

  export type TriggerDefinitionUpdateWithoutConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    triggerCode?: StringFieldUpdateOperationsInput | string
    executeWhen?: NullableEnumTriggerEventCodeFieldUpdateOperationsInput | $Enums.TriggerEventCode | null
    executeAt?: NullableStringFieldUpdateOperationsInput | string | null
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
    config?: JsonNullValueInput | InputJsonValue
    expiration?: NullableStringFieldUpdateOperationsInput | string | null
    step?: ProcessStepUpdateOneWithoutTriggersNestedInput
  }

  export type TriggerDefinitionUncheckedUpdateWithoutConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    triggerCode?: StringFieldUpdateOperationsInput | string
    executeWhen?: NullableEnumTriggerEventCodeFieldUpdateOperationsInput | $Enums.TriggerEventCode | null
    executeAt?: NullableStringFieldUpdateOperationsInput | string | null
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
    config?: JsonNullValueInput | InputJsonValue
    expiration?: NullableStringFieldUpdateOperationsInput | string | null
    stepId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutTodosInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    providers?: ProviderCreateNestedManyWithoutUserInput
    applications?: JobApplicantsCreateNestedManyWithoutUserInput
    userProcess?: UserProcessCreateNestedManyWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    createdJobPostings?: CreatedJobPostingCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepCreateNestedManyWithoutUserInput
    processes?: ProcessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTodosInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
    companyId?: string | null
    providers?: ProviderUncheckedCreateNestedManyWithoutUserInput
    applications?: JobApplicantsUncheckedCreateNestedManyWithoutUserInput
    userProcess?: UserProcessUncheckedCreateNestedManyWithoutUserInput
    createdJobPostings?: CreatedJobPostingUncheckedCreateNestedManyWithoutCreatedByInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedCreateNestedManyWithoutUserInput
    processSteps?: ProcessStepUncheckedCreateNestedManyWithoutUserInput
    processes?: ProcessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTodosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTodosInput, UserUncheckedCreateWithoutTodosInput>
  }

  export type TodoItemCreateWithoutTodoInput = {
    id?: string
    type: $Enums.TodoItemTypeEnum
    content: string
    order: number
  }

  export type TodoItemUncheckedCreateWithoutTodoInput = {
    id?: string
    type: $Enums.TodoItemTypeEnum
    content: string
    order: number
  }

  export type TodoItemCreateOrConnectWithoutTodoInput = {
    where: TodoItemWhereUniqueInput
    create: XOR<TodoItemCreateWithoutTodoInput, TodoItemUncheckedCreateWithoutTodoInput>
  }

  export type TodoItemCreateManyTodoInputEnvelope = {
    data: TodoItemCreateManyTodoInput | TodoItemCreateManyTodoInput[]
    skipDuplicates?: boolean
  }

  export type TodoUserProcessCreateWithoutTodoInput = {
    id?: string
    userProcess: UserProcessCreateNestedOneWithoutTodosInput
  }

  export type TodoUserProcessUncheckedCreateWithoutTodoInput = {
    id?: string
    userProcessId: string
  }

  export type TodoUserProcessCreateOrConnectWithoutTodoInput = {
    where: TodoUserProcessWhereUniqueInput
    create: XOR<TodoUserProcessCreateWithoutTodoInput, TodoUserProcessUncheckedCreateWithoutTodoInput>
  }

  export type TodoUserProcessCreateManyTodoInputEnvelope = {
    data: TodoUserProcessCreateManyTodoInput | TodoUserProcessCreateManyTodoInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTodosInput = {
    update: XOR<UserUpdateWithoutTodosInput, UserUncheckedUpdateWithoutTodosInput>
    create: XOR<UserCreateWithoutTodosInput, UserUncheckedCreateWithoutTodosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTodosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTodosInput, UserUncheckedUpdateWithoutTodosInput>
  }

  export type UserUpdateWithoutTodosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    createdJobPostings?: CreatedJobPostingUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUpdateManyWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTodosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUncheckedUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUncheckedUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUncheckedUpdateManyWithoutUserNestedInput
    createdJobPostings?: CreatedJobPostingUncheckedUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutUserNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TodoItemUpsertWithWhereUniqueWithoutTodoInput = {
    where: TodoItemWhereUniqueInput
    update: XOR<TodoItemUpdateWithoutTodoInput, TodoItemUncheckedUpdateWithoutTodoInput>
    create: XOR<TodoItemCreateWithoutTodoInput, TodoItemUncheckedCreateWithoutTodoInput>
  }

  export type TodoItemUpdateWithWhereUniqueWithoutTodoInput = {
    where: TodoItemWhereUniqueInput
    data: XOR<TodoItemUpdateWithoutTodoInput, TodoItemUncheckedUpdateWithoutTodoInput>
  }

  export type TodoItemUpdateManyWithWhereWithoutTodoInput = {
    where: TodoItemScalarWhereInput
    data: XOR<TodoItemUpdateManyMutationInput, TodoItemUncheckedUpdateManyWithoutTodoInput>
  }

  export type TodoItemScalarWhereInput = {
    AND?: TodoItemScalarWhereInput | TodoItemScalarWhereInput[]
    OR?: TodoItemScalarWhereInput[]
    NOT?: TodoItemScalarWhereInput | TodoItemScalarWhereInput[]
    id?: StringFilter<"TodoItem"> | string
    todoId?: StringFilter<"TodoItem"> | string
    type?: EnumTodoItemTypeEnumFilter<"TodoItem"> | $Enums.TodoItemTypeEnum
    content?: StringFilter<"TodoItem"> | string
    order?: IntFilter<"TodoItem"> | number
  }

  export type TodoUserProcessUpsertWithWhereUniqueWithoutTodoInput = {
    where: TodoUserProcessWhereUniqueInput
    update: XOR<TodoUserProcessUpdateWithoutTodoInput, TodoUserProcessUncheckedUpdateWithoutTodoInput>
    create: XOR<TodoUserProcessCreateWithoutTodoInput, TodoUserProcessUncheckedCreateWithoutTodoInput>
  }

  export type TodoUserProcessUpdateWithWhereUniqueWithoutTodoInput = {
    where: TodoUserProcessWhereUniqueInput
    data: XOR<TodoUserProcessUpdateWithoutTodoInput, TodoUserProcessUncheckedUpdateWithoutTodoInput>
  }

  export type TodoUserProcessUpdateManyWithWhereWithoutTodoInput = {
    where: TodoUserProcessScalarWhereInput
    data: XOR<TodoUserProcessUpdateManyMutationInput, TodoUserProcessUncheckedUpdateManyWithoutTodoInput>
  }

  export type TodoCreateWithoutItemsInput = {
    id?: string
    title: string
    dueDate: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTodosInput
    userProcesses?: TodoUserProcessCreateNestedManyWithoutTodoInput
  }

  export type TodoUncheckedCreateWithoutItemsInput = {
    id?: string
    userId: string
    title: string
    dueDate: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userProcesses?: TodoUserProcessUncheckedCreateNestedManyWithoutTodoInput
  }

  export type TodoCreateOrConnectWithoutItemsInput = {
    where: TodoWhereUniqueInput
    create: XOR<TodoCreateWithoutItemsInput, TodoUncheckedCreateWithoutItemsInput>
  }

  export type TodoUpsertWithoutItemsInput = {
    update: XOR<TodoUpdateWithoutItemsInput, TodoUncheckedUpdateWithoutItemsInput>
    create: XOR<TodoCreateWithoutItemsInput, TodoUncheckedCreateWithoutItemsInput>
    where?: TodoWhereInput
  }

  export type TodoUpdateToOneWithWhereWithoutItemsInput = {
    where?: TodoWhereInput
    data: XOR<TodoUpdateWithoutItemsInput, TodoUncheckedUpdateWithoutItemsInput>
  }

  export type TodoUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTodosNestedInput
    userProcesses?: TodoUserProcessUpdateManyWithoutTodoNestedInput
  }

  export type TodoUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProcesses?: TodoUserProcessUncheckedUpdateManyWithoutTodoNestedInput
  }

  export type TodoCreateWithoutUserProcessesInput = {
    id?: string
    title: string
    dueDate: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTodosInput
    items?: TodoItemCreateNestedManyWithoutTodoInput
  }

  export type TodoUncheckedCreateWithoutUserProcessesInput = {
    id?: string
    userId: string
    title: string
    dueDate: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TodoItemUncheckedCreateNestedManyWithoutTodoInput
  }

  export type TodoCreateOrConnectWithoutUserProcessesInput = {
    where: TodoWhereUniqueInput
    create: XOR<TodoCreateWithoutUserProcessesInput, TodoUncheckedCreateWithoutUserProcessesInput>
  }

  export type UserProcessCreateWithoutTodosInput = {
    id?: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    user: UserCreateNestedOneWithoutUserProcessInput
    steps?: UserProcessStepCreateNestedManyWithoutProcessInput
    jobPosting?: JobPostingCreateNestedOneWithoutUserProcessesInput
    process?: ProcessCreateNestedOneWithoutProcessesInput
  }

  export type UserProcessUncheckedCreateWithoutTodosInput = {
    id?: string
    userId: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    jobPostingId: string
    processId?: string | null
    steps?: UserProcessStepUncheckedCreateNestedManyWithoutProcessInput
  }

  export type UserProcessCreateOrConnectWithoutTodosInput = {
    where: UserProcessWhereUniqueInput
    create: XOR<UserProcessCreateWithoutTodosInput, UserProcessUncheckedCreateWithoutTodosInput>
  }

  export type TodoUpsertWithoutUserProcessesInput = {
    update: XOR<TodoUpdateWithoutUserProcessesInput, TodoUncheckedUpdateWithoutUserProcessesInput>
    create: XOR<TodoCreateWithoutUserProcessesInput, TodoUncheckedCreateWithoutUserProcessesInput>
    where?: TodoWhereInput
  }

  export type TodoUpdateToOneWithWhereWithoutUserProcessesInput = {
    where?: TodoWhereInput
    data: XOR<TodoUpdateWithoutUserProcessesInput, TodoUncheckedUpdateWithoutUserProcessesInput>
  }

  export type TodoUpdateWithoutUserProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTodosNestedInput
    items?: TodoItemUpdateManyWithoutTodoNestedInput
  }

  export type TodoUncheckedUpdateWithoutUserProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TodoItemUncheckedUpdateManyWithoutTodoNestedInput
  }

  export type UserProcessUpsertWithoutTodosInput = {
    update: XOR<UserProcessUpdateWithoutTodosInput, UserProcessUncheckedUpdateWithoutTodosInput>
    create: XOR<UserProcessCreateWithoutTodosInput, UserProcessUncheckedCreateWithoutTodosInput>
    where?: UserProcessWhereInput
  }

  export type UserProcessUpdateToOneWithWhereWithoutTodosInput = {
    where?: UserProcessWhereInput
    data: XOR<UserProcessUpdateWithoutTodosInput, UserProcessUncheckedUpdateWithoutTodosInput>
  }

  export type UserProcessUpdateWithoutTodosInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserProcessNestedInput
    steps?: UserProcessStepUpdateManyWithoutProcessNestedInput
    jobPosting?: JobPostingUpdateOneWithoutUserProcessesNestedInput
    process?: ProcessUpdateOneWithoutProcessesNestedInput
  }

  export type UserProcessUncheckedUpdateWithoutTodosInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingId?: StringFieldUpdateOperationsInput | string
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: UserProcessStepUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProviderCreateManyUserInput = {
    id?: string
    provider: $Enums.ProviderEnum
    providerAccountId: string
  }

  export type JobApplicantsCreateManyUserInput = {
    id?: string
    jobPostingId: string
    status?: string
    appliedAt: string
    gotJob?: boolean
  }

  export type UserProcessCreateManyUserInput = {
    id?: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    jobPostingId: string
    processId?: string | null
  }

  export type CreatedJobPostingCreateManyCreatedByInput = {
    id?: string
    jobPostingId: string
    createdByType: $Enums.CreatedByEnum
    source?: $Enums.JobSourceEnum | null
    importedAt?: Date | string | null
  }

  export type UserPipelineStepCommentCreateManyUserInput = {
    id?: string
    userPipelineStepId: string
    comment: string
    createdAt: string
  }

  export type ProcessStepCreateManyUserInput = {
    id?: string
    processId: string
    title: string
    description: string
    icon?: string | null
    order: number
  }

  export type ProcessCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    isTemplate: boolean
    isPublic?: boolean
  }

  export type TodoCreateManyUserInput = {
    id?: string
    title: string
    dueDate: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProviderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderEnumFieldUpdateOperationsInput | $Enums.ProviderEnum
    providerAccountId?: StringFieldUpdateOperationsInput | string
    token?: TokenUpdateOneWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderEnumFieldUpdateOperationsInput | $Enums.ProviderEnum
    providerAccountId?: StringFieldUpdateOperationsInput | string
    token?: TokenUncheckedUpdateOneWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderEnumFieldUpdateOperationsInput | $Enums.ProviderEnum
    providerAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type JobApplicantsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    appliedAt?: StringFieldUpdateOperationsInput | string
    gotJob?: BoolFieldUpdateOperationsInput | boolean
    jobPosting?: JobPostingUpdateOneRequiredWithoutUserJobApplicationsNestedInput
  }

  export type JobApplicantsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    appliedAt?: StringFieldUpdateOperationsInput | string
    gotJob?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobApplicantsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    appliedAt?: StringFieldUpdateOperationsInput | string
    gotJob?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserProcessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: UserProcessStepUpdateManyWithoutProcessNestedInput
    jobPosting?: JobPostingUpdateOneWithoutUserProcessesNestedInput
    process?: ProcessUpdateOneWithoutProcessesNestedInput
    todos?: TodoUserProcessUpdateManyWithoutUserProcessNestedInput
  }

  export type UserProcessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingId?: StringFieldUpdateOperationsInput | string
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: UserProcessStepUncheckedUpdateManyWithoutProcessNestedInput
    todos?: TodoUserProcessUncheckedUpdateManyWithoutUserProcessNestedInput
  }

  export type UserProcessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingId?: StringFieldUpdateOperationsInput | string
    processId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatedJobPostingUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByType?: EnumCreatedByEnumFieldUpdateOperationsInput | $Enums.CreatedByEnum
    source?: NullableEnumJobSourceEnumFieldUpdateOperationsInput | $Enums.JobSourceEnum | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobPosting?: JobPostingUpdateOneRequiredWithoutCreatedJobPostingNestedInput
  }

  export type CreatedJobPostingUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    createdByType?: EnumCreatedByEnumFieldUpdateOperationsInput | $Enums.CreatedByEnum
    source?: NullableEnumJobSourceEnumFieldUpdateOperationsInput | $Enums.JobSourceEnum | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CreatedJobPostingUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobPostingId?: StringFieldUpdateOperationsInput | string
    createdByType?: EnumCreatedByEnumFieldUpdateOperationsInput | $Enums.CreatedByEnum
    source?: NullableEnumJobSourceEnumFieldUpdateOperationsInput | $Enums.JobSourceEnum | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPipelineStepCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    step?: UserProcessStepUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type UserPipelineStepCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userPipelineStepId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
  }

  export type UserPipelineStepCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userPipelineStepId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessStepUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    process?: ProcessUpdateOneRequiredWithoutStepsNestedInput
    triggers?: TriggerDefinitionUpdateManyWithoutStepNestedInput
    actions?: ActionDefinitionUpdateManyWithoutStepNestedInput
    userProcessSteps?: UserProcessStepUpdateManyWithoutStepNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    triggers?: TriggerDefinitionUncheckedUpdateManyWithoutStepNestedInput
    actions?: ActionDefinitionUncheckedUpdateManyWithoutStepNestedInput
    userProcessSteps?: UserProcessStepUncheckedUpdateManyWithoutStepNestedInput
  }

  export type ProcessStepUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ProcessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    steps?: ProcessStepUpdateManyWithoutProcessNestedInput
    processes?: UserProcessUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    steps?: ProcessStepUncheckedUpdateManyWithoutProcessNestedInput
    processes?: UserProcessUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TodoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TodoItemUpdateManyWithoutTodoNestedInput
    userProcesses?: TodoUserProcessUpdateManyWithoutTodoNestedInput
  }

  export type TodoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TodoItemUncheckedUpdateManyWithoutTodoNestedInput
    userProcesses?: TodoUserProcessUncheckedUpdateManyWithoutTodoNestedInput
  }

  export type TodoUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyCompanyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: string | null
    image?: string | null
  }

  export type JobPostingCreateManyCompanyInput = {
    id?: string
    title: string
    companyName: string
    companyLogo?: string | null
    jobPostingUrl: string
    jobDescription: string
    markdownText: string
    status?: string
    endsAt?: string | null
    createdAt?: string
    updatedAt?: string
  }

  export type UserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUpdateManyWithoutUserNestedInput
    createdJobPostings?: CreatedJobPostingUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUpdateManyWithoutUserNestedInput
    processes?: ProcessUpdateManyWithoutUserNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: ProviderUncheckedUpdateManyWithoutUserNestedInput
    applications?: JobApplicantsUncheckedUpdateManyWithoutUserNestedInput
    userProcess?: UserProcessUncheckedUpdateManyWithoutUserNestedInput
    createdJobPostings?: CreatedJobPostingUncheckedUpdateManyWithoutCreatedByNestedInput
    userPipelineStepComments?: UserPipelineStepCommentUncheckedUpdateManyWithoutUserNestedInput
    processSteps?: ProcessStepUncheckedUpdateManyWithoutUserNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutUserNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobPostingUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    language?: JobPostingLanguageUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUpdateOneWithoutJobPostingNestedInput
    userJobApplications?: JobApplicantsUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    language?: JobPostingLanguageUncheckedUpdateManyWithoutJobPostingNestedInput
    jobRequirements?: JobPostingRequirementUncheckedUpdateManyWithoutJobPostingNestedInput
    merits?: JobPostingMeritUncheckedUpdateManyWithoutJobPostingNestedInput
    applicantQualities?: JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingNestedInput
    location?: JobPostingLocationUncheckedUpdateOneWithoutJobPostingNestedInput
    workArrengment?: JobPostingWorkArrengmentUncheckedUpdateOneWithoutJobPostingNestedInput
    employmentType?: JobPostingEmploymentTypeUncheckedUpdateOneWithoutJobPostingNestedInput
    salary?: JobPostingSalaryUncheckedUpdateOneWithoutJobPostingNestedInput
    createdJobPosting?: CreatedJobPostingUncheckedUpdateOneWithoutJobPostingNestedInput
    userJobApplications?: JobApplicantsUncheckedUpdateManyWithoutJobPostingNestedInput
    userProcesses?: UserProcessUncheckedUpdateManyWithoutJobPostingNestedInput
  }

  export type JobPostingUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyLogo?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingUrl?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    markdownText?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endsAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingLanguageCreateManyJobPostingInput = {
    id?: string
    language: string
    level?: string | null
  }

  export type JobPostingRequirementCreateManyJobPostingInput = {
    id?: string
    requirement: string
  }

  export type JobPostingMeritCreateManyJobPostingInput = {
    id?: string
    merit: string
  }

  export type JobPostingApplicantQualityCreateManyJobPostingInput = {
    id?: string
    quality: string
  }

  export type JobApplicantsCreateManyJobPostingInput = {
    id?: string
    userId: string
    status?: string
    appliedAt: string
    gotJob?: boolean
  }

  export type UserProcessCreateManyJobPostingInput = {
    id?: string
    userId: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    processId?: string | null
  }

  export type JobPostingLanguageUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobPostingLanguageUncheckedUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobPostingLanguageUncheckedUpdateManyWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobPostingRequirementUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirement?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingRequirementUncheckedUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirement?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingRequirementUncheckedUpdateManyWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirement?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingMeritUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    merit?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingMeritUncheckedUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    merit?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingMeritUncheckedUpdateManyWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    merit?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingApplicantQualityUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingApplicantQualityUncheckedUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostingApplicantQualityUncheckedUpdateManyWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
  }

  export type JobApplicantsUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    appliedAt?: StringFieldUpdateOperationsInput | string
    gotJob?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type JobApplicantsUncheckedUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    appliedAt?: StringFieldUpdateOperationsInput | string
    gotJob?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobApplicantsUncheckedUpdateManyWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    appliedAt?: StringFieldUpdateOperationsInput | string
    gotJob?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserProcessUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserProcessNestedInput
    steps?: UserProcessStepUpdateManyWithoutProcessNestedInput
    process?: ProcessUpdateOneWithoutProcessesNestedInput
    todos?: TodoUserProcessUpdateManyWithoutUserProcessNestedInput
  }

  export type UserProcessUncheckedUpdateWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    steps?: UserProcessStepUncheckedUpdateManyWithoutProcessNestedInput
    todos?: TodoUserProcessUncheckedUpdateManyWithoutUserProcessNestedInput
  }

  export type UserProcessUncheckedUpdateManyWithoutJobPostingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProcessStepCreateManyProcessInput = {
    id?: string
    stepId?: string | null
    isExecuted?: boolean
    executedAt?: string | null
  }

  export type TodoUserProcessCreateManyUserProcessInput = {
    id?: string
    todoId: string
  }

  export type UserProcessStepUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    executedAt?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: UserPipelineStepCommentUpdateManyWithoutStepNestedInput
    step?: ProcessStepUpdateOneWithoutUserProcessStepsNestedInput
  }

  export type UserProcessStepUncheckedUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: NullableStringFieldUpdateOperationsInput | string | null
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    executedAt?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: UserPipelineStepCommentUncheckedUpdateManyWithoutStepNestedInput
  }

  export type UserProcessStepUncheckedUpdateManyWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: NullableStringFieldUpdateOperationsInput | string | null
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    executedAt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TodoUserProcessUpdateWithoutUserProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    todo?: TodoUpdateOneRequiredWithoutUserProcessesNestedInput
  }

  export type TodoUserProcessUncheckedUpdateWithoutUserProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    todoId?: StringFieldUpdateOperationsInput | string
  }

  export type TodoUserProcessUncheckedUpdateManyWithoutUserProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    todoId?: StringFieldUpdateOperationsInput | string
  }

  export type UserPipelineStepCommentCreateManyStepInput = {
    id?: string
    userId: string
    comment: string
    createdAt: string
  }

  export type UserPipelineStepCommentUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserPipelineStepCommentsNestedInput
  }

  export type UserPipelineStepCommentUncheckedUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
  }

  export type UserPipelineStepCommentUncheckedUpdateManyWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessStepCreateManyProcessInput = {
    id?: string
    title: string
    description: string
    icon?: string | null
    order: number
    userId?: string | null
  }

  export type UserProcessCreateManyProcessInput = {
    id?: string
    userId: string
    status?: $Enums.StatusUserJobProcesses
    startedAt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: string | null
    jobPostingId: string
  }

  export type ProcessStepUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    triggers?: TriggerDefinitionUpdateManyWithoutStepNestedInput
    actions?: ActionDefinitionUpdateManyWithoutStepNestedInput
    user?: UserUpdateOneWithoutProcessStepsNestedInput
    userProcessSteps?: UserProcessStepUpdateManyWithoutStepNestedInput
  }

  export type ProcessStepUncheckedUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: TriggerDefinitionUncheckedUpdateManyWithoutStepNestedInput
    actions?: ActionDefinitionUncheckedUpdateManyWithoutStepNestedInput
    userProcessSteps?: UserProcessStepUncheckedUpdateManyWithoutStepNestedInput
  }

  export type ProcessStepUncheckedUpdateManyWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProcessUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserProcessNestedInput
    steps?: UserProcessStepUpdateManyWithoutProcessNestedInput
    jobPosting?: JobPostingUpdateOneWithoutUserProcessesNestedInput
    todos?: TodoUserProcessUpdateManyWithoutUserProcessNestedInput
  }

  export type UserProcessUncheckedUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingId?: StringFieldUpdateOperationsInput | string
    steps?: UserProcessStepUncheckedUpdateManyWithoutProcessNestedInput
    todos?: TodoUserProcessUncheckedUpdateManyWithoutUserProcessNestedInput
  }

  export type UserProcessUncheckedUpdateManyWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusUserJobProcessesFieldUpdateOperationsInput | $Enums.StatusUserJobProcesses
    startedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    jobPostingId?: StringFieldUpdateOperationsInput | string
  }

  export type TriggerDefinitionCreateManyStepInput = {
    id?: string
    order: number
    isPublic?: boolean
    createdBy: string
    triggerCode: string
    executeWhen?: $Enums.TriggerEventCode | null
    executeAt?: string | null
    combinator?: $Enums.CombinatorEnum | null
    config: JsonNullValueInput | InputJsonValue
    expiration?: string | null
  }

  export type ActionDefinitionCreateManyStepInput = {
    id?: string
    name: string
    isPublic?: boolean
    order: number
    config: JsonNullValueInput | InputJsonValue
  }

  export type UserProcessStepCreateManyStepInput = {
    id?: string
    userProcessId: string
    isExecuted?: boolean
    executedAt?: string | null
  }

  export type TriggerDefinitionUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    triggerCode?: StringFieldUpdateOperationsInput | string
    executeWhen?: NullableEnumTriggerEventCodeFieldUpdateOperationsInput | $Enums.TriggerEventCode | null
    executeAt?: NullableStringFieldUpdateOperationsInput | string | null
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
    config?: JsonNullValueInput | InputJsonValue
    expiration?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: ConditionalUpdateManyWithoutTriggerNestedInput
  }

  export type TriggerDefinitionUncheckedUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    triggerCode?: StringFieldUpdateOperationsInput | string
    executeWhen?: NullableEnumTriggerEventCodeFieldUpdateOperationsInput | $Enums.TriggerEventCode | null
    executeAt?: NullableStringFieldUpdateOperationsInput | string | null
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
    config?: JsonNullValueInput | InputJsonValue
    expiration?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: ConditionalUncheckedUpdateManyWithoutTriggerNestedInput
  }

  export type TriggerDefinitionUncheckedUpdateManyWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    triggerCode?: StringFieldUpdateOperationsInput | string
    executeWhen?: NullableEnumTriggerEventCodeFieldUpdateOperationsInput | $Enums.TriggerEventCode | null
    executeAt?: NullableStringFieldUpdateOperationsInput | string | null
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
    config?: JsonNullValueInput | InputJsonValue
    expiration?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActionDefinitionUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    config?: JsonNullValueInput | InputJsonValue
  }

  export type ActionDefinitionUncheckedUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    config?: JsonNullValueInput | InputJsonValue
  }

  export type ActionDefinitionUncheckedUpdateManyWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    config?: JsonNullValueInput | InputJsonValue
  }

  export type UserProcessStepUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    executedAt?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: UserPipelineStepCommentUpdateManyWithoutStepNestedInput
    process?: UserProcessUpdateOneRequiredWithoutStepsNestedInput
  }

  export type UserProcessStepUncheckedUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProcessId?: StringFieldUpdateOperationsInput | string
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    executedAt?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: UserPipelineStepCommentUncheckedUpdateManyWithoutStepNestedInput
  }

  export type UserProcessStepUncheckedUpdateManyWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProcessId?: StringFieldUpdateOperationsInput | string
    isExecuted?: BoolFieldUpdateOperationsInput | boolean
    executedAt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConditionalCreateManyTriggerInput = {
    id?: string
    fieldKey: string
    fieldKeyLabel: string
    operator: $Enums.ComparisonOperatorEnum
    comparisonValue: string
    combinator?: $Enums.CombinatorEnum | null
  }

  export type ConditionalUpdateWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldKeyLabel?: StringFieldUpdateOperationsInput | string
    operator?: EnumComparisonOperatorEnumFieldUpdateOperationsInput | $Enums.ComparisonOperatorEnum
    comparisonValue?: StringFieldUpdateOperationsInput | string
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
  }

  export type ConditionalUncheckedUpdateWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldKeyLabel?: StringFieldUpdateOperationsInput | string
    operator?: EnumComparisonOperatorEnumFieldUpdateOperationsInput | $Enums.ComparisonOperatorEnum
    comparisonValue?: StringFieldUpdateOperationsInput | string
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
  }

  export type ConditionalUncheckedUpdateManyWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldKey?: StringFieldUpdateOperationsInput | string
    fieldKeyLabel?: StringFieldUpdateOperationsInput | string
    operator?: EnumComparisonOperatorEnumFieldUpdateOperationsInput | $Enums.ComparisonOperatorEnum
    comparisonValue?: StringFieldUpdateOperationsInput | string
    combinator?: NullableEnumCombinatorEnumFieldUpdateOperationsInput | $Enums.CombinatorEnum | null
  }

  export type TodoItemCreateManyTodoInput = {
    id?: string
    type: $Enums.TodoItemTypeEnum
    content: string
    order: number
  }

  export type TodoUserProcessCreateManyTodoInput = {
    id?: string
    userProcessId: string
  }

  export type TodoItemUpdateWithoutTodoInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTodoItemTypeEnumFieldUpdateOperationsInput | $Enums.TodoItemTypeEnum
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TodoItemUncheckedUpdateWithoutTodoInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTodoItemTypeEnumFieldUpdateOperationsInput | $Enums.TodoItemTypeEnum
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TodoItemUncheckedUpdateManyWithoutTodoInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTodoItemTypeEnumFieldUpdateOperationsInput | $Enums.TodoItemTypeEnum
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TodoUserProcessUpdateWithoutTodoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProcess?: UserProcessUpdateOneRequiredWithoutTodosNestedInput
  }

  export type TodoUserProcessUncheckedUpdateWithoutTodoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProcessId?: StringFieldUpdateOperationsInput | string
  }

  export type TodoUserProcessUncheckedUpdateManyWithoutTodoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProcessId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}